<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DispatchGroup出现EXC_BAD_INSTRUCTION问题</title>
    <link href="/2020/06/25/DispatchGroup%E5%87%BA%E7%8E%B0EXC-BAD-INSTRUCTION%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/25/DispatchGroup%E5%87%BA%E7%8E%B0EXC-BAD-INSTRUCTION%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看app的线上奔溃总是出现意义不明的崩溃问题，而且崩溃栈出现在闭包的回调里，并且bugly上提示说是有可能在swift解包的时候出现问题，也就是对nil使用了!。这就完全误导了我，把我对问题的理解定义为数据保护的不够到位。结果就是在多次发版后这个问题还未得到解决，所以我绝对对这个问题一探究竟。</p><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><p>其实出现这个问题的原因很简单，那就是group的enter和leave没有成对出现。比如说我们会在闭包的回调里去leave，但是闭包有可能返回多次，一旦多leave了，那么就会出现<strong>EXC_BAD_INSTRUCTION</strong>这个问题。</p><p>举个例子</p><p>我们声明如下两个方法，可以看出来work2回调了两次</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work1</span><span class="hljs-params">(closure: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;    sleep(<span class="hljs-number">1</span>)    closure()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work2</span><span class="hljs-params">(closure: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;    closure()    sleep(<span class="hljs-number">2</span>)    closure()&#125;</code></pre></div><p>接着我们使用它们</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">super</span>.viewDidLoad()        <span class="hljs-keyword">let</span> group = <span class="hljs-type">DispatchGroup</span>()    <span class="hljs-keyword">let</span> queue = <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">"test"</span>, qos: .background, attributes: .concurrent, autoreleaseFrequency: .inherit, target: <span class="hljs-literal">nil</span>)        group.enter()    queue.async &#123;        <span class="hljs-keyword">self</span>.work1 &#123;            group.leave()        &#125;    &#125;        group.enter()    queue.async &#123;        <span class="hljs-keyword">self</span>.work2 &#123;            group.leave()        &#125;    &#125;        group.notify(queue: queue) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">"同步完成"</span>)    &#125;&#125;</code></pre></div><p>这里可以看出来在work2的闭包的leave就会出现这个问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>其实这种问题完全使我们编写代码的过程中不够细心导致的，通过完善的测试用例完全可以避免问题发生，但是我们还是需要记住一句话<strong>DispatchGroup的enter和leave必须成对出现!!!</strong></p>]]></content>
    
    
    <categories>
      
      <category>Crash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UITableView和UICollectionView实现自定义滚动动画</title>
    <link href="/2020/06/25/UITableView%E5%92%8CUICollectionView%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB/"/>
    <url>/2020/06/25/UITableView%E5%92%8CUICollectionView%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到这个标题你可能会觉得“这不是很简单吗？像下面这么一写就完了呗”</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">UIView</span><span class="hljs-selector-class">.animate</span>(<span class="hljs-attribute">withDuration</span>: <span class="hljs-number">0.25</span>) &#123;    <span class="hljs-selector-tag">self</span><span class="hljs-selector-class">.tableView</span><span class="hljs-selector-class">.setContentOffset</span>(CGPoint(<span class="hljs-attribute">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">y</span>: <span class="hljs-number">500</span>), <span class="hljs-attribute">animated</span>: false)&#125;</code></pre></div><p>不不不，如果你觉得就这么简单的话说明你还是太年轻了。这样写你的列表在滚动的一开始上面的cell就消失了，这种效果是完全过不了产品和视觉小姐姐的像素眼。</p><p>为了实现自定义滚动动效我们可以使用CADisplayLink来实现，至于为什么不用其他timer相信大家可以自己百度了解。</p><p>当然如果你并不想那么麻烦的自己写的话可以使用Facebook出品的Pop动画库，它也是基于CADisplayLink实现的。由于UIScrollView的滚动原理，我们可以用<code>POPBasicAnimation</code>设置UIScrollView的<code>bounds</code>属性动画即可。</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://github.com/qyz777/scroll_animation" target="_blank" rel="noopener">自定义列表滚动动效</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h2><p>首先我们先实现实际动画的类<code>ScrollViewAnimator</code>。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollViewAnimator</span> </span>&#123;        <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> scrollView: <span class="hljs-type">UIScrollView?</span>    <span class="hljs-keyword">let</span> timingFunction: <span class="hljs-type">ScrollTimingFunction</span>        <span class="hljs-keyword">var</span> closure: (() -&gt; <span class="hljs-type">Void</span>)?        <span class="hljs-comment">//动画开始时间</span>    <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>    <span class="hljs-comment">//动画初始的contentOffset</span>    <span class="hljs-keyword">var</span> startOffset: <span class="hljs-type">CGPoint</span> = .zero    <span class="hljs-comment">//动画目标的contentOffset</span>    <span class="hljs-keyword">var</span> destinationOffset: <span class="hljs-type">CGPoint</span> = .zero    <span class="hljs-comment">//动画时长</span>    <span class="hljs-keyword">var</span> duration: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>    <span class="hljs-comment">//动画已运行时长</span>    <span class="hljs-keyword">var</span> runTime: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>        <span class="hljs-keyword">var</span> timer: <span class="hljs-type">CADisplayLink?</span>        <span class="hljs-keyword">init</span>(scrollView: <span class="hljs-type">UIScrollView</span>, timingFunction: <span class="hljs-type">ScrollTimingFunction</span>) &#123;        <span class="hljs-keyword">self</span>.scrollView = scrollView        <span class="hljs-keyword">self</span>.timingFunction = timingFunction    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setContentOffset</span><span class="hljs-params">(<span class="hljs-number">_</span> contentOffset: CGPoint, duration: TimeInterval)</span></span> &#123;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scrollView = scrollView <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-comment">//设置需要的属性</span>        startTime = <span class="hljs-type">Date</span>().timeIntervalSince1970        startOffset = scrollView.contentOffset        destinationOffset = contentOffset        <span class="hljs-keyword">self</span>.duration = duration        runTime = <span class="hljs-number">0</span>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">self</span>.duration &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> &#123;            scrollView.setContentOffset(contentOffset, animated: <span class="hljs-literal">false</span>)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">if</span> timer == <span class="hljs-literal">nil</span> &#123;            timer = <span class="hljs-type">CADisplayLink</span>(target: <span class="hljs-keyword">self</span>, selector: #selector(animtedScroll))            <span class="hljs-comment">//把timer加入到common的runloop中</span>            timer?.add(to: .main, forMode: .common)        &#125;    &#125;        <span class="hljs-meta">@objc</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animtedScroll</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> timer = timer <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scrollView = scrollView <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;        <span class="hljs-comment">//由于CADisplayLink每次回调的时间不固定，所以使用它自己记录的回调时间来增加运行时长</span>        runTime += timer.duration        <span class="hljs-keyword">if</span> runTime &gt;= duration &#123;            <span class="hljs-comment">//如果运行时长超过动画时长说明动画需要结束了</span>            scrollView.setContentOffset(destinationOffset, animated: <span class="hljs-literal">false</span>)            timer.invalidate()            <span class="hljs-keyword">self</span>.timer = <span class="hljs-literal">nil</span>            closure?()            <span class="hljs-keyword">return</span>        &#125;                <span class="hljs-keyword">var</span> offset = scrollView.contentOffset        offset.x = timingFunction.compute(<span class="hljs-type">CGFloat</span>(runTime), startOffset.x, destinationOffset.x - startOffset.x, <span class="hljs-type">CGFloat</span>(duration))        offset.y = timingFunction.compute(<span class="hljs-type">CGFloat</span>(runTime), startOffset.y, destinationOffset.y - startOffset.y, <span class="hljs-type">CGFloat</span>(duration))        scrollView.setContentOffset(offset, animated: <span class="hljs-literal">false</span>)    &#125;    &#125;</code></pre></div><h2 id="UIScrollView拓展"><a href="#UIScrollView拓展" class="headerlink" title="UIScrollView拓展"></a>UIScrollView拓展</h2><p>我们用OC的runtime知识动态为分类添加属性方便使用</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIScrollView</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AssociatedKeys</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> animator: <span class="hljs-type">String</span> = <span class="hljs-string">"animator"</span>    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> animator: <span class="hljs-type">ScrollViewAnimator?</span> &#123;        <span class="hljs-keyword">set</span> &#123;            objc_setAssociatedObject(<span class="hljs-keyword">self</span>, &amp;<span class="hljs-type">AssociatedKeys</span>.animator, newValue, .<span class="hljs-type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)        &#125;        <span class="hljs-keyword">get</span> &#123;            <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, &amp;<span class="hljs-type">AssociatedKeys</span>.animator) <span class="hljs-keyword">as</span>? <span class="hljs-type">ScrollViewAnimator</span>        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setContentOffset</span><span class="hljs-params">(<span class="hljs-number">_</span> contentOffset: CGPoint, duration: TimeInterval, timingFunction: ScrollTimingFunction = .linear, completion: <span class="hljs-params">(<span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)? = <span class="hljs-literal">nil</span>) &#123;        <span class="hljs-keyword">if</span> animator == <span class="hljs-literal">nil</span> &#123;            animator = <span class="hljs-type">ScrollViewAnimator</span>(scrollView: <span class="hljs-keyword">self</span>, timingFunction: timingFunction)        &#125;        animator!.closure = &#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> strongSelf = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;            <span class="hljs-type">DispatchQueue</span>.main.async &#123;                strongSelf.animator = <span class="hljs-literal">nil</span>            &#125;            completion?()        &#125;        animator!.setContentOffset(contentOffset, duration: duration)    &#125;    &#125;</code></pre></div><h2 id="ScrollTimingFunction枚举"><a href="#ScrollTimingFunction枚举" class="headerlink" title="ScrollTimingFunction枚举"></a>ScrollTimingFunction枚举</h2><p>动画缓冲函数的实现可以参考<a href="http://robertpenner.com/easing/" target="_blank" rel="noopener">http://robertpenner.com/easing/</a>。具体实现例子在<a href="https://github.com/qyz777/scroll_animation" target="_blank" rel="noopener">Demo</a>中</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://robertpenner.com/easing/" target="_blank" rel="noopener">http://robertpenner.com/easing/</a><br><a href="https://blog.csdn.net/S_clifftop/article/details/89490422" target="_blank" rel="noopener">https://blog.csdn.net/S_clifftop/article/details/89490422</a><br><a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="noopener">https://zsisme.gitbooks.io/ios-/content/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
