<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大二至大三实习一年，你想知道的这里都有</title>
    <link href="/2020/06/25/%E5%A4%A7%E4%BA%8C%E8%87%B3%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0%E4%B8%80%E5%B9%B4%EF%BC%8C%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%99%E9%87%8C%E9%83%BD%E6%9C%89/"/>
    <url>/2020/06/25/%E5%A4%A7%E4%BA%8C%E8%87%B3%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0%E4%B8%80%E5%B9%B4%EF%BC%8C%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%99%E9%87%8C%E9%83%BD%E6%9C%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我还很清晰的记得2018年4月25日是我第一天实习，在这步入社会的一年里，我的心态发生了很大的变化。说是一年，其实也并不是完整的一年，我在18年9月份的时候休息了整整一个月，当然也顺便利用这段时间去面试拿到了下一个offer。因为第一次实习发现工作真的是太累了，能理解到长辈赚钱真的很不容易，我自己也体会到当码农的感觉。写代码是我的一个爱好，尤其是写iOS。但是当爱好转化为我的工作进行输出时，我在工作的时间内就不会觉得那会让我愉悦了，而会让我很疲惫。</p><p>一年来不断有学弟学妹问我怎么做到大二出去实习的，ta想向我学习该怎么做。鉴于总是有人问，我觉得这个事情可以记录下来作为我的一个生活和反思相关的blog吧。</p><p>重要的话先写到最前面，经过一年的实习，我本人认为尽可能<strong>避免大二出去实习</strong>。</p><h1 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h1><p>在你想要了解我是如何做到大二出去实习的之前，你应该仔细思考一下自己究竟想要什么，这个是十分重要的。如果你要考研，那么这条路对你来说非常不合适。如果你要毕业就工作，那么这条路对你来说<strong>也许</strong>会合适。</p><h1 id="如何大二出去实习"><a href="#如何大二出去实习" class="headerlink" title="如何大二出去实习"></a>如何大二出去实习</h1><h2 id="保证你的学习成绩"><a href="#保证你的学习成绩" class="headerlink" title="保证你的学习成绩"></a>保证你的学习成绩</h2><p>最重要也是最关键的一点，你得保证你不能挂科。因为你一旦挂科就意味着你接下来的学期就会有更多的事情积压在你的身上，你的包袱就会越来越大直到压着你喘不过气，当然如果你抗压能力足够强大，即使有包袱也没啥对吧。看到这里一定会有同学好奇了，那去外面实习都不上课，怎么能不挂科呢？这个说起来真是个技术活。</p><p>那么翘课最重要的技能是什么呢？是学会沟通。在我看来沟通技能是十分重要的，尽管你以后有可能是个程序员，但是作为软件工程师，沟通这个技能非常重要。首先你需要让老师意识到你是个能力足够的孩子，你考试能过，实验也ok，技术也ok。如何证明你技术ok呢？你可以拿到offer以后再去跟老师商量。你需要让老师知道你是本科毕业就工作的，不会考虑考研。其次，既然你想要出去实习，那分数肯定不会那么好看，世界上没有这么好的事情。那么平时分能跟老师争取到及格最好，不行的话那就看自己考试和实验成绩咯。这一年来我有N门课的平时分不及格，但我一样能过。提醒一下，与老师沟通的时候态度很重要，你要上去说话就冲，一副自己最牛逼的样子，那肯定不会让你出去的。最后，有些老师就是不放你出去怎么办呢？我的答案就是没办法，老老实实上课呗。其实也有办法，那就看你人际交往关系如何了XD。</p><h2 id="足够的技术能力"><a href="#足够的技术能力" class="headerlink" title="足够的技术能力"></a>足够的技术能力</h2><p>这个也一样是必须满足的条件，如果你满足不了这个条件，我相信你连offer都拿不到。那么如何保证大二的自己拥有足够的技术能力呢？不说别的，我校大一上那C语言那么简单，不考个满分说不过去吧？大一下那C++/Java也很简单，不说满分，也得考个90+吧。说这些什么意思就是要在大一打好编程基础。出去实习是很硬核的，人家公司就是要招个实习生过来写业务的，不是白养你的，尤其是创业公司，所以一定会对你的技术有要求。</p><p>在大一打好基础是远远不够的，为什么不够呢，因为你还没有一个有一定深度了解的方向。可以是前端、后端或者是客户端，像我就是一直在写iOS，所以一定要有一个自己专研过的方向。但是你自己的专研不够呀，你没有经验啊，怎么办呢？我认为最好的解决方案就是不要放过学长学姐提供的机会。其实很多学长学姐都有非常好的能够让你实践的机会，要么是你没发现，要么是你懒，<strong>机会都是自己把握的</strong>。不断的把握机会就会让别人觉得你靠谱，下一次还有这种机会也会继续找你。当你让你身边的人意识到你靠谱的时候，有些事情你就要看情况接手了，因为这个时候可能你已经非常忙了。我有一段时间很懊悔自己抓住了太多事情而让自己忙到没有休息的时间，我目前最高记录是并行处理4件事吧，那几个月忙到没工夫花钱，花呗一个月花了7块hhh。</p><p>抓住了不少机会后，我相信你在我校的同级学生中已经拥有一份还可以的简历了，这个时候你可能还是不具备拿到offer的条件。为什么呢？因为你没有面试经验。我认为最好的解决办法就是直接去面试。App Store打开找到几个实习找工作的App一顿下载，比如实习僧、Boss直聘和拉钩之类的，然后打开App一顿猛投，接着就等HR给你打电话吧。具体的面试踩坑细节就不展开了，说一些一开始需要注意的吧。我还记得我的第一份工作的Boss上来问我的第一句是：“哦，大四了吧”，我说：“我才大二”。我能明显的看到Boss身体一震，一脸惊讶。Boss问我是否有时间，这个时候我就是把我的真实情况告诉他，但是我强调了我是可以调出足够的时间实习的。</p><p>至于如何找到一家靠谱的实习公司这里也不展开说了，但是有一点很重要，你要是实习没工资，那绝对不靠谱。</p><h2 id="保证你自己的时间"><a href="#保证你自己的时间" class="headerlink" title="保证你自己的时间"></a>保证你自己的时间</h2><p>这一条不是必须的，但是我觉得对我来说是必须的。因为拥有自己的时间才能继续提高自己，大二出去实习所拥有的技术水平和真正毕业所面对的校招要求的技术水平还是有很大差距的。也正是因为如此，大二出去实习就会异常的忙碌，你还需要抽出时间来学习和提高自己。我刚上班的那一两个月，每天下班回来就想休息或者打游戏，其他啥也不想干了，因为很累。但是一段时间后我就觉得这样是不行的，我开始下班回来接着做自己的事情或者学习和提高自己。之所以能做到这样是因为一方面我逐渐适应了这样的生活，除了发版前之外并不会感到特别疲惫了，另一方面是我足够自律。所以为了前程考虑，大二出去实习还得足够的自律。</p><h1 id="为何需要大二出去实习"><a href="#为何需要大二出去实习" class="headerlink" title="为何需要大二出去实习"></a>为何需要大二出去实习</h1><p>我想说道这个事情，可能就会有很多人想到要尽快提升自己的能力balabala。这个说的没错，不管自己在学校搞什么项目，终究是学习主导的，并没有经过企业级历练，是不完善的。经过企业开发实战，无论从技术还是从眼界来看，都会有较大提升。</p><p>不过我个人认为还是有其他必要原因的，比如说现在互联网就业环境不好以及门槛较高，身在象牙塔中的学生可能并未意识到这件事情。尤其我校并不是名校，起点可以算是非常低了，为了校招能得到大厂的面试机会，一份丰富的简历是很有必要的，而一份丰富的简历所必要的就是实习经验。这里有一点要强调一下，能被面试，说明你已经过了简历筛选，意味着之后的流程与你在哪个学校无关，<strong>也意味着之后的流程需要靠你的真本事</strong>。</p><p>至于我个人必须大二出去实习的原因则是我大二下的时候没有生活费了XD，为了活下去我只好出去实习咯hhh。</p><h1 id="为什么我不建议大二出去实习"><a href="#为什么我不建议大二出去实习" class="headerlink" title="为什么我不建议大二出去实习"></a>为什么我不建议大二出去实习</h1><p>上面说了这么多如何做，来讲讲为什么我在前言里说不建议大二出去实习。我是没有生活费没办法，但是读这篇文章的你不一定。</p><h2 id="占用你的大量时间"><a href="#占用你的大量时间" class="headerlink" title="占用你的大量时间"></a>占用你的大量时间</h2><p>北京的计算机相关工作都集中在西二旗、知春路、中关村、马连洼、上地和望京，你可以计算一下你的路程花费的时间，然后再加上965的工作时间，看看总共多少时间。大学的时候要花大量的时间来打基础，我一开始就觉得深入掌握一门技术即可，但结果就是我现在在回头补计算机网络、操作系统以及算法。很多公司面试的时候并不care你在这个方向上有多少深度，在他们看来，3年以内的工作经验跟应届都差不多。他们往往在乎你基础是否扎实，是否能手写算法，因为这些才是计算机体系中几乎不变的，而就业方向与其所需技能是容易变的。下面是我某一周的时间安排。</p><p><img src="http://cdn.qyizhong.cn/8216167-50ecaed6844986bd.jpg" srcset="/img/loading.gif" alt="我一周的时间安排"></p><h2 id="压力太大"><a href="#压力太大" class="headerlink" title="压力太大"></a>压力太大</h2><p>我校大四之前是不允许实习的，也就是说一旦出去就要面对学校的学习压力以及工作压力。学习压力还是小事，因为我校的考试确实不会很难。但是工作压力是个大事，我们在自己做项目的时候buffer是很充足的，有的时候真不想写了可以缓一缓明天再写，可是工作中就不能这样了，做不完你可走不了。讲道理是下班时间到了你就可以走，可要是项目进度卡在你这里你敢走吗？我一年来坚信着不能让事情卡在我这里的道理，但是我又想早点回去，所以很多时候我都会牺牲中午的休息时间。当然目前我在网易的工作会轻松一些，一方面是自己的技能越来越熟练了，另一方面是自己接手的需求都会自己预估工期，会给自己预留buffer。</p><p>看到这里吧，我相信有些人会觉得压力大没关系，我也行。我这里只提醒一下，一旦选择这条路，你就马上要并行处理两条线的事情，分别是工作与学校的事情。在学校的时候觉得学校的事情没什么，但你工作的时候突然有个学校的事情就不会让你心情舒服了。接着你还要提升自己的实力，于是你又多开了一个线程用来学习和提升自己的能力，所以在我看来，最终的你至少并行在做三件事。不过我认为这是自己的选择，但是在选择之前还是思考一下<strong>自己到底要什么</strong>。</p><p>当然，我不推荐的是大二的日常实习，如果有暑期实习的机会，这个机会一定不要放过。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>一年的实习经验让我经历了不少有趣的事情，也让我见识到了市场的残酷，而我逐渐的意识到自己只是个普通人。如果问我是否后悔，我不会后悔，因为这是我当时最好的选择。曾经有人问我“你以后还有几十年要工作，为什么那么着急？”。当时我只觉得不着急就会被淘汰，现在反思后却觉得在大二这个时间点，我努力的方向却不是那么对。</p><p>最后的最后，用一句话总结我一年来最大也是最多的体会：“小时候真傻，竟然期望长大”。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DispatchGroup出现EXC_BAD_INSTRUCTION问题</title>
    <link href="/2020/06/25/DispatchGroup%E5%87%BA%E7%8E%B0EXC-BAD-INSTRUCTION%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/25/DispatchGroup%E5%87%BA%E7%8E%B0EXC-BAD-INSTRUCTION%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看app的线上奔溃总是出现意义不明的崩溃问题，而且崩溃栈出现在闭包的回调里，并且bugly上提示说是有可能在swift解包的时候出现问题，也就是对nil使用了!。这就完全误导了我，把我对问题的理解定义为数据保护的不够到位。结果就是在多次发版后这个问题还未得到解决，所以我绝对对这个问题一探究竟。</p><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><p>其实出现这个问题的原因很简单，那就是group的enter和leave没有成对出现。比如说我们会在闭包的回调里去leave，但是闭包有可能返回多次，一旦多leave了，那么就会出现<strong>EXC_BAD_INSTRUCTION</strong>这个问题。</p><p>举个例子</p><p>我们声明如下两个方法，可以看出来work2回调了两次</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work1</span><span class="hljs-params">(closure: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;    sleep(<span class="hljs-number">1</span>)    closure()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work2</span><span class="hljs-params">(closure: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;    closure()    sleep(<span class="hljs-number">2</span>)    closure()&#125;</code></pre></div><p>接着我们使用它们</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">super</span>.viewDidLoad()        <span class="hljs-keyword">let</span> group = <span class="hljs-type">DispatchGroup</span>()    <span class="hljs-keyword">let</span> queue = <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">"test"</span>, qos: .background, attributes: .concurrent, autoreleaseFrequency: .inherit, target: <span class="hljs-literal">nil</span>)        group.enter()    queue.async &#123;        <span class="hljs-keyword">self</span>.work1 &#123;            group.leave()        &#125;    &#125;        group.enter()    queue.async &#123;        <span class="hljs-keyword">self</span>.work2 &#123;            group.leave()        &#125;    &#125;        group.notify(queue: queue) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">"同步完成"</span>)    &#125;&#125;</code></pre></div><p>这里可以看出来在work2的闭包的leave就会出现这个问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>其实这种问题完全使我们编写代码的过程中不够细心导致的，通过完善的测试用例完全可以避免问题发生，但是我们还是需要记住一句话<strong>DispatchGroup的enter和leave必须成对出现!!!</strong></p>]]></content>
    
    
    <categories>
      
      <category>Crash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UITableView和UICollectionView实现自定义滚动动画</title>
    <link href="/2020/06/25/UITableView%E5%92%8CUICollectionView%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB/"/>
    <url>/2020/06/25/UITableView%E5%92%8CUICollectionView%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到这个标题你可能会觉得“这不是很简单吗？像下面这么一写就完了呗”</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">UIView</span><span class="hljs-selector-class">.animate</span>(<span class="hljs-attribute">withDuration</span>: <span class="hljs-number">0.25</span>) &#123;    <span class="hljs-selector-tag">self</span><span class="hljs-selector-class">.tableView</span><span class="hljs-selector-class">.setContentOffset</span>(CGPoint(<span class="hljs-attribute">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">y</span>: <span class="hljs-number">500</span>), <span class="hljs-attribute">animated</span>: false)&#125;</code></pre></div><p>不不不，如果你觉得就这么简单的话说明你还是太年轻了。这样写你的列表在滚动的一开始上面的cell就消失了，这种效果是完全过不了产品和视觉小姐姐的像素眼。</p><p>为了实现自定义滚动动效我们可以使用CADisplayLink来实现，至于为什么不用其他timer相信大家可以自己百度了解。</p><p>当然如果你并不想那么麻烦的自己写的话可以使用Facebook出品的Pop动画库，它也是基于CADisplayLink实现的。由于UIScrollView的滚动原理，我们可以用<code>POPBasicAnimation</code>设置UIScrollView的<code>bounds</code>属性动画即可。</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://github.com/qyz777/scroll_animation" target="_blank" rel="noopener">自定义列表滚动动效</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h2><p>首先我们先实现实际动画的类<code>ScrollViewAnimator</code>。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollViewAnimator</span> </span>&#123;        <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> scrollView: <span class="hljs-type">UIScrollView?</span>    <span class="hljs-keyword">let</span> timingFunction: <span class="hljs-type">ScrollTimingFunction</span>        <span class="hljs-keyword">var</span> closure: (() -&gt; <span class="hljs-type">Void</span>)?        <span class="hljs-comment">//动画开始时间</span>    <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>    <span class="hljs-comment">//动画初始的contentOffset</span>    <span class="hljs-keyword">var</span> startOffset: <span class="hljs-type">CGPoint</span> = .zero    <span class="hljs-comment">//动画目标的contentOffset</span>    <span class="hljs-keyword">var</span> destinationOffset: <span class="hljs-type">CGPoint</span> = .zero    <span class="hljs-comment">//动画时长</span>    <span class="hljs-keyword">var</span> duration: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>    <span class="hljs-comment">//动画已运行时长</span>    <span class="hljs-keyword">var</span> runTime: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>        <span class="hljs-keyword">var</span> timer: <span class="hljs-type">CADisplayLink?</span>        <span class="hljs-keyword">init</span>(scrollView: <span class="hljs-type">UIScrollView</span>, timingFunction: <span class="hljs-type">ScrollTimingFunction</span>) &#123;        <span class="hljs-keyword">self</span>.scrollView = scrollView        <span class="hljs-keyword">self</span>.timingFunction = timingFunction    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setContentOffset</span><span class="hljs-params">(<span class="hljs-number">_</span> contentOffset: CGPoint, duration: TimeInterval)</span></span> &#123;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scrollView = scrollView <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-comment">//设置需要的属性</span>        startTime = <span class="hljs-type">Date</span>().timeIntervalSince1970        startOffset = scrollView.contentOffset        destinationOffset = contentOffset        <span class="hljs-keyword">self</span>.duration = duration        runTime = <span class="hljs-number">0</span>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">self</span>.duration &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> &#123;            scrollView.setContentOffset(contentOffset, animated: <span class="hljs-literal">false</span>)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">if</span> timer == <span class="hljs-literal">nil</span> &#123;            timer = <span class="hljs-type">CADisplayLink</span>(target: <span class="hljs-keyword">self</span>, selector: #selector(animtedScroll))            <span class="hljs-comment">//把timer加入到common的runloop中</span>            timer?.add(to: .main, forMode: .common)        &#125;    &#125;        <span class="hljs-meta">@objc</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animtedScroll</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> timer = timer <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scrollView = scrollView <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;        <span class="hljs-comment">//由于CADisplayLink每次回调的时间不固定，所以使用它自己记录的回调时间来增加运行时长</span>        runTime += timer.duration        <span class="hljs-keyword">if</span> runTime &gt;= duration &#123;            <span class="hljs-comment">//如果运行时长超过动画时长说明动画需要结束了</span>            scrollView.setContentOffset(destinationOffset, animated: <span class="hljs-literal">false</span>)            timer.invalidate()            <span class="hljs-keyword">self</span>.timer = <span class="hljs-literal">nil</span>            closure?()            <span class="hljs-keyword">return</span>        &#125;                <span class="hljs-keyword">var</span> offset = scrollView.contentOffset        offset.x = timingFunction.compute(<span class="hljs-type">CGFloat</span>(runTime), startOffset.x, destinationOffset.x - startOffset.x, <span class="hljs-type">CGFloat</span>(duration))        offset.y = timingFunction.compute(<span class="hljs-type">CGFloat</span>(runTime), startOffset.y, destinationOffset.y - startOffset.y, <span class="hljs-type">CGFloat</span>(duration))        scrollView.setContentOffset(offset, animated: <span class="hljs-literal">false</span>)    &#125;    &#125;</code></pre></div><h2 id="UIScrollView拓展"><a href="#UIScrollView拓展" class="headerlink" title="UIScrollView拓展"></a>UIScrollView拓展</h2><p>我们用OC的runtime知识动态为分类添加属性方便使用</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIScrollView</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AssociatedKeys</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> animator: <span class="hljs-type">String</span> = <span class="hljs-string">"animator"</span>    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> animator: <span class="hljs-type">ScrollViewAnimator?</span> &#123;        <span class="hljs-keyword">set</span> &#123;            objc_setAssociatedObject(<span class="hljs-keyword">self</span>, &amp;<span class="hljs-type">AssociatedKeys</span>.animator, newValue, .<span class="hljs-type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)        &#125;        <span class="hljs-keyword">get</span> &#123;            <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, &amp;<span class="hljs-type">AssociatedKeys</span>.animator) <span class="hljs-keyword">as</span>? <span class="hljs-type">ScrollViewAnimator</span>        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setContentOffset</span><span class="hljs-params">(<span class="hljs-number">_</span> contentOffset: CGPoint, duration: TimeInterval, timingFunction: ScrollTimingFunction = .linear, completion: <span class="hljs-params">(<span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)? = <span class="hljs-literal">nil</span>) &#123;        <span class="hljs-keyword">if</span> animator == <span class="hljs-literal">nil</span> &#123;            animator = <span class="hljs-type">ScrollViewAnimator</span>(scrollView: <span class="hljs-keyword">self</span>, timingFunction: timingFunction)        &#125;        animator!.closure = &#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> strongSelf = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;            <span class="hljs-type">DispatchQueue</span>.main.async &#123;                strongSelf.animator = <span class="hljs-literal">nil</span>            &#125;            completion?()        &#125;        animator!.setContentOffset(contentOffset, duration: duration)    &#125;    &#125;</code></pre></div><h2 id="ScrollTimingFunction枚举"><a href="#ScrollTimingFunction枚举" class="headerlink" title="ScrollTimingFunction枚举"></a>ScrollTimingFunction枚举</h2><p>动画缓冲函数的实现可以参考<a href="http://robertpenner.com/easing/" target="_blank" rel="noopener">http://robertpenner.com/easing/</a>。具体实现例子在<a href="https://github.com/qyz777/scroll_animation" target="_blank" rel="noopener">Demo</a>中</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://robertpenner.com/easing/" target="_blank" rel="noopener">http://robertpenner.com/easing/</a><br><a href="https://blog.csdn.net/S_clifftop/article/details/89490422" target="_blank" rel="noopener">https://blog.csdn.net/S_clifftop/article/details/89490422</a><br><a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="noopener">https://zsisme.gitbooks.io/ios-/content/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
