<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>品质优化半年工作的回忆与思考</title>
    <link href="/2021/03/25/%E5%93%81%E8%B4%A8%E4%BC%98%E5%8C%96%E5%8D%8A%E5%B9%B4%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%9B%9E%E5%BF%86%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <url>/2021/03/25/%E5%93%81%E8%B4%A8%E4%BC%98%E5%8C%96%E5%8D%8A%E5%B9%B4%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%9B%9E%E5%BF%86%E4%B8%8E%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>好久没有写博客了，上一个博客应该是去年12月底了，讲了我的2020都发生了些什么。这回说一说我最近半年的工作吧。每当我脑袋里总是充斥着关于同一件事的想法和回忆时，我就知道是时候把这些想法好好梳理一下，做一些总结了。</p><p>最近半年的工作确实值得好好说道，因为这是我工作以来（包括实习）最有意思的一段时间，但同时也是我最焦虑的一段时间。这半年我主要在做品质优化方向的工作。何为品质优化？在我的理解来看就是通过优化产品体验问题或性能问题来达到提升产品数据收益的工作。这句话有点绕口，我们拆开来说。这个工作的目标是改进产品体验，从而提升留存时长等数据，手段可以是修改产品结构、上线新的产品策略和进行性能优化等。</p><p>20年9月份的时候我换了一个方向，从业务侧到品质小组工作。刚开始，这是一个超出我预期的工作内容，因为我开始做性能优化工作了。我相信每一个工程师都明白，单纯的做业务迭代对于技术来说不会有很多的成长，可能一开始还不熟练，等到了熟练以后基本上就是体力活。在过去的很长一段时间里，我接的需求基本上扫一下文档就知道要怎么写了，我也觉得自身的技术达到了某种能感知到的瓶颈。不过我很幸运，在遇到瓶颈的时候有了参与性能优化工作的机会。</p><p>刚开始我做的是启动优化工作，这是一个我完全没接触过的领域，不知道各位有没有那种面对一个很着急的事情但你什么都不懂也无从下手的处境。为什么会有这种情况呢，在我看来是因为我离开了舒适区，这是件好事。虽然技术上我不是很懂，不过没关系我可以学。于是我花了大概一周多的时间来研究启动相关的知识并且产出了启动问题分析的文档。虽然这份文档要做的事情以及后来的实验都证明了没什么用处，不过我也算成功入门了。在整个9-10双月里我基本没有实质性的产出，不过我却在技术上有了超大的提升。如果说做性能优化工作前，我技术提升是对数函数的话，那现在的我技术提升大概是指数函数，就是这么夸张。不过在大公司做启动优化有很多困难，首先是接入业务方过多，问题推不动。有一次我想推动开屏广告SDK的同学帮我优化一个问题，他竟然跟我说3个月后才能解决，我的天，那我的OKR都凉透了。其次是AB实验，做启动优化理论上应该提升产品收益，所以启动优化至少不能让产品数据掉，像有些团队说的什么首页数据缓存这种方案根本不现实。最后，在我开始接这个工作前，同事已经优化了一波，干掉了很多大头问题，因此我只能做精细化的优化，对我来说可能10ms的优化都是很重要的事情。在我看来，启动优化这件事情就是理论简单、问题已知、目标明确，但就是很难优化。虽然有这些困扰，但是毕竟是在做工程实践。既然我推不动，那我就自己改，我要是改不了那我就hook。只能感叹这半年写的hook比前两年加起来都多。</p><p>后来我对启动优化这件事越来越得心应手，对于启动防劣化服务的报警，我基本上扫一眼trace就能知道哪有问题了。在这个方向上的产出也得到了同事的认可，并且分享了西瓜iOS的冷启动优化方案。想起mentor曾经跟我说过：“头条业务比我们西瓜重，我们至少启动不能比头条慢吧？”，现在确实比头条快了。前段时间也有同事跟我聊到：“你知道我跟你做启动优化的最大区别是什么吗？是激进，你做优化不会担心出什么问题，很激进”。确实，我确实很激进，我觉得这可能也是找我来做这个工作的理由之一？说起来我很喜欢字节的一点，在于它不会因为你是应届或者是实习生就不敢交予你大或者难的事情。但这可能也看不同的人是否能接受，像我就喜欢做有挑战的事情。</p><p>到11-12双月时，我开始接起整个西瓜iOS的流畅性优化工作。不得不说，这又是一个极速提升我技术水平的工作。我是真没想到，当初所谓面试造火箭的知识，现在被我用的一干二净。在这个双月里，我对我们的首页进行了流畅性优化，让有点卡的首页变成了不那么卡，没想到竟然取得了显著的产品收益，真是十分有成就感。在我最开始的时候其实是决定对首页进行重构来达到性能优化的效果，不过这个方案被否了，因为成本太高。没办法，面对那一坨屎一样的代码，我所做的工作也只能是在屎上添屎并努力让新的屎看起来好看一些，说起来我倒是挺擅长改造屎的呢。不过一坨屎再怎么改造都是有极限的，现在我差不多已经让这坨屎达到极限了，只有推翻重来才能再提升了。哎，滑动播放的性能问题简直是世界级难题。</p><p>现在，在不动列表架构的前提下，优化一个列表的性能问题对我来说非常简单。只要跑一遍instruments基本就能看出问题，然后针对性的优化一下差不多就ok了。流畅性优化对我来说基本上已经没有技术提升了，纯粹是体力活。回忆起19年频繁面试那会，那时无论是技术广度还是深度都会被现在的自己碾压吧，没想到也就一年多的时间我竟然成长的这么快。</p><p>不过到了1-2双月，感觉一切都变了。在我换方向4个月后，我发现我手里已经没有那种一眼就能看出有收益的事情。现在的情况正如头条之前所遇到的，叫做品质优化已经进入了深水区，没想到这个转变来的这么快。因此我开始做一些精细化的性能优化工作，比如说针对低端机做性能优化。不过很遗憾，我虽然按照了我的想法开发了许多优化上线，但根据AB实验的结论来看，那就是我在想当然，这真是令人沮丧。接着，我应该是陷入了某种奇怪的节奏中。那就是非常焦虑的想有产出，然后由于焦虑做了特别多的事情，但是做完特别多的事情并没有让我有成就感的产出，接着我就更焦虑。对我来说，仅仅是有性能收益已经满足不了我的胃口，我想要既有性能收益，又有产品收益，这真的很难很有挑战。</p><p>另外，在品质工作中的每一个需求都会有特别长的链路。举一个例子，当你决定做一个优化时得先分析为什么要做这个优化，接着开始开发和找QA测试或者自测，最后合码。OK，这对于一个研发同学来说还算好。不过接下来就得等漫长的各个灰度和最后上线，上线完还得开AB实验，实验一般得开1到2个完整周。所以整个流程基本上要有一个月的时间。这大概是什么意思呢？就是假设你需要通过一个优化的AB实验来指导你下一步该怎么做，那你得等接近一个月，真是好强的延迟满足感呢。以前作为业务研发同学，我只需要关注流水线上自己的那几个环节，但现在我作为一个优化项的owner，我必须关注所有环节，而且时间被拉的很长。这样一来就会引入一个问题，那就是做事的容错率很低。一旦我最开始确定有收益的事情在一个月后实际没有收益，那我这个双月定的OKR就没有完成的希望了。</p><p>所以在1-2双月里，我为了能够完成我的OKR，我做了非常多的事情试图取得收益。但这样让我精力分散，完全没有进行深度的思考和分析，最终的结果就是我完全没有取得产品上的收益。这两个月的经历让我开始佩服起产品同学，他们一直都是这样过来的吧，作为整个流程的owner，需要去跟各个职能的同学沟通并且推进项目的进展。最后在功能上线后还要等实验结论再继续执导他们的工作。突然能理解为什么他们总是走的比我们迟，我觉得我还有很多地方需要向产品同学们学习。</p><p>因为1-2双月的经历和感受，最近我一直在反思，为什么我会陷入这种焦虑的怪圈。我觉得我的第一个问题就是需求前期的分析不足，没有真正的找到问题的关键，并做出强而有力的事情，试图靠数量来弥补质量。我想了想，我觉得这大概就是假努力？做了很多事情来减缓自己的焦虑，实际上没有解决任何问题。举一个例子，我最近做了一个较小流量场景的性能优化，实验结果表明性能优化效果非常显著，但产品指标却有一点点负向。这是为什么呢？经过我对数据的仔细研究我发现用户进入这个页面后基本就不滑动，都不滑动那咋可能因为性能影响体验呢？在这个例子里我觉得我出现的最大错误就是我竟然没能前置的分析出这个情况，我只是因为看到性能数据很糟糕就下意识的认为优化性能问题就能取得产品收益。如果我在动手之前全方面的分析一下，我是不是就不用耽误这么多时间了呢？前段时间我听了头条那边一位同事的品质优化分享，我发现她的数据分析能力真是太强了，我完全被她的能力所折服。我感觉我在能力上跟她的差距，比我跟猪的差距还要大，这应该就是我想拥有的能力水平吧。</p><p>我的第二个问题就是推动力、规划能力不足，导致工作方案局限在我一个人能完成的范围内。随着品质工作时间的变长，我越来越发现职场中的软素质与硬素质（技术能力）一样重要。我认为作为一名软件工程师，技术只能决定我的下限，而软素质能决定我的上限。技术固然重要，但是在工作中并不能靠自己单打独斗完成所有事情。我很享受一个人能完成所有角色的事情，这样拥有极高的效率，因为都是脑内交流。如果一个需求需要多个人介入，那就需要花费很多时间在沟通上。而我现在往往是是一件事情的owner角色，为了达成目标，我还需要去推动其他同学跟我一起完成这个事情，对我这种嫌麻烦的人来说简直是让人糟心，从内心就有些抗拒，我觉得我需要克服这个毛病。克服了嫌麻烦的心态之后，我还得学会如何推动别人，因为合作总会遇到很多推不动的情况，或许是我没有让对方意识到做这件事的价值或许是我推动的方式不够合适，这也是我需要持续学习的地方。在规划能力上的不足，具体表现在我不知道如何在多人合作的场景下去拆解一个大事情，或者说知道要如何完成一件事，但我不知道要如何和别人一起合作完成。比如确定方向、分工和确定里程碑等内容，我完全不知道怎么开始怎么协调别的同学。仔细一想，可能是因为我工作经验还不够，我相信只要我确实的做过一次这样的事情我就能学会它。</p><p>总结一下，这半年工作让我意识到的事情。第一个是需要让自己的焦虑稍微平静一下，不要因为急于想要有产出而失去判断力。第二个是需求前后思考两个WHY，做需求之前需要进行充分的分析，为什么要做这件事，是因为什么样的数据或者理论支撑了做这件事的理由。在出来的实验结果也需要仔细研究为什么我的方案会得到这样的数据变化，要针对数据变化归纳出原因。第三个是丰富自己的方案思路，不要局限在只能自己一个人完成的领域内，要多与他人合作，从而能够锻炼到自己的软素质能力。最后，数据分析能力真的很重要，需要多锻炼，提升数据的敏感度，学会看数据，从数据中发现问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的2020</title>
    <link href="/2020/12/26/%E6%88%91%E7%9A%842020/"/>
    <url>/2020/12/26/%E6%88%91%E7%9A%842020/</url>
    
    <content type="html"><![CDATA[<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年比较特殊，除了年初去泰国的度假未受影响以外，其他的旅游安排都被迫取消了。原本计划毕业后自驾西北大环线，没想到竟然刚好遇到北京封城，真是太扫兴了。另外，经过一年短短续续的思考，我也基本上确定了毕业后的生活目标。以前一直在纠结是否要留在北京，现在已经确定了，我就是要留在北京生活。目前对于我来说面临的最麻烦的问题大概就是如何凑齐首付了吧。今年毕业前的时候从来没有考虑过这些未来生活上的事情，心情很放松，也很快乐。但是毕业后进入了全新生活的我，好像又给自己增压了？</p><p>说说射箭吧，去年年底我开始练习射箭，今年年初因为疫情原因没有接着练习。疫情缓解后我并没有放弃这个运动，并且买了一套装备。起初花了1.5w左右，后来断断续续又花了不少小钱。我自己买的这把弓感觉跟我并不是那么契合，刚用的前两个月，水平甚至不如用射箭馆里的弓。我跟它磨合了半年，也算是能够驾驭它了。</p><p>除了射箭之外，我今年也体验了许多新鲜的事情。比如说我大概花了1w5左右用于做美容。其实我原本以为这些东西是智商税，但实际上确实很有用，我现在的皮肤真是前所未有的光滑，痘印也基本淡化了。现在我能理解为什么很多明星即使年龄大了皮肤状态看起来还是那么好，这完全是可以用钱砸出来的呀！对了，我还养了一头猫，现在它就窝在我的脚上。养猫也是很培养耐心，我觉得要养孩子之前可能可以用养猫练习一下。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>今年的工作情况也是很神奇吧，这是我头一次目睹团队的极速扩张。年初的时候，一个会议室就可以坐下整个西瓜iOS的成员，到年底的时候人数已经翻番了，而且还有3个城市的办公室。很多西瓜主端业务都拆给了别的中台团队来维护，但很神奇的是C端竟然还是抱怨没有人力。我自己呢，也换了两次方向。第一次是换小方向，从消费业务去了互动业务，扛起了不少模块，承担了好久的死亡oncall。不得不说，oncall这玩意太消磨人的耐心了，即使我这么有耐心的人，每次被oncall了，那气血就增增的往头上冒，上去就是一阵battle。第二次换方向更夸张了，连组都换了，现在我在西瓜做基础技术。当然，第二次换方向还是考虑了我的个人意愿，我冥冥之中觉得去做技术方向对我有巨大的帮助，所以我就很高兴的去了。</p><p>去做基础技术以后发现果然没来错。想起以前总是吐槽面试造火箭，入职拧螺丝，现在我也终于有机会自己造火箭了。从9月份到现在，我在实际工作中遇到了诸多问题，也学会了非常多的技术，个人感觉能力上有了巨大的提升。另外，我终于没有业务压力了。以前是每天干到9点半还做不完，但是受不了了一定要下班。现在是每天8点前就能把工作做完，剩下时间用来学习和思考，看看有没有可以参考的。之所以差别这么大，主要在于做业务方向的同学需要开很多会，也会被很多人找，工作总是打断。但是做技术方向的同学就不一样，基本上没有会要开，而且整个开发流程都是自己充当所有的角色，所以能把工作完成的特别高效。当然，做技术方向也有指标上的压力。我9-10这个双月刚做技术需求的时候，那指标怎么也不达标，我就感觉压力老大了。</p><p>总的来看，在字节呆了一年多算是在工作上能够做到游刃有余了。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>今年除了工作和做毕设需要学习的技能之外，基本没学其他东西。工作上熟练掌握了启动优化、流畅性优化还有许多底层原理吧。各种源码理解的更深刻了，看的更通透了。在毕设上算是熟练掌握了AVFoundation的使用，其实感觉好像没什么卵用？</p><p>学习上学的少的主要原因还是在于我的物质条件丰富了，还没有完全玩够。而且平时工作已经很辛苦了，周末在花时间学习真的很难。不过最近我有了一些新玩具，我开始研究如何提高彩票的中奖概率。为了达到我的目标，我重新开始学习机器学习的原理，并且对彩票历史数据进行了许多分析。我相信明年我会产出一篇高质量的文章来指导人们如何购买彩票，并且给出具体的代码实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS实现高性能弹幕框架</title>
    <link href="/2020/10/06/iOS%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%BC%B9%E5%B9%95%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/10/06/iOS%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%BC%B9%E5%B9%95%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我之前维护过公司的弹幕库，但由于它的历史包袱过重，改造成本过高，一直没有将它改造成我心中理想状态的一个库。另外在周末，我也需要做一些事情来消磨时间，所以我写了一个比较符合我心中理想状态的弹幕库并将它开源：<a href="https://github.com/qyz777/DanmakuKit">https://github.com/qyz777/DanmakuKit</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/qyz777/DanmakuKit">DanmakuKit</a>是一个高性能弹幕框架，它提供了基础的弹幕功能，能够让你通过异步队列的方式渲染弹幕。它提供三种弹幕类别，分别是浮动、置顶和置底弹幕。目前它支持的功能如下：</p><ul><li>速度调节</li><li>轨道高度调节</li><li>显示区域调节</li><li>点击回调</li><li>暂停单个弹幕</li><li>重叠展示</li><li>禁用不同类型的弹幕</li><li>渲染不同进度的弹幕到屏幕上</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在说原理之前先把弹幕库的类图放上，DanmakuKit由DanmakuView作为承载弹幕的主体，其中包含不同的DanmakuTrack作为管理view中弹幕的对象。对于使用者而言，只需要给DanmakuView传入了实现DanmakuCellModel协议的对象，它就能根据协议自动创建或复用一个DanmakuCell来展示弹幕。</p><p><img src="https://cdn.qyizhong.cn/1240.png" alt="类图"></p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>在实际写代码之前就必须考虑到弹幕的性能问题，因为如果不考虑这个问题的话一旦弹幕量很大那就会极大的影响app使用体验。那么在iOS中，想要获得最佳的性能体验，我们可以很快的想到一个流程，那就是异步队列渲染出一张弹幕图片，把它放在layer.content中，再用Core Animation播放出来。另外，反复的创建和销毁管理弹幕的对象也有一些开销，我们要用合适的方法来管理这些对象。</p><p>因此我们总结一下，如果想要实现一个高性能的弹幕，那我们肯定会用到以下3点：</p><ul><li>复用</li><li>异步队列绘制</li><li>Core Animation</li></ul><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>复用是一个很容易想到的想法，在DanmakuKit中，弹幕的绘制是由DanmakuCell实现的，而它是一个view的子类，所以复用也是以view为维度的。复用view是为了减少反复addSubview以及removeFromSuperView的开销，当然，在实际测试来看这块性能开销并不会特别大。</p><h3 id="异步队列绘制"><a href="#异步队列绘制" class="headerlink" title="异步队列绘制"></a>异步队列绘制</h3><p>在DanmakuKit中，绘制使用的是<code>CGContext</code>，将内容绘制成一张图片放在layer.content中。如果这块的逻辑是在主线程同步的话那么必然会是个不小的开销，此时选择异步队列绘制就是一个很好的选择。当然，异步队列绘制也有它的劣势，那就是在写代码的过程中必须注意线程安全问题。</p><p>异步队列渲染的原理可以参考<a href="https://github.com/ibireme/YYAsyncLayer">https://github.com/ibireme/YYAsyncLayer</a> ，网上也有不少的播客解析过原理。</p><h3 id="使用Core-Animation"><a href="#使用Core-Animation" class="headerlink" title="使用Core Animation"></a>使用Core Animation</h3><p>如果动画使用Pop，那就不用操心手势响应事件了，但由于Pop是基于CADisplayLink实现的动画，它的执行是在主线程中，所以主线程一旦卡顿，那么动画也必然卡。而Core Animation的动画是由系统用一个专用的进程来进行渲染，使用它的好处不用多说了。</p><h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>由于DanmakuKit使用了Core Animation，因此弹幕在动画过程中的展示的其实是layer而不是view。layer是不支持手势响应的，因此点击事件必然也需要特别的实现一下。</p><p>实现弹幕在动画中的点击并不是一件很难的事情，我们可以充分利用手势响应链的知识来实现。众所周知，系统是先找到最上层最适合响应事件的view，再往下找能够响应的view，其中找view的方法就是hitTest。</p><p>在hitTest中，系统先会判断当前的point是否在view的范围内，如果在的话会从后往前遍历当前view的subViews数组，将传入的point转化为子view的point继续传入调用子view的hitTest方法，直到找到为止。那么我们只要将其中找子view的部分替换为找当前在播放动画的layer就好了，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hitTest</span><span class="hljs-params">(<span class="hljs-keyword">_</span> point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class="hljs-type">UIView</span>? &#123;<br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">self</span>.point(inside: point, with: event) <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>subviews.count).reversed() &#123;<br>        <span class="hljs-keyword">let</span> subView <span class="hljs-operator">=</span> subviews[i]<br>        <span class="hljs-comment">//如果当前的layer正在播放动画</span><br>        <span class="hljs-keyword">if</span> subView.layer.animationKeys() <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span>, <span class="hljs-keyword">let</span> presentationLayer <span class="hljs-operator">=</span> subView.layer.presentation() &#123;<br>        <span class="hljs-comment">//用动画的layer判断一下是否在点击范围内</span><br>            <span class="hljs-keyword">let</span> newPoint <span class="hljs-operator">=</span> layer.convert(point, to: presentationLayer)<br>            <span class="hljs-keyword">if</span> presentationLayer.contains(newPoint) &#123;<br>            <span class="hljs-comment">//是的话就找到这个view了</span><br>                <span class="hljs-keyword">return</span> subView<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> newPoint <span class="hljs-operator">=</span> convert(point, to: subView)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> findView <span class="hljs-operator">=</span> subView.hitTest(newPoint, with: event) &#123;<br>                <span class="hljs-keyword">return</span> findView<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，Core Animation动画中获取实时坐标的layer是layer.presentation()。另外，在开发过程中我发现presentationLayer的实际size与layer并不是完全相同的，因此在计算中最好只使用presentationLayer的坐标，否则总会出一些奇奇怪怪的问题。</p><h2 id="队列池"><a href="#队列池" class="headerlink" title="队列池"></a>队列池</h2><p>之前说到渲染弹幕要使用异步队列，那我们能不能直接使用GCD的并行队列呢？答案是不行的，因为随意使用GCD的并行队列很容易造成线程数量爆炸，引发内存问题或者使主线程卡死，大家可以用for循环遍历1000次来执行GCD的并行队列任务试试看。</p><p>为了解决这类的问题，我们必须实现一个队列池来解决在可控数量的队列内满足我们的并行需求。实现原理很简单，就是创建一定数量的串行队列存在数组中，每次获取队列时通过计数来获取到不同的队列，下方是一个简单的实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> Foundation<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DanmakuQueuePool</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> queues: [<span class="hljs-type">DispatchQueue</span>] <span class="hljs-operator">=</span> []<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> queueCount: <span class="hljs-type">Int</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> counter: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, queueCount: <span class="hljs-type">Int</span>, qos: <span class="hljs-type">DispatchQoS</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.queueCount <span class="hljs-operator">=</span> queueCount<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>queueCount &#123;<br>            <span class="hljs-keyword">let</span> queue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: name, qos: qos, attributes: [], autoreleaseFrequency: .inherit, target: <span class="hljs-literal">nil</span>)<br>            queues.append(queue)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> queue: <span class="hljs-type">DispatchQueue</span> &#123;<br>        <span class="hljs-keyword">return</span> getQueue()<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getQueue</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">DispatchQueue</span> &#123;<br>        <span class="hljs-keyword">if</span> counter <span class="hljs-operator">==</span> <span class="hljs-type">Int</span>.max &#123;<br>            counter <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        &#125;<br>        <span class="hljs-keyword">let</span> queue <span class="hljs-operator">=</span> queues[counter <span class="hljs-operator">%</span> queueCount]<br>        counter <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> queue<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>欢迎大家使用<a href="https://github.com/qyz777/DanmakuKit">DanmakuKit</a>，或为它提供建议。</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>帧率和丢帧</title>
    <link href="/2020/07/05/%E5%B8%A7%E7%8E%87%E5%92%8C%E4%B8%A2%E5%B8%A7/"/>
    <url>/2020/07/05/%E5%B8%A7%E7%8E%87%E5%92%8C%E4%B8%A2%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做一些性能优化的工作，在这个工作之前，除了fps以外其他的性能指标我并不了解，所以就有了这篇文章。</p><h1 id="帧率（FPS）"><a href="#帧率（FPS）" class="headerlink" title="帧率（FPS）"></a>帧率（FPS）</h1><p>在说fps之前，我们先要搞清楚一些概念。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>帧是什么？很简单，就是视频或者动画中一个画面，许多个帧组合起来就是视频或者动画。</p><h3 id="帧数"><a href="#帧数" class="headerlink" title="帧数"></a>帧数</h3><p>这个名词很直观，帧数就是生成帧的数量。如果一秒有60帧，那么2秒就是120帧。</p><h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><p>帧率是用于测量显示帧数的量度，也就是我们所说的fps，它的计算方式如下引用。</p><blockquote><p>帧率(Frame rate) = 帧数(Frames)/时间(Time)，单位为帧每秒(f/s, frames per second, fps)</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>fps也可以称为刷新率，它的值越高代表画面越连贯，当它太低时我们肉眼能感觉到不连贯。但是很多时候我们不仅在乎连贯性，也在乎流畅性。</p><p>引用<a href="https://zhuanlan.zhihu.com/p/48674410的例子如下，两者都是5">https://zhuanlan.zhihu.com/p/48674410的例子如下，两者都是5</a> fps，都是一秒5帧，但是由于前者的帧数不平滑，导致实际上流畅度也不如后者，就是因为帧生成时间不够平滑导致的。</p><blockquote><p>比如举个例子</p></blockquote><blockquote><p>第一组：第一帧与第二帧间隔了0.3秒，第二帧与第三针间隔了0.1秒，第三针与第四帧间隔了0.2秒，第四帧与第五帧间隔了0.4秒。</p></blockquote><blockquote><p>第二组：每一帧都间隔0.25秒</p></blockquote><p>只有两者都达到最好才能形成最好的视觉效果，但是fps这一指标无法衡量流畅性，因此我们需要引入丢帧。</p><h1 id="丢帧（Dropped-Frame）"><a href="#丢帧（Dropped-Frame）" class="headerlink" title="丢帧（Dropped Frame）"></a>丢帧（Dropped Frame）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>丢帧一般指由于硬件不足以负荷画面刷新的频率，从而导致帧率过低所造成的画面出现停滞现象。它也可以称为跳帧或者掉帧（Skipped Frames）。</p><p>在解释丢帧之前，先让我们来回顾一遍屏幕显示画面的原理。引用来自YY大佬的<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a>。简单来说就是准备一帧需要一行一行绘制，每换一行发一个叫HSync的信号，绘制完之后发一个YSync信号让CPU提交计算好的内容到GPU上进行显示。</p><blockquote><p><img src="https://cdn.qyizhong.cn/image.png" alt="img_0"></p></blockquote><blockquote></blockquote><blockquote><p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。</p></blockquote><blockquote><p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。</p></blockquote><p>所以为什么会丢帧呢？由于<a href="https://zhuanlan.zhihu.com/p/41848908">垂直同步</a>的机制（强制绘制刷新率与屏幕刷新率相符，锁定1秒60帧），如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变，这样就发生了丢帧。示意图如下，可以发现第二帧越到了第三帧的时间内，这样第三帧显示的还是第二帧的内容就丢了一帧。</p><p><img src="https://cdn.qyizhong.cn/image%20%281%29.png" alt="img_1"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>那说了这么多，丢帧要怎么计算呢？其实很简单，我们已知一帧的时间是1/60 s也就是16.67 ms，那么只要想办法获取到前一帧和后一帧的时间戳就可以计算出丢帧的帧数。这在iOS中是很容易做到的事情，我们只要使用CADisplayLink即可。</p><p>计算公式如下：</p><p>丢帧帧数 = (后一帧时间戳 - 前一帧时间戳) / 一帧的时间</p><h2 id="衡量丢帧"><a href="#衡量丢帧" class="headerlink" title="衡量丢帧"></a>衡量丢帧</h2><p>在衡量丢帧上，业界有许多方法，比如<a href="https://segmentfault.com/a/1190000005089412?from=from_parent_docs这篇文章中（虽然写的是Android，但也具备参考价值），Bugly就运用丢帧来计算多种指标。而我打算以时间为维度，多个（丢帧的次数之合">https://segmentfault.com/a/1190000005089412?from=from_parent_docs这篇文章中（虽然写的是Android，但也具备参考价值），Bugly就运用丢帧来计算多种指标。而我打算以时间为维度，多个（丢帧的次数之合</a> / 上报次数）为指标进行查看，可视化查询示意图如下。由于1～2帧的丢帧肉眼感受不明显，所以只统计了丢失3帧及以上的次数。</p><p><img src="https://cdn.qyizhong.cn/image%20%282%29.png" alt="img_2"></p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>使用CADisplayLink来计算丢帧并用字典存起来，key是丢帧的帧数，value是该丢帧帧数丢失的次数。具体代码如下，完整代码可查看XIGSmoothnessMonitor，它也包含fps的计算。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (void)start &#123;<br>    <span class="hljs-keyword">self</span>.lastDroppedTimestamp <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">self</span>.droppedFrameStatisticsInfo <span class="hljs-operator">=</span> [<span class="hljs-type">NSMutableDictionary</span> dictionary];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span><span class="hljs-keyword">self</span>.displayLink) &#123;<br>        <span class="hljs-keyword">self</span>.displayLink <span class="hljs-operator">=</span> [<span class="hljs-type">CADisplayLink</span> displayLinkWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-meta">@selector</span>(callback:)];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">@available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">10.0</span>, <span class="hljs-operator">*</span>)) &#123;<br>            <span class="hljs-keyword">self</span>.displayLink.preferredFramesPerSecond <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">self</span>.displayLink.frameInterval <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    [<span class="hljs-keyword">self</span>.displayLink addToRunLoop:[<span class="hljs-type">NSRunLoop</span> currentRunLoop] forMode:<span class="hljs-type">NSRunLoopCommonModes</span>];<br>&#125;<br><br><span class="hljs-operator">-</span> (void)callback:(<span class="hljs-type">CADisplayLink</span> <span class="hljs-operator">*</span>)displayLink &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.lastDroppedTimestamp <span class="hljs-operator">==</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">self</span>.lastDroppedTimestamp <span class="hljs-operator">=</span> displayLink.timestamp <span class="hljs-operator">*</span> <span class="hljs-number">1000</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//计算丢帧</span><br><br>    <span class="hljs-comment">//获取当前回调时间戳 单位是ms</span><br>    <span class="hljs-type">NSTimeInterval</span> droppedTimestamp <span class="hljs-operator">=</span> displayLink.timestamp <span class="hljs-operator">*</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">//获取当前一帧的时间 单位是ms</span><br>    <span class="hljs-type">NSTimeInterval</span> duration <span class="hljs-operator">=</span> displayLink.duration <span class="hljs-operator">*</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">//根据公示计算丢帧帧数</span><br>    <span class="hljs-type">NSInteger</span> droppedFrame <span class="hljs-operator">=</span> (droppedTimestamp <span class="hljs-operator">-</span> <span class="hljs-keyword">self</span>.lastDroppedTimestamp) <span class="hljs-operator">/</span> duration;<br>    <span class="hljs-keyword">self</span>.lastDroppedTimestamp <span class="hljs-operator">=</span> droppedTimestamp;<br>    <br>    <span class="hljs-comment">//丢帧大于等于3的才进行统计</span><br>    <span class="hljs-keyword">if</span> (droppedFrame <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-type">NSString</span> <span class="hljs-operator">*</span>droppedFrameKey <span class="hljs-operator">=</span> [<span class="hljs-type">NSString</span> stringWithFormat:@<span class="hljs-string">&quot;%zd&quot;</span>, droppedFrame];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.droppedFrameStatisticsInfo[droppedFrameKey]) &#123;<br>            <span class="hljs-type">NSInteger</span> count <span class="hljs-operator">=</span> [<span class="hljs-keyword">self</span>.droppedFrameStatisticsInfo[droppedFrameKey] integerValue];<br>            <span class="hljs-keyword">self</span>.droppedFrameStatisticsInfo[droppedFrameKey] <span class="hljs-operator">=</span> @(count <span class="hljs-operator">+</span> <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">self</span>.droppedFrameStatisticsInfo[droppedFrameKey] <span class="hljs-operator">=</span> @(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考文献</p><p><a href="https://www.leiue.com/2128">https://www.leiue.com/2128</a></p><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p><p><a href="https://zhuanlan.zhihu.com/p/48674410">https://zhuanlan.zhihu.com/p/48674410</a></p><p><a href="https://juejin.im/post/5ec35cc55188256d92438174">https://juejin.im/post/5ec35cc55188256d92438174</a></p><p><a href="https://segmentfault.com/a/1190000005089412">https://segmentfault.com/a/1190000005089412</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（8）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%888%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%888%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章对应<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html">官方教程第8章</a>。本章介绍如何将语言编译为目标文件。</p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>因为我们之前用了<code>JIT</code>，但是我们现在也要生成目标文件，两者只能选其一，所以我们现在把封装一下<code>JIT</code>以及main文件。</p><p>首先是封装<code>JIT</code>，我这里封装为类<code>CodeRunner</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeRunner</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> jit: <span class="hljs-type">JIT</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">typealias</span> fnPr <span class="hljs-operator">=</span> <span class="hljs-keyword">@convention(c)</span> () -&gt; <span class="hljs-type">Double</span><br>    <br>    <span class="hljs-keyword">init</span>(machine: <span class="hljs-type">TargetMachine</span>) &#123;<br>        jit <span class="hljs-operator">=</span> <span class="hljs-type">JIT</span>(machine: machine)<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(module: Module)</span></span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">let</span> handle <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> jit.addEagerlyCompiledIR(module, &#123; (<span class="hljs-keyword">_</span>) -&gt; <span class="hljs-type">JIT</span>.<span class="hljs-type">TargetAddress</span> <span class="hljs-keyword">in</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-type">JIT</span>.<span class="hljs-type">TargetAddress</span>()<br>            &#125;)<br>            <span class="hljs-keyword">let</span> addr <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> jit.address(of: <span class="hljs-string">&quot;__anon_expr&quot;</span>)<br>            <span class="hljs-keyword">let</span> fn <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(addr, to: fnPr.<span class="hljs-keyword">self</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(fn())</span>&quot;</span>)<br>            <span class="hljs-keyword">try</span> jit.removeModule(handle)<br>        &#125; <span class="hljs-keyword">catch</span> &#123;<br>            <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Adds the IR from a given module failure.&quot;</span>)<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>接着是main文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> isUseJIT <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-keyword">_</span> path: String)</span></span> -&gt; <span class="hljs-type">String</span>? &#123;<br>    <span class="hljs-keyword">var</span> path <span class="hljs-operator">=</span> path<br>    <span class="hljs-keyword">if</span> path.hasSuffix(<span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span>) &#123;<br>        path.removeLast()<br>    &#125;<br>    <span class="hljs-keyword">guard</span> path.split(separator: <span class="hljs-string">&quot;.&quot;</span>).last<span class="hljs-operator">!</span> <span class="hljs-operator">==</span> <span class="hljs-string">&quot;k&quot;</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Expected file is *.k.&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> <span class="hljs-type">String</span>(contentsOfFile: path, encoding: .utf8)<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Read file <span class="hljs-subst">\(path)</span> failure.&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//初始化Module和中间代码优化器</span><br>    initModule()<br>    <span class="hljs-comment">//解析器</span><br>    <span class="hljs-keyword">let</span> parser <span class="hljs-operator">=</span> <span class="hljs-type">Parser</span>()<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(data: <span class="hljs-type">FileHandle</span>.standardInput.availableData, encoding: .utf8) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> str <span class="hljs-operator">=</span> readFile(path) &#123;<br>            parser.parse(str)<br>          <span class="hljs-comment">//指定目标</span><br>            theModule.targetTriple <span class="hljs-operator">=</span> .default<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">//这个初始化方法里已经调用了initializeLLVM()</span><br>                <span class="hljs-keyword">let</span> targetMachine <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">TargetMachine</span>(triple: .default,<br>                                                      cpu: <span class="hljs-string">&quot;x86-64&quot;</span>,<br>                                                      features: <span class="hljs-string">&quot;&quot;</span>,<br>                                                      optLevel: .default,<br>                                                      relocations: .default,<br>                                                      codeModel: .default)<br>              <span class="hljs-comment">//指定数据布局</span><br>                theModule.dataLayout <span class="hljs-operator">=</span> targetMachine.dataLayout<br>              <span class="hljs-comment">//把代码优化放在这里</span><br>                <span class="hljs-keyword">let</span> pass <span class="hljs-operator">=</span> <span class="hljs-type">PassPipeliner</span>(module: theModule)<br>                pass.execute()<br>                <span class="hljs-keyword">if</span> isUseJIT &#123;<br>                    <span class="hljs-keyword">let</span> runner <span class="hljs-operator">=</span> <span class="hljs-type">CodeRunner</span>(machine: targetMachine)<br>                    runner.run(module: theModule)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//修改为自己的路径</span><br>                    <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;填你自己的路径&quot;</span><br>                  <span class="hljs-comment">//这里就是生成目标文件</span><br>                    <span class="hljs-keyword">try</span> targetMachine.emitToFile(module: theModule, type: .object, path: path)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Wrote <span class="hljs-subst">\(path)</span>&quot;</span>)<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> &#123;<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(error)</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>main()<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们新建.k文件<code>average.k</code>。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">def average(<span class="hljs-symbol">x</span> <span class="hljs-symbol">y</span>) (<span class="hljs-symbol">x</span> + <span class="hljs-symbol">y</span>) * <span class="hljs-number">0.5</span>;<br></code></pre></td></tr></table></figure><p>我们运行代码生成目标文件<code>output.o</code>，我们可以用下面命令看一下目标文件是否生成了符号表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -t output.o<br></code></pre></td></tr></table></figure><p>会输出类似的以下信息。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">output</span>.o:<span class="hljs-meta">file</span> <span class="hljs-meta">format</span> Mach-O 64-bit x86-64<br><br>SYMBOL <span class="hljs-meta">TABLE</span>:<br>0000000000000000 g     F __TEXT,__text_average<br></code></pre></td></tr></table></figure><p>生成完目标文件我们需要写一段C++代码进行调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">average</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;average of 3.0 and 4.0: &quot;</span> &lt;&lt; average(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将程序链接到output.o并查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang++ main.cpp output.o -o main<br>./main<br><br>//输出<br>average of 3.0 and 4.0: 3.5<br></code></pre></td></tr></table></figure><p>完整代码请参考<a href="https://github.com/qyz777/Kaleidoscope">仓库</a>。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>macOS下’wchar.h’ File Not Found</p><p>参考回答<a href="https://stackoverflow.com/questions/26185978/macos-wchar-h-file-not-found">macOS ‘wchar.h’ File Not Found</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg<br></code></pre></td></tr></table></figure><p>Mojava下安装头文件包即可。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（7）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%887%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%887%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章对应<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html">官方教程第7章</a>。本章的目的是支持变量<code>var</code>和`=运算符，我们需要在堆栈分配内存给变量，详细说明请查看官方教程第7章。</p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="调整现有变量"><a href="#调整现有变量" class="headerlink" title="调整现有变量"></a>调整现有变量</h3><p>首先我们需要改变<code>namedValues</code>的value类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> namedValues: [<span class="hljs-type">String</span>: <span class="hljs-type">IRInstruction</span>] <span class="hljs-operator">=</span> [:]<br></code></pre></td></tr></table></figure><p>此外，我们需要一个辅助函数来创建<code>Alloca</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createEntryBlockAlloca</span><span class="hljs-params">(function: Function, name: String)</span></span> -&gt; <span class="hljs-type">IRInstruction</span> &#123;<br>    <span class="hljs-keyword">let</span> instruction <span class="hljs-operator">=</span> builder.buildAlloca(type: <span class="hljs-type">FloatType</span>.double, count: <span class="hljs-number">0</span>, name: name)<br>    <span class="hljs-keyword">return</span> instruction<br>&#125;<br></code></pre></td></tr></table></figure><p>在本章中，变量改为了存于堆栈中，因此变量的代码生成也需要从堆栈中加载。我们修改<code>VariableExprAST</code>的<code>codeGen()</code>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> namedValues[name]<br>    <span class="hljs-keyword">guard</span> value <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;unknow variable name.&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> builder.buildLoad(value<span class="hljs-operator">!</span>, name: name)<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们需要更新定义变量的代码来设置<code>Alloca</code>。我们从<code>ForExprAST</code>的<code>codeGen()</code>方法开始。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">let</span> startVal <span class="hljs-operator">=</span> start.codeGen()<br>    <span class="hljs-keyword">guard</span> startVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//for循环，插在当前的block之后</span><br>    <span class="hljs-keyword">let</span> theFunction <span class="hljs-operator">=</span> builder.insertBlock<span class="hljs-operator">?</span>.parent<br>    <span class="hljs-keyword">guard</span> theFunction <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">//在entry block中为变量创建alloca</span><br>    <span class="hljs-keyword">let</span> alloca <span class="hljs-operator">=</span> createEntryBlockAlloca(function: theFunction<span class="hljs-operator">!</span>, name: name)<br>  把变量存储在alloca中<br>    builder.buildStore(startVal<span class="hljs-operator">!</span>, to: alloca)<br>    <br>    <span class="hljs-keyword">let</span> loopBB <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.appendBasicBlock(named: <span class="hljs-string">&quot;loop&quot;</span>)<br>    builder.buildBr(loopBB)<br>    builder.positionAtEnd(of: loopBB)<br>    <br>    <span class="hljs-keyword">let</span> oldVal <span class="hljs-operator">=</span> namedValues[name]<br>    namedValues[name] <span class="hljs-operator">=</span> alloca<br>    <br>    <span class="hljs-keyword">guard</span> body.codeGen() <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">let</span> stepVal: <span class="hljs-type">IRValue</span>?<br>    <span class="hljs-keyword">if</span> step <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>        stepVal <span class="hljs-operator">=</span> step<span class="hljs-operator">!</span>.codeGen()<br>        <span class="hljs-keyword">guard</span> stepVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        stepVal <span class="hljs-operator">=</span> <span class="hljs-type">FloatType</span>.double.constant(<span class="hljs-number">1</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">//循环终止条件</span><br>    <span class="hljs-keyword">var</span> endCond <span class="hljs-operator">=</span> end.codeGen()<br>    <span class="hljs-keyword">guard</span> endCond <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">//build条件时候要使用int类型</span><br>    endCond <span class="hljs-operator">=</span> builder.buildICmp(endCond<span class="hljs-operator">!</span>, <span class="hljs-type">IntType</span>.int1.zero(), .notEqual, name: <span class="hljs-string">&quot;loopCond&quot;</span>)<br>    <br>  <span class="hljs-comment">//加载当前变量</span><br>    <span class="hljs-keyword">let</span> curVal <span class="hljs-operator">=</span> builder.buildLoad(alloca)<br>  <span class="hljs-comment">//让下一个变量为当前变量+步长，即增长了</span><br>    <span class="hljs-keyword">let</span> nextVal <span class="hljs-operator">=</span> builder.buildAdd(curVal, stepVal<span class="hljs-operator">!</span>, name: <span class="hljs-string">&quot;nextVal&quot;</span>)<br>  <span class="hljs-comment">//再重新存储到alloca中</span><br>    builder.buildStore(nextVal, to: alloca)<br>    <br>    <span class="hljs-comment">//循环后的代码basic block</span><br>    <span class="hljs-keyword">let</span> afterBB <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">?</span>.appendBasicBlock(named: <span class="hljs-string">&quot;afterLoop&quot;</span>)<br>    builder.buildCondBr(condition: endCond<span class="hljs-operator">!</span>, then: loopBB, <span class="hljs-keyword">else</span>: afterBB<span class="hljs-operator">!</span>)<br>    builder.positionAtEnd(of: afterBB<span class="hljs-operator">!</span>)<br>    <br>    <span class="hljs-keyword">if</span> oldVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>        namedValues[name] <span class="hljs-operator">=</span> oldVal<span class="hljs-operator">!</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        namedValues[name] <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//for循环解析总是返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">FloatType</span>.double.constant(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这其中最大的变化就是我们不再使用<code>phi</code>操作而是使用<code>load/store</code>来根据需要访问变量。</p><p>我们在<code>FunctionAST</code>中也需要改变<code>codeGen()</code>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Function</span>? &#123;<br>    functionProtos[proto.name] <span class="hljs-operator">=</span> proto<br>    <span class="hljs-keyword">let</span> theFunction <span class="hljs-operator">=</span> getFunction(named: proto.name)<br>    <span class="hljs-keyword">guard</span> theFunction <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//如果是操作符，把他放在全局的操作符表中</span><br>    <span class="hljs-keyword">if</span> proto.isOperator &#123;<br>        <span class="hljs-type">BinOpPrecedence</span>[proto.operatorName<span class="hljs-operator">!</span>] <span class="hljs-operator">=</span> proto.precedence<br>    &#125;<br>    <br>    <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.appendBasicBlock(named: <span class="hljs-string">&quot;entry&quot;</span>)<br>    builder.positionAtEnd(of: entry)<br>    <br>    namedValues.removeAll()<br>    <span class="hljs-keyword">var</span> arg <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.firstParameter<br>    <span class="hljs-keyword">while</span> arg <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-comment">//为参数创建alloca</span><br>        <span class="hljs-keyword">let</span> alloca <span class="hljs-operator">=</span> createEntryBlockAlloca(function: theFunction<span class="hljs-operator">!</span>, name: arg<span class="hljs-operator">!</span>.name)<br>      <span class="hljs-comment">//把变量存到alloca中</span><br>        builder.buildStore(arg<span class="hljs-operator">!</span>, to: alloca)<br>      <span class="hljs-comment">//把变量放到符号表里</span><br>        namedValues[arg<span class="hljs-operator">!</span>.name] <span class="hljs-operator">=</span> alloca<br>        arg <span class="hljs-operator">=</span> arg<span class="hljs-operator">?</span>.next()<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> retValue <span class="hljs-operator">=</span> body.codeGen() &#123;<br>        builder.buildRet(retValue)<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">try</span> theModule.verify()<br>            <span class="hljs-keyword">return</span> theFunction<br>        &#125; <span class="hljs-keyword">catch</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(error)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//函数体出现问题，移除函数</span><br>    theFunction<span class="hljs-operator">!</span>.eraseFromParent()<br>    <span class="hljs-keyword">if</span> proto.isOperator &#123;<br>        <span class="hljs-type">BinOpPrecedence</span>[proto.operatorName<span class="hljs-operator">!</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加新的运算符"><a href="#添加新的运算符" class="headerlink" title="添加新的运算符"></a>添加新的运算符</h3><p>我们需要在全局操作符表中加入<code>=</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> <span class="hljs-type">BinOpPrecedence</span>: [<span class="hljs-type">String</span>: <span class="hljs-type">UInt</span>] <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;=&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;&lt;&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&quot;+&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&quot;-&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-number">40</span>]<br></code></pre></td></tr></table></figure><p>接下来我想大家都能想到，那就是去修改<code>BinaryExprAST</code>的<code>codeGen()</code>方法。</p><p>我们只需要在<code>codeGen()</code>方法最开始判断一下<code>=</code>即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">if</span> op <span class="hljs-operator">==</span> <span class="hljs-string">&quot;=&quot;</span> &#123;<br>    <span class="hljs-keyword">let</span> lhse <span class="hljs-operator">=</span> lhs <span class="hljs-keyword">as?</span> <span class="hljs-type">VariableExprAST</span><br>    <span class="hljs-keyword">guard</span> lhse <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Destination of &#x27;=&#x27; must be a variable.&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">let</span> val <span class="hljs-operator">=</span> lhse<span class="hljs-operator">?</span>.codeGen()<br>    <span class="hljs-keyword">guard</span> val <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>  <span class="hljs-comment">//获取符号表中的变量</span><br>    <span class="hljs-keyword">let</span> variable <span class="hljs-operator">=</span> namedValues[lhse<span class="hljs-operator">!</span>.name]<br>    <span class="hljs-keyword">guard</span> variable <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Unknow variable name.&quot;</span>)<br>    &#125;<br>  <span class="hljs-comment">//为变量赋值</span><br>    builder.buildStore(val<span class="hljs-operator">!</span>, to: variable<span class="hljs-operator">!</span>)<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户定义的局部变量"><a href="#用户定义的局部变量" class="headerlink" title="用户定义的局部变量"></a>用户定义的局部变量</h3><p>就像之前所做过的扩展一样，我们先要在<code>Token</code>、<code>Lexer</code>和<code>Parser</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Token</span> </span>&#123;<br><span class="hljs-operator">...</span><br>    <span class="hljs-keyword">case</span> `var`<br>    <span class="hljs-operator">...</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;var&quot;</span> &#123;<br>currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .var, val: <span class="hljs-string">&quot;var&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们构造<code>VarExprAST</code>AST Node。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarExprAST</span>: <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> varNames: [(<span class="hljs-type">String</span>, <span class="hljs-type">ExprAST</span>?)]<br>    <br>    <span class="hljs-keyword">let</span> body: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> varNames: [(<span class="hljs-type">String</span>, <span class="hljs-type">ExprAST</span>?)], <span class="hljs-keyword">_</span> body: <span class="hljs-type">ExprAST</span>) &#123;<br>        <span class="hljs-keyword">self</span>.varNames <span class="hljs-operator">=</span> varNames<br>        <span class="hljs-keyword">self</span>.body <span class="hljs-operator">=</span> body<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们允许通过<code>var/in</code>一次定义多个变量以及其初始化的值，并且我们允许在body中访问<code>var/in</code>定义的变量。</p><p>之后我们需要定义<code>Parser</code>的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析Var变量</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseVarExpr</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    lexer.nextToken()<br>    <span class="hljs-keyword">var</span> varNames: [(<span class="hljs-type">String</span>, <span class="hljs-type">ExprAST</span>?)] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">guard</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">==</span> .identifier <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected identifier after val.&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> &#123;<br>        <span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> lexer.currentToken<span class="hljs-operator">!</span>.val<br>        lexer.nextToken()<br>        <br>        <span class="hljs-keyword">let</span> expr: <span class="hljs-type">ExprAST</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;=&quot;</span> &#123;<br>            lexer.nextToken()<br>          <span class="hljs-comment">//解析&quot;=&quot;右边</span><br>            <span class="hljs-keyword">let</span> expr <span class="hljs-operator">=</span> parseExpression()<br>            <span class="hljs-keyword">guard</span> expr <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>            &#125;<br>        &#125;<br>        <br>        varNames.append((name, expr))<br>        <br>      <span class="hljs-comment">//看看还有没有下一个</span><br>        <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;,&quot;</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        lexer.nextToken()<br>        <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">!=</span> .identifier &#123;<br>            <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected identifier list after var.&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">!=</span> .in &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected &#x27;in&#x27; keyword after &#x27;var&#x27;.&quot;</span>)<br>    &#125;<br>    lexer.nextToken()<br>  <span class="hljs-comment">//解析body</span><br>    <span class="hljs-keyword">let</span> body <span class="hljs-operator">=</span> parseExpression()<br>    <span class="hljs-keyword">guard</span> body <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">VarExprAST</span>(varNames, body<span class="hljs-operator">!</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后需要添加的是我们<code>VarExprAST</code>中的<code>codeGen()</code>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">var</span> oldBindings: [<span class="hljs-type">IRInstruction</span>?] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">let</span> theFunction <span class="hljs-operator">=</span> builder.insertBlock<span class="hljs-operator">?</span>.parent<br>    <span class="hljs-keyword">guard</span> theFunction <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">//注册所有变量，并让他们初始化</span><br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> varNames &#123;<br>        <span class="hljs-keyword">let</span> initVal: <span class="hljs-type">IRValue</span>?<br>        <span class="hljs-keyword">if</span> v.<span class="hljs-number">1</span> <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>            initVal <span class="hljs-operator">=</span> v.<span class="hljs-number">1</span><span class="hljs-operator">?</span>.codeGen()<br>            <span class="hljs-keyword">guard</span> initVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//没有的话就默认0</span><br>            initVal <span class="hljs-operator">=</span> <span class="hljs-type">FloatType</span>.double.constant(<span class="hljs-number">0</span>)<br>        &#125;<br>        <br>        <span class="hljs-keyword">let</span> alloca <span class="hljs-operator">=</span> createEntryBlockAlloca(function: theFunction<span class="hljs-operator">!</span>, name: v.<span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//初始化变量，把initVal存到alloca中</span><br>        builder.buildStore(initVal<span class="hljs-operator">!</span>, to: alloca)<br>      <span class="hljs-comment">//记录的目的是防止丢失外部变量名相同的变量，比如说外部有变量a，body里也有变量a</span><br>        oldBindings.append(namedValues[v.<span class="hljs-number">0</span>])<br>        namedValues[v.<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> alloca<br>    &#125;<br>    <br>    <span class="hljs-keyword">let</span> bodyVal <span class="hljs-operator">=</span> body.codeGen()<br>    <span class="hljs-keyword">guard</span> bodyVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">//恢复之前的变量绑定</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>varNames.count &#123;<br>        namedValues[varNames[i].<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> oldBindings[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> bodyVal<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们输入</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs flix"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary</span> </span>: <span class="hljs-number">1</span> (x y) y;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibi</span></span>(x)<br>    var a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, c <span class="hljs-keyword">in</span><br>    (for i = <span class="hljs-number">3</span>, i &lt; x <span class="hljs-keyword">in</span><br>        c = a + b :<br>        a = b :<br>        b = c) :<br>    b;<br><br>fibi(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs llvm">Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-keyword">double</span> @<span class="hljs-string">&quot;binary:&quot;</span>(<span class="hljs-keyword">double</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%y</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%x1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%x1</span><br>  <span class="hljs-variable">%y2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%y</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%y2</span><br>  <span class="hljs-variable">%y3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%y2</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%y3</span><br>&#125;<br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-keyword">double</span> <span class="hljs-title">@fibi</span>(<span class="hljs-keyword">double</span> <span class="hljs-variable">%x</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%x1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%x1</span><br>  <span class="hljs-variable">%a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-number">0.000000e+00</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%a</span><br>  <span class="hljs-variable">%b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-number">0.000000e+00</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%b</span><br>  <span class="hljs-variable">%c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-number">0.000000e+00</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%c</span><br>  <span class="hljs-variable">%i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-number">3.000000e+00</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%i</span><br>  <span class="hljs-keyword">br</span> label <span class="hljs-variable">%loop</span><br><br><span class="hljs-symbol">loop:</span>                                             <span class="hljs-comment">; preds = %loop, %entry</span><br>  <span class="hljs-variable">%c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%c</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%c2</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%c</span><br>  <span class="hljs-variable">%a3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%a</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%a3</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%a</span><br>  <span class="hljs-variable">%binaryOp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">double</span> @<span class="hljs-string">&quot;binary:&quot;</span>(<span class="hljs-keyword">double</span> <span class="hljs-variable">%c2</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%a3</span>)<br>  <span class="hljs-variable">%b4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%b</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%b4</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%b</span><br>  <span class="hljs-variable">%binaryOp5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">double</span> @<span class="hljs-string">&quot;binary:&quot;</span>(<span class="hljs-keyword">double</span> <span class="hljs-variable">%binaryOp</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%b4</span>)<br>  <span class="hljs-variable">%i6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%i</span><br>  <span class="hljs-variable">%x7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%x1</span><br>  <span class="hljs-variable">%boolCmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">fcmp</span> <span class="hljs-keyword">olt</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%i6</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%x7</span><br>  <span class="hljs-variable">%loopCond</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">ne</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%boolCmp</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">false</span><br>  <span class="hljs-variable">%0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%i</span><br>  <span class="hljs-variable">%nextVal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">fadd</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1.000000e+00</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%nextVal</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%i</span><br>  <span class="hljs-keyword">br</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%loopCond</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%loop</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%afterLoop</span><br><br>afterLoop:                                        <span class="hljs-comment">; preds = %loop</span><br>  <span class="hljs-variable">%b8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-keyword">double</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span>* <span class="hljs-variable">%b</span><br>  <span class="hljs-variable">%binaryOp9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">double</span> @<span class="hljs-string">&quot;binary:&quot;</span>(<span class="hljs-keyword">double</span> <span class="hljs-number">0.000000e+00</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%b8</span>)<br>  <span class="hljs-keyword">ret</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%binaryOp9</span><br>&#125;<br>Read top-level expression:<br><br><span class="hljs-keyword">define</span> <span class="hljs-keyword">double</span> <span class="hljs-title">@__anon_expr</span>() &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">double</span> <span class="hljs-title">@fibi</span>(<span class="hljs-keyword">double</span> <span class="hljs-number">1.000000e+01</span>)<br>  <span class="hljs-keyword">ret</span> <span class="hljs-keyword">double</span> <span class="hljs-variable">%call</span><br>&#125;<br><span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（6）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%886%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%886%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章对应<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.html">官方教程第6章</a>。在之前的教程中我们为Kaleidoscope实现了一些基本的功能，但现在它有个大问题，那就是没有更多的操作符。所以本章内容展示了如何为让Kaleidoscope支持自定义操作符。</p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>既然我们要支持自定义运算符，那么肯定是需要在函数的处理上提供支持。因为我们需要支持一元运算符和二元运算符，所以需要定义两个<code>token</code>。他们分别是<code>unary</code>，用于扩展一元运算符。和<code>binary</code>，用于扩展二元运算符。</p><p>我们举两个例子说明用户自定义操作符的用法。</p><p>用于扩展一元运算符的函数写法，扩展了<code>&quot;非&quot;</code>操作符。</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs flix"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unary</span> <span class="hljs-title">!</span> </span>(v)<br>  <span class="hljs-keyword">if</span> v then<br>    <span class="hljs-number">0</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>用于扩展二元运算符的函数写法，扩展了<code>&quot;或&quot;</code>操作符。</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs flix"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary</span> <span class="hljs-title">|</span> 5 </span>(LHS RHS)<br>  <span class="hljs-keyword">if</span> LHS then<br>    <span class="hljs-number">1</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> RHS then<br>    <span class="hljs-number">1</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="Token解析"><a href="#Token解析" class="headerlink" title="Token解析"></a>Token解析</h3><p>需要做的第一件还是完善<code>token</code>的解析。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Token</span> </span>&#123;<br>  <span class="hljs-operator">...</span><br><span class="hljs-keyword">case</span> binary<br><span class="hljs-keyword">case</span> unary<br><span class="hljs-operator">...</span><br>&#125;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;binary&quot;</span> &#123;<br>currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .binary, val: <span class="hljs-string">&quot;binary&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;unary&quot;</span> &#123;<br>currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .unary, val: <span class="hljs-string">&quot;unary&quot;</span>)<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="扩展AST-Node"><a href="#扩展AST-Node" class="headerlink" title="扩展AST Node"></a>扩展AST Node</h3><p>既然我们是用<code>def</code>去自定义操作符，那么我们肯定需要改变之前的AST数据结构。</p><p>首先我们来看<code>PrototypeAST</code>的改变。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PrototypeKind</span>: <span class="hljs-title">Int</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> identifier<br>    <span class="hljs-keyword">case</span> unary<br>    <span class="hljs-keyword">case</span> binary<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">let</span> args: [<span class="hljs-type">String</span>]<br>    <br>    <span class="hljs-keyword">let</span> isOperator: <span class="hljs-type">Bool</span><span class="hljs-comment">//是否是运算符定义函数</span><br>    <br>    <span class="hljs-keyword">let</span> precedence: <span class="hljs-type">UInt</span><span class="hljs-comment">//运算符优先级</span><br>    <br>  <span class="hljs-comment">//是否是二元运算符定义函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isBinaryOp: <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">return</span> isOperator <span class="hljs-operator">&amp;&amp;</span> args.count <span class="hljs-operator">==</span> <span class="hljs-number">2</span><br>    &#125;<br>    <br>  <span class="hljs-comment">//是否是一元运算符定义函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isUnaryOp: <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">return</span> isOperator <span class="hljs-operator">&amp;&amp;</span> args.count <span class="hljs-operator">==</span> <span class="hljs-number">1</span><br>    &#125;<br>    <br>  <span class="hljs-comment">//运算符定义名字</span><br>    <span class="hljs-keyword">var</span> operatorName: <span class="hljs-type">String</span>? &#123;<br>        <span class="hljs-keyword">guard</span> isUnaryOp <span class="hljs-operator">||</span> isOperator <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">String</span>(<span class="hljs-type">Array</span>(name).last<span class="hljs-operator">!</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> name: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> args: [<span class="hljs-type">String</span>], <span class="hljs-keyword">_</span> isOperator: <span class="hljs-type">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, <span class="hljs-keyword">_</span> precedence: <span class="hljs-type">UInt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.args <span class="hljs-operator">=</span> args<br>        <span class="hljs-keyword">self</span>.isOperator <span class="hljs-operator">=</span> isOperator<br>        <span class="hljs-keyword">self</span>.precedence <span class="hljs-operator">=</span> precedence<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Function</span> &#123;<br>        <span class="hljs-keyword">let</span> doubles <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(repeating: <span class="hljs-type">FloatType</span>.double, count: args.count)<br>        <span class="hljs-keyword">let</span> ft <span class="hljs-operator">=</span> <span class="hljs-type">FunctionType</span>(doubles, <span class="hljs-type">FloatType</span>.double, variadic: <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">var</span> f: <span class="hljs-type">Function</span> <span class="hljs-operator">=</span> theModule.addFunction(name, type: ft)<br>        <span class="hljs-comment">//这其实是默认linkage，这里为了和官方教程保持一致，显示的写一下</span><br>        f.linkage <span class="hljs-operator">=</span> .external<br>        <span class="hljs-comment">//设置参数名</span><br>        <span class="hljs-keyword">var</span> p <span class="hljs-operator">=</span> f.firstParameter<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>args.count &#123;<br>            p<span class="hljs-operator">?</span>.name <span class="hljs-operator">=</span> args[i]<br>            p <span class="hljs-operator">=</span> p<span class="hljs-operator">?</span>.next()<br>        &#125;<br>        <span class="hljs-keyword">return</span> f<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>紧接着我们需要改变<code>parsePrototype()</code>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析函数原型</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: 函数原型AST</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePrototype</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">PrototypeAST</span> &#123;<br>    <span class="hljs-keyword">var</span> fnName: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> kind: <span class="hljs-type">PrototypeKind</span><br>    <span class="hljs-keyword">var</span> binaryPrecedence: <span class="hljs-type">UInt</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br>    <br>    <span class="hljs-keyword">switch</span> lexer.currentToken<span class="hljs-operator">!</span>.token &#123;<br>    <span class="hljs-keyword">case</span> .identifier:<br>        fnName <span class="hljs-operator">=</span> lexer.currentToken<span class="hljs-operator">!</span>.val<br>        kind <span class="hljs-operator">=</span> .identifier<br>        lexer.nextToken()<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> .binary:<br>        lexer.nextToken()<br>      <span class="hljs-comment">//不是ASCII字符不可以使用</span><br>        <span class="hljs-keyword">guard</span> <span class="hljs-type">Array</span>(lexer.currentToken<span class="hljs-operator">!</span>.val)[<span class="hljs-number">0</span>].isASCII <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected binary operator.&quot;</span>)<br>        &#125;<br>        fnName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;binary&quot;</span><br>        fnName <span class="hljs-operator">+=</span> lexer.currentToken<span class="hljs-operator">!</span>.val<br>        kind <span class="hljs-operator">=</span> .binary<br>        lexer.nextToken()<br>        <br>      <span class="hljs-comment">//解析二元表达式优先级</span><br>        <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">==</span> .number &#123;<br>            <span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> <span class="hljs-type">UInt</span>(lexer.currentToken<span class="hljs-operator">!</span>.val)<span class="hljs-operator">!</span><br>            <span class="hljs-keyword">if</span> num <span class="hljs-operator">&lt;</span> <span class="hljs-number">1</span> <span class="hljs-operator">||</span> num <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> &#123;<br>                <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Invalid precedence: must be 1...100.&quot;</span>)<br>            &#125;<br>            binaryPrecedence <span class="hljs-operator">=</span> num<br>            lexer.nextToken()<br>        &#125;<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected function name in prototype.&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;(&quot;</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected &#x27;(&#x27; in prototype&quot;</span>)<br>    &#125;<br>    <br>    lexer.nextToken()<br>    <span class="hljs-keyword">var</span> argNames: [<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">while</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">==</span> .identifier &#123;<br>        argNames.append(lexer.currentToken<span class="hljs-operator">!</span>.val)<br>        lexer.nextToken()<br>    &#125;<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;)&quot;</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected &#x27;)&#x27; in prototype&quot;</span>)<br>    &#125;<br>    lexer.nextToken()<br>    <br>    <span class="hljs-keyword">if</span> kind <span class="hljs-operator">!=</span> .identifier <span class="hljs-operator">&amp;&amp;</span> kind.rawValue <span class="hljs-operator">!=</span> argNames.count &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Invalid number of operands for operator.&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">PrototypeAST</span>(fnName, argNames, kind.rawValue <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>, binaryPrecedence)<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这里的变化无非就是需要多解析一元表达式和二元表达式这两种情况而已。</p><p>解析完AST之后我们还需要支持代码生成，所以我们在<code>BinaryExprAST</code>中的<code>codeGen()</code>方法里支持一下。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>  <span class="hljs-operator">...</span><br>    <span class="hljs-comment">//如果走到这里了，说明这个运算符是用户自己定义的</span><br>    <span class="hljs-keyword">let</span> fn <span class="hljs-operator">=</span> getFunction(named: <span class="hljs-string">&quot;binary&quot;</span> <span class="hljs-operator">+</span> op)<br>    <span class="hljs-keyword">guard</span> fn <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(String(describing: fn))</span> binary operator not found!&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">let</span> ops <span class="hljs-operator">=</span> [l<span class="hljs-operator">!</span>, r<span class="hljs-operator">!</span>]<br>    <span class="hljs-keyword">return</span> builder.buildCall(fn<span class="hljs-operator">!</span>, args: ops, name: <span class="hljs-string">&quot;binaryOp&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>FunctionAST</code>的<code>codeGen()</code>方法里把自定义操作符放在全局操作符表中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Function</span>? &#123;     <br>    <span class="hljs-operator">...</span><br><span class="hljs-comment">//如果是操作符，把他放在全局的操作符表中</span><br>      <span class="hljs-keyword">if</span> proto.isOperator &#123;<br>          <span class="hljs-type">BinOpPrecedence</span>[proto.operatorName<span class="hljs-operator">!</span>] <span class="hljs-operator">=</span> proto.precedence<br>      &#125;<br>    <span class="hljs-operator">...</span><br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="支持一元运算符"><a href="#支持一元运算符" class="headerlink" title="支持一元运算符"></a>支持一元运算符</h3><p>由于之前在Kaleidoscope中不支持一元运算符，所以我们需要新增一个AST Node <code>UnaryExprAST</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnaryExprAST</span>: <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> op: <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">let</span> operand: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> op: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> operand: <span class="hljs-type">ExprAST</span>) &#123;<br>        <span class="hljs-keyword">self</span>.op <span class="hljs-operator">=</span> op<br>        <span class="hljs-keyword">self</span>.operand <span class="hljs-operator">=</span> operand<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>接着按照惯例我们在<code>Parser</code>中添加解析逻辑。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析一元表达式</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseUnaryExpr</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    <span class="hljs-comment">//当前token不是操作符，那就是基本类型</span><br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-operator">||</span><br>        lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;,&quot;</span> <span class="hljs-operator">||</span><br>        <span class="hljs-type">Array</span>(lexer.currentToken<span class="hljs-operator">!</span>.val)[<span class="hljs-number">0</span>].isLetter <span class="hljs-operator">||</span><br>        <span class="hljs-type">Array</span>(lexer.currentToken<span class="hljs-operator">!</span>.val)[<span class="hljs-number">0</span>].isNumber &#123;<br>        <span class="hljs-keyword">return</span> parsePrimary()<br>    &#125;<br>    <br>    <span class="hljs-keyword">let</span> op <span class="hljs-operator">=</span> lexer.currentToken<span class="hljs-operator">!</span>.val<br>    lexer.nextToken()<br>    <span class="hljs-comment">//这里需要递归的处理一元运算符，比如说 !! x，这里有两个!!需要处理</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> operand <span class="hljs-operator">=</span> parseUnaryExpr() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">UnaryExprAST</span>(op, operand)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了调用这个方法，我们需要改变之前调用<code>parsePrimary()</code>方法的地方改为调用<code>parseUnaryExpr()</code>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseBinOpRHS</span><span class="hljs-params">(<span class="hljs-keyword">_</span> exprPrec: Int, <span class="hljs-keyword">_</span> lhs: <span class="hljs-keyword">inout</span> ExprAST)</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> &#123;<br><span class="hljs-operator">...</span><br>        <span class="hljs-comment">//解析二元运算符右边的表达式</span><br>        <span class="hljs-keyword">var</span> rhs <span class="hljs-operator">=</span> parseUnaryExpr()<br>        <span class="hljs-keyword">guard</span> rhs <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <span class="hljs-operator">...</span><br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseExpression</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    <span class="hljs-keyword">var</span> lhs <span class="hljs-operator">=</span> parseUnaryExpr()<br>    <span class="hljs-keyword">guard</span> lhs <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> parseBinOpRHS(<span class="hljs-number">0</span>, <span class="hljs-operator">&amp;</span>lhs<span class="hljs-operator">!</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们为<code>parsePrototype()</code>方法添加解析支持。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift">    <span class="hljs-operator">...</span><br><span class="hljs-keyword">case</span> .unary:<br>        lexer.nextToken()<br>        <span class="hljs-keyword">guard</span> <span class="hljs-type">Array</span>(lexer.currentToken<span class="hljs-operator">!</span>.val)[<span class="hljs-number">0</span>].isASCII <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected unary operator.&quot;</span>)<br>        &#125;<br>        fnName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;unary&quot;</span><br>        fnName <span class="hljs-operator">+=</span> lexer.currentToken<span class="hljs-operator">!</span>.val<br>        kind <span class="hljs-operator">=</span> .unary<br>        lexer.nextToken()<br>        <span class="hljs-keyword">break</span><br><span class="hljs-operator">...</span><br></code></pre></td></tr></table></figure><p>最后我们实现<code>UnaryExprAST</code>的<code>codeGen()</code>方法即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">let</span> operandVal <span class="hljs-operator">=</span> operand.codeGen()<br>    <span class="hljs-keyword">guard</span> operandVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> fn <span class="hljs-operator">=</span> getFunction(named: <span class="hljs-string">&quot;unary&quot;</span> <span class="hljs-operator">+</span> op)<br>    <span class="hljs-keyword">guard</span> fn <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Unknow unary operator.&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> builder.buildCall(fn<span class="hljs-operator">!</span>, args: [operandVal<span class="hljs-operator">!</span>], name: <span class="hljs-string">&quot;unaryOp&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>一元运算符</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs llvm">//输入<br>def unary ! (v) if v then <span class="hljs-number">0</span> else <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>def testfunc(<span class="hljs-keyword">x</span>) <span class="hljs-title">!x</span><span class="hljs-comment">;</span><br>testfunc(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br><br>//输出<br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> @<span class="hljs-string">&quot;unary!&quot;</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%v</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%ifCond</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">eq</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%v</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><br>  <span class="hljs-variable">%.</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">select</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%ifCond</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%.</span><br>&#125;<br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@testfunc</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%x</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%unaryOp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> @<span class="hljs-string">&quot;unary!&quot;</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%x</span>)<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%unaryOp</span><br>&#125;<br>Read top-level expression:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@__anon_expr</span>() &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> <span class="hljs-title">@testfunc</span>(<span class="hljs-type">i64</span> <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%call</span><br>&#125;<br>Evaluated <span class="hljs-keyword">to</span> <span class="hljs-number">0</span>.<br></code></pre></td></tr></table></figure><p>二元运算符</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs llvm">//输入<br>def binary &gt; <span class="hljs-number">10</span> (LHS RHS) RHS &lt; LHS<span class="hljs-comment">;</span><br>def testfunc(v) if v &gt; <span class="hljs-number">10</span> then <span class="hljs-number">1</span> else <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>testfunc(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br><br>//输出<br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> @<span class="hljs-string">&quot;binary&gt;&quot;</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%LHS</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%RHS</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%boolCmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">slt</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%RHS</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%LHS</span><br>  <span class="hljs-variable">%0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">sext</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%boolCmp</span> <span class="hljs-keyword">to</span> <span class="hljs-type">i64</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%0</span><br>&#125;<br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@testfunc</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%v</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%binaryOp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> @<span class="hljs-string">&quot;binary&gt;&quot;</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%v</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">10</span>)<br>  <span class="hljs-variable">%ifCond</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">eq</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%binaryOp</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><br>  <span class="hljs-variable">%.</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">select</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%ifCond</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%.</span><br>&#125;<br>Read top-level expression:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@__anon_expr</span>() &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> <span class="hljs-title">@testfunc</span>(<span class="hljs-type">i64</span> <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%call</span><br>&#125;<br>Evaluated <span class="hljs-keyword">to</span> <span class="hljs-number">0</span>.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（5）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%885%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%885%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章对应<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.html">官方教程第5章</a>，本章介绍如何扩展Kaleidoscope以使用<code>if / then / else</code>表达式和一个简单的<code>for</code>循环。</p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if / then / else"></a>if / then / else</h3><p><code>if / then / else</code>也是一种表达式，我们需要把它计算为int1类型，0是假，1是真。如果<code>if</code>表达式计算为真返回<code>then</code>表达式，否则返回<code>else</code>表达式。</p><p>首先我们需要做的第一件事情是扩展我们的Token枚举</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">...</span><br><span class="hljs-keyword">case</span> `if`<br><span class="hljs-keyword">case</span> then<br><span class="hljs-keyword">case</span> `else`<br><span class="hljs-operator">...</span><br></code></pre></td></tr></table></figure><p>接着我们在<code>Lexer</code>的<code>nextToken()</code>方法中补充token的解析</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;if&quot;</span> &#123;<br>currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .if, val: <span class="hljs-string">&quot;if&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;then&quot;</span> &#123;<br>currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .then, val: <span class="hljs-string">&quot;then&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;else&quot;</span> &#123;<br>currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .else, val: <span class="hljs-string">&quot;else&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-then-else的AST扩展"><a href="#if-then-else的AST扩展" class="headerlink" title="if / then / else的AST扩展"></a>if / then / else的AST扩展</h3><p>为了解析新的表达式我们需要添加新的AST Node。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IfExprAST</span>: <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> cond: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">let</span> then: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">let</span> `else`: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> cond: <span class="hljs-type">ExprAST</span>, <span class="hljs-keyword">_</span> then: <span class="hljs-type">ExprAST</span>, <span class="hljs-keyword">_</span> `else`: <span class="hljs-type">ExprAST</span>) &#123;<br>        <span class="hljs-keyword">self</span>.cond <span class="hljs-operator">=</span> cond<br>        <span class="hljs-keyword">self</span>.then <span class="hljs-operator">=</span> then<br>        <span class="hljs-keyword">self</span>.else <span class="hljs-operator">=</span> `else`<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-then-else的Parser扩展"><a href="#if-then-else的Parser扩展" class="headerlink" title="if / then / else的Parser扩展"></a>if / then / else的Parser扩展</h3><p>有了AST之后我们要做的事情那就是扩展<code>Parser</code>了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析条件语句</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseIfExpr</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    lexer.nextToken()<br>  <span class="hljs-comment">//解析if表达式</span><br>    <span class="hljs-keyword">let</span> cond <span class="hljs-operator">=</span> parseExpression()<br>    <span class="hljs-keyword">guard</span> cond <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>  <span class="hljs-comment">//if表达式后面不是then就报错</span><br>    <span class="hljs-keyword">guard</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">==</span> .then <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;expected then.&quot;</span>)<br>    &#125;<br>    lexer.nextToken()<br>  <span class="hljs-comment">//解析then表达式</span><br>    <span class="hljs-keyword">let</span> then <span class="hljs-operator">=</span> parseExpression()<br>    <span class="hljs-keyword">guard</span> then <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>  <span class="hljs-comment">//then表达式后面不是else表达式就报错</span><br>    <span class="hljs-keyword">guard</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">==</span> .else <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;expected else.&quot;</span>)<br>    &#125;<br>    lexer.nextToken()<br>    <span class="hljs-keyword">let</span> `else` <span class="hljs-operator">=</span> parseExpression()<br>    <span class="hljs-keyword">guard</span> `else` <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">IfExprAST</span>(cond<span class="hljs-operator">!</span>, then<span class="hljs-operator">!</span>, `else`<span class="hljs-operator">!</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们把它放在<code>parsePrimary</code>中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析基本表达式的入口</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePrimary</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    <span class="hljs-keyword">guard</span> lexer.currentToken <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;(&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> parseParenExpr()<br>    &#125;<br>    <span class="hljs-keyword">switch</span> lexer.currentToken<span class="hljs-operator">!</span>.token &#123;<br>    <span class="hljs-keyword">case</span> .identifier:<br>        <span class="hljs-keyword">return</span> parseIdentifierExpr()<br>    <span class="hljs-keyword">case</span> .number:<br>        <span class="hljs-keyword">return</span> parseNumberExpr()<br>    <span class="hljs-keyword">case</span> .if:<br>        <span class="hljs-keyword">return</span> parseIfExpr()<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;unknow token when expecting an expression&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-then-else的代码生成"><a href="#if-then-else的代码生成" class="headerlink" title="if / then / else的代码生成"></a>if / then / else的代码生成</h3><p>我们需要在<code>IfExprAST</code>中实现方法<code>codeGen()</code>。这里我们需要使用的是一个SSA操作:<a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Phi操作</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">var</span> condV <span class="hljs-operator">=</span> cond.codeGen()<br>    <span class="hljs-keyword">guard</span> condV <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>  <span class="hljs-comment">//这里有个神坑就是build条件时候要使用int1类型</span><br>    condV <span class="hljs-operator">=</span> builder.buildICmp(condV<span class="hljs-operator">!</span>, <span class="hljs-type">IntType</span>.int1.zero(), .equal, name: <span class="hljs-string">&quot;ifCond&quot;</span>)<br>    <br>    <span class="hljs-keyword">let</span> theFunction <span class="hljs-operator">=</span> builder.insertBlock<span class="hljs-operator">?</span>.parent<br>    <span class="hljs-keyword">guard</span> theFunction <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//为then else merge创建basic block并放在函数里</span><br>    <span class="hljs-keyword">let</span> thenBB <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.appendBasicBlock(named: <span class="hljs-string">&quot;then&quot;</span>)<br>    <span class="hljs-keyword">let</span> elseBB <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.appendBasicBlock(named: <span class="hljs-string">&quot;else&quot;</span>)<br>    <span class="hljs-keyword">let</span> mergeBB <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.appendBasicBlock(named: <span class="hljs-string">&quot;merge&quot;</span>)<br>    <br>  <span class="hljs-comment">//构建控制流表达式</span><br>    builder.buildCondBr(condition: condV<span class="hljs-operator">!</span>, then: thenBB, <span class="hljs-keyword">else</span>: elseBB)<br>    <br>  <span class="hljs-comment">//让builder移动到then的基本块里</span><br>    builder.positionAtEnd(of: thenBB)<br>  <span class="hljs-comment">//插入then</span><br>    <span class="hljs-keyword">let</span> thenVal <span class="hljs-operator">=</span> then.codeGen()<br>    <span class="hljs-keyword">guard</span> thenVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    builder.buildBr(mergeBB)<br>    <span class="hljs-comment">//让builer移动到else的基本块里</span><br>    builder.positionAtEnd(of: elseBB)<br>    <span class="hljs-keyword">let</span> elseVal <span class="hljs-operator">=</span> `else`.codeGen()<br>    <span class="hljs-keyword">guard</span> elseVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    builder.buildBr(mergeBB)<br>    <span class="hljs-comment">//让builder移动到merge的基本块里</span><br>    builder.positionAtEnd(of: mergeBB)<br>    <span class="hljs-keyword">let</span> phi <span class="hljs-operator">=</span> builder.buildPhi(<span class="hljs-type">FloatType</span>.double, name: <span class="hljs-string">&quot;phi&quot;</span>)<br>    phi.addIncoming([(thenVal<span class="hljs-operator">!</span>, thenBB), (elseVal<span class="hljs-operator">!</span>, elseBB)])<br>    <br>    <span class="hljs-keyword">return</span> phi<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for循环表达式"><a href="#for循环表达式" class="headerlink" title="for循环表达式"></a>for循环表达式</h3><p>Kaleidoscope的for循环长下面这样，1.0是可选的步长，默认即为1.0。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i = <span class="hljs-number">1</span>, i &lt; n, <span class="hljs-number">1</span>.<span class="hljs-number">0</span> in<br></code></pre></td></tr></table></figure><p>for循环表达式的处理会复杂一些，但还是同样运用了<code>Phi</code>操作来处理。</p><p>同控制流语句的扩展，我们还是先要扩展<code>Token</code>和<code>Lexer</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">case</span> `for`<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;for&quot;</span> &#123;<br>currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .for, val: <span class="hljs-string">&quot;for&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们扩展for循环的AST Node<code>ForExprAST</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForExprAST</span>: <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">let</span> start: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">let</span> end: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">let</span> step: <span class="hljs-type">ExprAST</span>?<br>    <br>    <span class="hljs-keyword">let</span> body: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> name: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> start: <span class="hljs-type">ExprAST</span>, <span class="hljs-keyword">_</span> end: <span class="hljs-type">ExprAST</span>, <span class="hljs-keyword">_</span> step: <span class="hljs-type">ExprAST</span>?, <span class="hljs-keyword">_</span> body: <span class="hljs-type">ExprAST</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.start <span class="hljs-operator">=</span> start<br>        <span class="hljs-keyword">self</span>.end <span class="hljs-operator">=</span> end<br>        <span class="hljs-keyword">self</span>.step <span class="hljs-operator">=</span> step<br>        <span class="hljs-keyword">self</span>.body <span class="hljs-operator">=</span> body<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>step</code>用来表示for循环的步长，即每次变量的增长值。编译器通过检查第二个逗号是否存在来判断，如果不存在我们把它设为<code>nil</code>。</p><h3 id="for循环的Parser扩展"><a href="#for循环的Parser扩展" class="headerlink" title="for循环的Parser扩展"></a>for循环的Parser扩展</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析For表达式</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseForExpr</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    lexer.nextToken()<br>  <span class="hljs-comment">//第一个得是变量，比如说`i`</span><br>    <span class="hljs-keyword">guard</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">==</span> .identifier <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;expected identifier after for.&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">let</span> idName <span class="hljs-operator">=</span> lexer.currentToken<span class="hljs-operator">!</span>.val<br>    lexer.nextToken()<br>    <span class="hljs-keyword">guard</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;=&quot;</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;expected &#x27;=&#x27; after for.&quot;</span>)<br>    &#125;<br>    <br>    lexer.nextToken()<br>  <span class="hljs-comment">//循环开始值</span><br>    <span class="hljs-keyword">let</span> start <span class="hljs-operator">=</span> parseExpression()<br>    <span class="hljs-keyword">guard</span> start <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">guard</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;,&quot;</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;expected &#x27;,&#x27; after start value.&quot;</span>)<br>    &#125;<br>    <br>    lexer.nextToken()<br>  <span class="hljs-comment">//循环结束值</span><br>    <span class="hljs-keyword">let</span> end <span class="hljs-operator">=</span> parseExpression()<br>    <span class="hljs-keyword">guard</span> end <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>  <span class="hljs-comment">//步长</span><br>    <span class="hljs-keyword">var</span> step: <span class="hljs-type">ExprAST</span>!<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;,&quot;</span> &#123;<br>        lexer.nextToken()<br>        step <span class="hljs-operator">=</span> parseExpression()<br>        <span class="hljs-keyword">guard</span> step <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//in作为for循环的关键字不可缺少</span><br>    <span class="hljs-keyword">guard</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">==</span> .in <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;expected &#x27;in&#x27; after for.&quot;</span>)<br>    &#125;<br>    lexer.nextToken()<br>    <span class="hljs-comment">//for循环的循环体解析</span><br>    <span class="hljs-keyword">let</span> body <span class="hljs-operator">=</span> parseExpression()<br>    <span class="hljs-keyword">guard</span> body <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">ForExprAST</span>(idName, start<span class="hljs-operator">!</span>, end<span class="hljs-operator">!</span>, step, body<span class="hljs-operator">!</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在<code>parsePrimary()</code>方法中补充调用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">case</span> .for:<br><span class="hljs-keyword">return</span> parseForExpr()<br></code></pre></td></tr></table></figure><h3 id="for循环的代码生成"><a href="#for循环的代码生成" class="headerlink" title="for循环的代码生成"></a>for循环的代码生成</h3><p>话不多说直接看代码，过程都会体现在注释中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">let</span> startVal <span class="hljs-operator">=</span> start.codeGen()<br>    <span class="hljs-keyword">guard</span> startVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//for循环，插在当前的block之后</span><br>    <span class="hljs-keyword">let</span> theFunction <span class="hljs-operator">=</span> builder.insertBlock<span class="hljs-operator">?</span>.parent<br>    <span class="hljs-keyword">guard</span> theFunction <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> preHeaderBB <span class="hljs-operator">=</span> builder.insertBlock<br>  <span class="hljs-comment">//循环体的基本块</span><br>    <span class="hljs-keyword">let</span> loopBB <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.appendBasicBlock(named: <span class="hljs-string">&quot;loop&quot;</span>)<br>    builder.buildBr(loopBB)<br>  <span class="hljs-comment">//让builder移动到</span><br>    builder.positionAtEnd(of: loopBB)<br>    <br>    <span class="hljs-comment">//这里控制循环或退出</span><br>    <span class="hljs-keyword">let</span> phi <span class="hljs-operator">=</span> builder.buildPhi(<span class="hljs-type">FloatType</span>.double, name: name)<br>    phi.addIncoming([(startVal<span class="hljs-operator">!</span>, preHeaderBB<span class="hljs-operator">!</span>)])<br>    <br>  <span class="hljs-comment">//防止for循环作用域与外部产生变量命名冲突，所以先记录一下，是nil也无所谓</span><br>    <span class="hljs-keyword">let</span> oldVal <span class="hljs-operator">=</span> namedValues[name]<br>    namedValues[name] <span class="hljs-operator">=</span> phi<br>    <br>    <span class="hljs-keyword">guard</span> body.codeGen() <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">let</span> stepVal: <span class="hljs-type">IRValue</span>?<br>    <span class="hljs-keyword">if</span> step <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-comment">//有步长就要解析</span><br>        stepVal <span class="hljs-operator">=</span> step<span class="hljs-operator">!</span>.codeGen()<br>        <span class="hljs-keyword">guard</span> stepVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//默认步长为1.0</span><br>        stepVal <span class="hljs-operator">=</span> <span class="hljs-type">FloatType</span>.double.constant(<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-comment">//步长的增长指令</span><br>    <span class="hljs-keyword">let</span> nextVar <span class="hljs-operator">=</span> builder.buildAdd(phi, stepVal<span class="hljs-operator">!</span>, name: <span class="hljs-string">&quot;nextVar&quot;</span>)<br>    <br>    <span class="hljs-comment">//循环终止条件</span><br>    <span class="hljs-keyword">var</span> endCond <span class="hljs-operator">=</span> end.codeGen()<br>    <span class="hljs-keyword">guard</span> endCond <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    endCond <span class="hljs-operator">=</span> builder.buildICmp(endCond<span class="hljs-operator">!</span>, <span class="hljs-type">IntType</span>.int1.zero(), .equal, name: <span class="hljs-string">&quot;loopCond&quot;</span>)<br>    <br>    <span class="hljs-comment">//循环后的代码basic block</span><br>    <span class="hljs-keyword">let</span> loopEndBB <span class="hljs-operator">=</span> builder.insertBlock<br>    <span class="hljs-keyword">let</span> afterBB <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">?</span>.appendBasicBlock(named: <span class="hljs-string">&quot;afterLoop&quot;</span>)<br>    builder.buildCondBr(condition: endCond<span class="hljs-operator">!</span>, then: loopBB, <span class="hljs-keyword">else</span>: afterBB<span class="hljs-operator">!</span>)<br>    builder.positionAtEnd(of: afterBB<span class="hljs-operator">!</span>)<br>    <br>    phi.addIncoming([(nextVar, loopEndBB<span class="hljs-operator">!</span>)])<br>    <br>    <span class="hljs-keyword">if</span> oldVal <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>        namedValues[name] <span class="hljs-operator">=</span> oldVal<span class="hljs-operator">!</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        namedValues[name] <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//for循环解析总是返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">FloatType</span>.double.constant(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>控制流语句</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs llvm">extern foo()<span class="hljs-comment">;</span><br>Read extern:<br><br><span class="hljs-keyword">declare</span> <span class="hljs-type">i64</span> <span class="hljs-title">@foo</span>()<br>extern bar()<span class="hljs-comment">;</span><br>Read extern:<br><br><span class="hljs-keyword">declare</span> <span class="hljs-type">i64</span> <span class="hljs-title">@bar</span>()<br>def baz(<span class="hljs-keyword">x</span>) if <span class="hljs-keyword">x</span> then foo() else bar()<span class="hljs-comment">;</span><br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@baz</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%x</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%ifCond</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">eq</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">br</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%ifCond</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%then</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%else</span><br><br><span class="hljs-symbol">then:</span>                                             <span class="hljs-comment">; preds = %entry</span><br>  <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> <span class="hljs-title">@foo</span>()<br>  <span class="hljs-keyword">br</span> label <span class="hljs-variable">%merge</span><br><br><span class="hljs-symbol">else:</span>                                             <span class="hljs-comment">; preds = %entry</span><br>  <span class="hljs-variable">%call1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> <span class="hljs-title">@bar</span>()<br>  <span class="hljs-keyword">br</span> label <span class="hljs-variable">%merge</span><br><br><span class="hljs-symbol">merge:</span>                                            <span class="hljs-comment">; preds = %else, %then</span><br>  <span class="hljs-variable">%phi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">phi</span> <span class="hljs-type">i64</span> [ <span class="hljs-variable">%call</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%then</span> ]<span class="hljs-punctuation">,</span> [ <span class="hljs-variable">%call1</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%else</span> ]<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%phi</span><br>&#125;<br></code></pre></td></tr></table></figure><p>for循环语句</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs llvm">extern putchard(char)<span class="hljs-comment">;</span><br>Read extern:<br><br><span class="hljs-keyword">declare</span> <span class="hljs-type">i64</span> <span class="hljs-title">@putchard</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%char</span>)<br>def printstar(n) for i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> i &lt; n<span class="hljs-punctuation">,</span> <span class="hljs-number">1</span> in putchard(<span class="hljs-number">42</span>)<span class="hljs-comment">;</span><br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@printstar</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%n</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-keyword">br</span> label <span class="hljs-variable">%loop</span><br><br><span class="hljs-symbol">loop:</span>                                             <span class="hljs-comment">; preds = %loop, %entry</span><br>  <span class="hljs-variable">%i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">phi</span> <span class="hljs-type">i64</span> [ <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%entry</span> ]<span class="hljs-punctuation">,</span> [ <span class="hljs-variable">%nextVar</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%loop</span> ]<br>  <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> <span class="hljs-title">@putchard</span>(<span class="hljs-type">i64</span> <span class="hljs-number">42</span>)<br>  <span class="hljs-variable">%nextVar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%i</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><br>  <span class="hljs-variable">%boolCmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">slt</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%i</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%n</span><br>  <span class="hljs-variable">%0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">sext</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%boolCmp</span> <span class="hljs-keyword">to</span> <span class="hljs-type">i64</span><br>  <span class="hljs-variable">%loopCond</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">eq</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">br</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%loopCond</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%loop</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%afterLoop</span><br><br>afterLoop:                                        <span class="hljs-comment">; preds = %loop</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（4）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%884%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%884%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章对应<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.html">官方教程第4章</a>，本章介绍如何为中间代码(LLVM IR)添加优化以及添加JIT编译器支持。</p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="中间代码优化"><a href="#中间代码优化" class="headerlink" title="中间代码优化"></a>中间代码优化</h3><p>我们都知道在编译的过程中有着中间代码优化这一步。我们想要中间代码能够去除无用以及重复计算的内容，所以这个时候我们需要使用中间代码优化器。</p><p>举一个例子，在没有优化之前，我们输入<code>def test(x) (1+2+x)*(x+(1+2));</code>获得的结果如下所示。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm">def test(<span class="hljs-keyword">x</span>) (<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-keyword">x</span>)*(<span class="hljs-keyword">x</span>+(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>))<span class="hljs-comment">;</span><br><br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@test</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%x</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-type">i64</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%x</span><br>  <span class="hljs-variable">%add1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><br>  <span class="hljs-variable">%mul</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%add</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%add1</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%mul</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出来其实<code>add</code>和<code>add1</code>是相同的值，完全没有必要算两次。所以经过优化之后长下面这样</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs llvm">def test(<span class="hljs-keyword">x</span>) (<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-keyword">x</span>)*(<span class="hljs-keyword">x</span>+(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>))<span class="hljs-comment">;</span><br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@test</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%x</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-type">i64</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%x</span><br>  <span class="hljs-variable">%mul</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%add</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%add</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%mul</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出出来之前的两个add被优化成了一个。</p><p>那么我们该如何添加优化呢？LLVM为我们提供了<code>PassManager</code>。但是有趣的是在<code>LLVMSwift</code>中，<code>PassManager</code>被<code>deprecated</code>了。所以我们只需要使用更简单的<code>PassPipeliner</code>即可。</p><p>有多简单呢？简单到只需要添加两行代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> passPipeliner <span class="hljs-operator">=</span> <span class="hljs-type">PassPipeliner</span>(module: theModule)<br><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lexerWithDefinition</span><span class="hljs-params">(<span class="hljs-keyword">_</span> lexer: Lexer)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> parseDefinition() &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> p.codeGen() &#123;<br>              <span class="hljs-comment">//在这里调用execute()方法</span><br>            passPipeliner.execute()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Read function definition:&quot;</span>)<br>                f.dump()<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            lexer.nextToken()<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="添加JIT支持"><a href="#添加JIT支持" class="headerlink" title="添加JIT支持"></a>添加JIT支持</h3><p>使用<code>LLVMSwift</code>中的JIT也十分简单。我们只需要在合适的地方调用即可。</p><p>首先我们定义全局变量JIT，并在main中初始化它。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> theJIT: <span class="hljs-type">JIT</span>!<br><span class="hljs-keyword">let</span> targetMachine <span class="hljs-operator">=</span> <span class="hljs-keyword">try!</span> <span class="hljs-type">TargetMachine</span>()<br>theJIT <span class="hljs-operator">=</span> <span class="hljs-type">JIT</span>(machine: targetMachine)<br></code></pre></td></tr></table></figure><p>接着我们在<code>lexerWithDefinition</code>中把<code>Module</code>中的IR添加到JIT中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift">      <span class="hljs-operator">...</span><br>f.dump()<br>      <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try!</span> theJIT.addLazilyCompiledIR(theModule) &#123; (<span class="hljs-keyword">_</span>) -&gt; <span class="hljs-type">JIT</span>.<span class="hljs-type">TargetAddress</span> <span class="hljs-keyword">in</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-type">JIT</span>.<span class="hljs-type">TargetAddress</span>()<br>      &#125;<br></code></pre></td></tr></table></figure><p>在<code>lexerWithTopLevelExpression</code>中把继续把<code>Module</code>中的IR添加到JIT中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift">        <span class="hljs-operator">...</span><br><span class="hljs-keyword">let</span> handle <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> theJIT.addEagerlyCompiledIR(theModule) &#123; (name) -&gt; <span class="hljs-type">JIT</span>.<span class="hljs-type">TargetAddress</span> <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-type">JIT</span>.<span class="hljs-type">TargetAddress</span>()<br>        &#125;<br>        <span class="hljs-keyword">let</span> addr <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> theJIT.address(of: <span class="hljs-string">&quot;__anon_expr&quot;</span>)<br>        <span class="hljs-keyword">typealias</span> <span class="hljs-type">FnPr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">@convention(c)</span> () -&gt; <span class="hljs-type">Int</span><br>        <span class="hljs-keyword">let</span> fn <span class="hljs-operator">=</span> <span class="hljs-built_in">unsafeBitCast</span>(addr, to: <span class="hljs-type">FnPr</span>.<span class="hljs-keyword">self</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Evaluated to <span class="hljs-subst">\(fn())</span>.&quot;</span>)<br>        <span class="hljs-keyword">try</span> theJIT.removeModule(handle)<br>initModule()<br></code></pre></td></tr></table></figure><p>还记得之前<code>parseTopLevelExpr</code>中添加的默认函数名<code>&quot;__anon_expr&quot;</code>吗？在<code>lexerWithTopLevelExpression</code>新增代码的意思就是把顶级表达式包在一个名为<code>&quot;__anon_expr&quot;</code>且返回值为空的函数中进行调用。</p><p>但是目前我们还只能调用一次函数，调用第二次函数时我们就找不到这个函数了。所以这个时候我们需要有一个全局的表用来记录。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> functionProtos: [<span class="hljs-type">String</span>: <span class="hljs-type">PrototypeAST</span>] <span class="hljs-operator">=</span> [:]<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFunction</span><span class="hljs-params">(named name: String)</span></span> -&gt; <span class="hljs-type">Function</span>? &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> theModule.function(named: name) &#123;<br>        <span class="hljs-keyword">return</span> f<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> fi <span class="hljs-operator">=</span> functionProtos[name]<br>        <span class="hljs-keyword">guard</span> fi <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> fi<span class="hljs-operator">?</span>.codeGen()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要为<code>CallExprAST</code>和<code>FunctionAST</code>替换获取函数名的方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//CallExprAST</span><br><span class="hljs-keyword">let</span> calleeF <span class="hljs-operator">=</span> getFunction(named: callee<span class="hljs-operator">!</span>)<br><span class="hljs-comment">//FunctionAST</span><br>functionProtos[proto<span class="hljs-operator">!</span>.name<span class="hljs-operator">!</span>] <span class="hljs-operator">=</span> proto<br><span class="hljs-keyword">let</span> theFunction <span class="hljs-operator">=</span> getFunction(named: proto<span class="hljs-operator">!</span>.name<span class="hljs-operator">!</span>)<br><span class="hljs-keyword">guard</span> theFunction <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们总是可以在当前<code>Module</code>中获得先前定义过的函数进行调用。</p><p>最后我们还需要更新一下<code>lexerWithDefinition</code>方法和<code>lexerWithExtern</code>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//lexerWithDefinition</span><br><span class="hljs-operator">...</span><br>f.dump()<br><span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try!</span> theJIT.addLazilyCompiledIR(theModule) &#123; (<span class="hljs-keyword">_</span>) -&gt; <span class="hljs-type">JIT</span>.<span class="hljs-type">TargetAddress</span> <span class="hljs-keyword">in</span><br><span class="hljs-keyword">return</span> <span class="hljs-type">JIT</span>.<span class="hljs-type">TargetAddress</span>()<br>&#125;<br>initModule()<br><br><span class="hljs-comment">//lexerWithExtern</span><br><span class="hljs-operator">...</span><br>f.dump()<br>functionProtos[p.name<span class="hljs-operator">!</span>] <span class="hljs-operator">=</span> p<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initModule</span><span class="hljs-params">()</span></span> &#123;<br>    theModule <span class="hljs-operator">=</span> <span class="hljs-type">Module</span>(name: <span class="hljs-string">&quot;main&quot;</span>)<br>    theModule.dataLayout <span class="hljs-operator">=</span> targetMachine.dataLayout<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>直接输入表达式。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">1</span>+<span class="hljs-number">20</span><span class="hljs-comment">;//输入</span><br>Read top-level expression:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@__anon_expr</span>() &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-number">21</span><br>&#125;<br>Evaluated <span class="hljs-keyword">to</span> <span class="hljs-number">21</span>.//输出<br></code></pre></td></tr></table></figure><p>函数调用。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs llvm">def testfunc(<span class="hljs-keyword">x</span> y) <span class="hljs-keyword">x</span> + y*<span class="hljs-number">2</span><span class="hljs-comment">;//输入</span><br>Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@testfunc</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%y</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%mul</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%y</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><br>  <span class="hljs-variable">%add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%mul</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%add</span><br>&#125;<br>testfunc(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span>)<span class="hljs-comment">;//输入</span><br>Read top-level expression:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@__anon_expr</span>() &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> <span class="hljs-title">@testfunc</span>(<span class="hljs-type">i64</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%call</span><br>&#125;<br>Evaluated <span class="hljs-keyword">to</span> <span class="hljs-number">5</span>.//输出<br>testfunc(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span>)<span class="hljs-comment">;//输入</span><br>Read top-level expression:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@__anon_expr</span>() &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i64</span> <span class="hljs-title">@testfunc</span>(<span class="hljs-type">i64</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">3</span>)<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%call</span><br>&#125;<br>Evaluated <span class="hljs-keyword">to</span> <span class="hljs-number">7</span>.//输出<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（3）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%883%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章对应<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.html">官方教程第3章</a>，本章介绍如何将抽象语法树(AST)转换为中间代码(LLVM IR)。</p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在生成IR开始之前我们需要为为<code>ExprAST</code>协议定一个<code>codeGen</code>方法，并返回LLVM的<code>IRValue</code>对象。这个方法表示该AST所表示的IR。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>?<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们创建Module对象<code>theModule</code>，它是一个包含函数和全局变量的LLVM数据结构，它拥有我们生成的所以IR的内存。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> theModule: <span class="hljs-type">Module</span>! <span class="hljs-operator">=</span> <span class="hljs-type">Module</span>(name: <span class="hljs-string">&quot;main&quot;</span>)<br></code></pre></td></tr></table></figure><p>接着我们创建IRBuilder对象<code>builder</code>，它可以用来生成LLVM指令。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> builder <span class="hljs-operator">=</span> <span class="hljs-type">IRBuilder</span>(module: theModule)<br></code></pre></td></tr></table></figure><p>定义代码符号表<code>namedValues</code>，表中的内容为当前范围内的值以及他们的IRValue。在Kaleidoscope中，它会在函数体生成的时候用到。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> namedValues: [<span class="hljs-type">String</span>: <span class="hljs-type">IRValue</span>] <span class="hljs-operator">=</span> [:]<br></code></pre></td></tr></table></figure><h3 id="表达式代码生成"><a href="#表达式代码生成" class="headerlink" title="表达式代码生成"></a>表达式代码生成</h3><p>首先我们先从最简单的写起，那就是<code>NumberExprAST</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">FloatType</span>.double.constant(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码把swift的Double表示转化为了LLVM IR的Double表示。</p><p>变量的<code>codeGen</code>也十分简单</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> namedValues[name]<br>    <span class="hljs-keyword">guard</span> value <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;unknow variable name.&quot;</span>)<br>    &#125;<br><span class="hljs-keyword">return</span> value<span class="hljs-operator">!</span>.asLLVM()<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上目前namedValues中的内容只唯一有函数参数的变量。所以在返回值之前先要检查一下是否以及是被解析为函数的参数了。</p><p>二元运算符的代码生成思路是递归的生成左侧的<code>IRValue</code>以及右侧的<code>IRValue</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">let</span> l <span class="hljs-operator">=</span> lhs<span class="hljs-operator">!</span>.codeGen()<br>    <span class="hljs-keyword">let</span> r <span class="hljs-operator">=</span> rhs<span class="hljs-operator">!</span>.codeGen()<br>    <span class="hljs-keyword">guard</span> l <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">&amp;&amp;</span> r <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">switch</span> op<span class="hljs-operator">!</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>        <span class="hljs-keyword">return</span> builder.buildAdd(l<span class="hljs-operator">!</span>, r<span class="hljs-operator">!</span>, name: <span class="hljs-string">&quot;add&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>        <span class="hljs-keyword">return</span> builder.buildSub(l<span class="hljs-operator">!</span>, r<span class="hljs-operator">!</span>, name: <span class="hljs-string">&quot;sub&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>        <span class="hljs-keyword">return</span> builder.buildMul(l<span class="hljs-operator">!</span>, r<span class="hljs-operator">!</span>, name: <span class="hljs-string">&quot;mul&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&lt;&quot;</span>:<br>        <span class="hljs-keyword">return</span> builder.buildFCmp(l<span class="hljs-operator">!</span>, r<span class="hljs-operator">!</span>, .unorderedLessThan, name: <span class="hljs-string">&quot;boolCmp&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Invalid binary operator.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>builder</code>是知道在哪里插入指令，所以我们需要做的仅仅只是指定使用哪个指令而已。比如说<code>buildAdd</code>或者<code>buildFCmp</code>。</p><p>LLVM指令有很严格的约束，比如说<code>buildAdd</code>指令的的左右两侧都必须是同一类型，但是在Kaleidoscope中我们只支持了Double类型，所以不是很需要操心。</p><p>另外，符号”&lt;”对应的指令<code>buildFCmp</code>始终返回i1类型，在这里我们与官方教程不一样的一点就是我们并不需要操心这个类型不是Double类型，我们只需要返回出去即可。</p><p>接着我们来实现函数调用的<code>codeGen</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IRValue</span>? &#123;<br>    <span class="hljs-keyword">let</span> calleeF <span class="hljs-operator">=</span> theModule.function(named: callee<span class="hljs-operator">!</span>)<br>    <span class="hljs-keyword">guard</span> calleeF <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> calleeF<span class="hljs-operator">!</span>.parameterCount <span class="hljs-operator">!=</span> args<span class="hljs-operator">!</span>.count &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Incorrect arguments passed.&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> argsV: [<span class="hljs-type">IRValue</span>] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args<span class="hljs-operator">!</span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> gen <span class="hljs-operator">=</span> arg.codeGen() &#123;<br>            argsV.append(gen)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> builder.buildCall(calleeF<span class="hljs-operator">!</span>, args: argsV, name: <span class="hljs-string">&quot;call&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要在LLVM <code>Module</code>中查找函数名并设置参数即可生成函数调用的<code>IRValue</code>。</p><h3 id="功能代码生成"><a href="#功能代码生成" class="headerlink" title="功能代码生成"></a>功能代码生成</h3><p>原型和函数的<code>codeGen</code>比较复杂一些。值得注意的是原型和函数的<code>codeGen</code>方法的返回类型并不是<code>IRValue</code>类型而是<code>Function</code>类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Function</span> &#123;<br>    <span class="hljs-keyword">let</span> doubles <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(repeating: <span class="hljs-type">FloatType</span>.double, count: args.count)<br>    <span class="hljs-keyword">let</span> ft <span class="hljs-operator">=</span> <span class="hljs-type">FunctionType</span>(doubles, <span class="hljs-type">FloatType</span>.double, variadic: <span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">var</span> f: <span class="hljs-type">Function</span> <span class="hljs-operator">=</span> theModule.addFunction(name, type: ft)<br>    <span class="hljs-comment">//这其实是默认linkage，这里为了和官方教程保持一致，显示的写一下</span><br>    f.linkage <span class="hljs-operator">=</span> .external<br>    <span class="hljs-comment">//设置参数名</span><br>    <span class="hljs-keyword">var</span> p <span class="hljs-operator">=</span> f.firstParameter<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>args.count &#123;<br>        p<span class="hljs-operator">?</span>.name <span class="hljs-operator">=</span> args[i]<br>        p <span class="hljs-operator">=</span> p<span class="hljs-operator">?</span>.next()<br>    &#125;<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FunctionType</code>第一个参数为一个类型的数组代表这个函数每个参数的类型，第二个参数为函数返回值的类型，第三个参数的含义为是否为可变变量，这里设置为false。</p><p>接着我们要在<code>FunctionAST</code>的<code>codeGen</code>中定义函数体。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">codeGen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Function</span>? &#123;<br>    functionProtos[proto<span class="hljs-operator">!</span>.name<span class="hljs-operator">!</span>] <span class="hljs-operator">=</span> proto<br>    <span class="hljs-keyword">let</span> theFunction <span class="hljs-operator">=</span> getFunction(named: proto<span class="hljs-operator">!</span>.name<span class="hljs-operator">!</span>)<br>    <span class="hljs-keyword">guard</span> theFunction <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>  <span class="hljs-comment">//创建一个基本块(BasicBlock)</span><br>    <span class="hljs-keyword">let</span> entry <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.appendBasicBlock(named: <span class="hljs-string">&quot;entry&quot;</span>)<br>  <span class="hljs-comment">//这行代码告诉bulder应该把新的指令插在基本块的末尾，你可以理解为插在名为entry的这个基本块里</span><br>    builder.positionAtEnd(of: entry)<br>    <br>  <span class="hljs-comment">//我们把函数参数添加到namedValues中以便VariableExprAST可以访问到</span><br>    namedValues.removeAll()<br>    <span class="hljs-keyword">var</span> p <span class="hljs-operator">=</span> theFunction<span class="hljs-operator">!</span>.firstParameter<br>    <span class="hljs-keyword">while</span> p <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>        namedValues[p<span class="hljs-operator">!</span>.name] <span class="hljs-operator">=</span> p<span class="hljs-operator">!</span><br>        p <span class="hljs-operator">=</span> p<span class="hljs-operator">?</span>.next()<br>    &#125;<br>    <br>  <span class="hljs-comment">//解析函数体对应的IRValue</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> retValue <span class="hljs-operator">=</span> body<span class="hljs-operator">!</span>.codeGen() &#123;<br>        builder.buildRet(retValue)<br>        <span class="hljs-keyword">do</span> &#123;<br>          <span class="hljs-comment">//验证函数，这个方法可以检查出函数生成IR是否出现问题。</span><br>            <span class="hljs-keyword">try</span> theModule.verify()<br>            <span class="hljs-keyword">return</span> theFunction<br>        &#125; <span class="hljs-keyword">catch</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;verify failure: <span class="hljs-subst">\(error)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//函数体出现问题，移除函数</span><br>    theFunction<span class="hljs-operator">!</span>.eraseFromParent()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>函数体解析过程中的要点都在注释中体现了，下面我们可以使用<code>Function</code>对象的<code>dump()</code>方法打印出函数的IR。</p><p>我们在Parser中实现Lexer的代理<code>LexerDelegate</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Parser</span>: <span class="hljs-title">LexerDelegate</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lexerWithDefinition</span><span class="hljs-params">(<span class="hljs-keyword">_</span> lexer: Lexer)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> parseDefinition() &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> p.codeGen() &#123;<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Read function definition:&quot;</span>)<br>                f.dump()<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            lexer.nextToken()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lexerWithExtern</span><span class="hljs-params">(<span class="hljs-keyword">_</span> lexer: Lexer)</span></span> &#123;<br>        <span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> parseExtern()<br>        <span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> p.codeGen()<br>        f.dump()<br>        functionProtos[p.name] <span class="hljs-operator">=</span> p<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lexerWithTopLevelExpression</span><span class="hljs-params">(<span class="hljs-keyword">_</span> lexer: Lexer)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> parseTopLevelExpr() &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> p.codeGen() &#123;<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Read top-level expression:&quot;</span>)<br>                f.dump()<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            lexer.nextToken()<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>现在就可以打印出IR了。</p><p>我们将在下一章实现IR的优化以及对JIT的支持。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们编写一个扩展类型为.k的文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def foo(a b) a<span class="hljs-number">*a</span> + 2<span class="hljs-number">*a</span><span class="hljs-number">*b</span> + b<span class="hljs-number">*b</span>;<br></code></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs llvm">Read function definition:<br><br><span class="hljs-keyword">define</span> <span class="hljs-type">i64</span> <span class="hljs-title">@foo</span>(<span class="hljs-type">i64</span> <span class="hljs-variable">%a</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%b</span>) &#123;<br><span class="hljs-symbol">entry:</span><br>  <span class="hljs-variable">%mul</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%a</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%a</span><br>  <span class="hljs-variable">%mul1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-type">i64</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%a</span><br>  <span class="hljs-variable">%mul2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%mul1</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%b</span><br>  <span class="hljs-variable">%add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%mul</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%mul2</span><br>  <span class="hljs-variable">%mul3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%b</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%b</span><br>  <span class="hljs-variable">%add4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%add</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%mul3</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i64</span> <span class="hljs-variable">%add4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>请忽略我生成的IR中值的type是i64。因为我在最开始实现时并没有按照教程说的使用Double类型。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（2）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%882%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章对应<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.html">官方教程第2章</a>，介绍实现解析器(Parser)和抽象语法树(AST)。</p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>AST用来解释代码的行为，我们希望语言中的每个构造都有一个AST，所以我们首先需要一个AST的基类，在swift中我们可以使用<code>protocol</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ExprAST</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>注意，在Kaleidoscope中我们只支持Double类型，所以首先我们需要有一个保存数值的AST。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberExprAST</span>: <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> value: <span class="hljs-type">Double</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> value: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>用于保存变量名的AST，比如说保存”abc”。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VariableExprAST</span>: <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> name: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>用于保存二元运算符的AST，比如”+”。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryExprAST</span>: <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> op: <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">let</span> lhs: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">let</span> rhs: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> op: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> lhs: <span class="hljs-type">ExprAST</span>, <span class="hljs-keyword">_</span> rhs: <span class="hljs-type">ExprAST</span>) &#123;<br>        <span class="hljs-keyword">self</span>.op <span class="hljs-operator">=</span> op<br>        <span class="hljs-keyword">self</span>.lhs <span class="hljs-operator">=</span> lhs<br>        <span class="hljs-keyword">self</span>.rhs <span class="hljs-operator">=</span> rhs<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>因为这个类适用于二元运算符，所以AST需要记录操作符左边的AST(lhs)以及右边的AST(rhs)以及操作符的名字。</p><p>函数的AST包括原型AST(<code>PrototypeAST</code>)、函数定义AST(<code>FunctionAST</code>)和函数调用AST(<code>CallExprAST</code>)。原型AST即函数的声明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">let</span> args: [<span class="hljs-type">String</span>]<br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> name: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> args: [<span class="hljs-type">String</span>]) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.args <span class="hljs-operator">=</span> args<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>PrototypeAST需要保存函数名以及参数名。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">let</span> proto: <span class="hljs-type">PrototypeAST</span><br>    <br>    <span class="hljs-keyword">let</span> body: <span class="hljs-type">ExprAST</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> proto: <span class="hljs-type">PrototypeAST</span>, <span class="hljs-keyword">_</span> body: <span class="hljs-type">ExprAST</span>) &#123;<br>        <span class="hljs-keyword">self</span>.proto <span class="hljs-operator">=</span> proto<br>        <span class="hljs-keyword">self</span>.body <span class="hljs-operator">=</span> body<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>FunctionAST保存函数声明的AST proto和函数定义的AST body。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallExprAST</span>: <span class="hljs-title">ExprAST</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">var</span> callee: <span class="hljs-type">String</span>?<br>    <br>    <span class="hljs-keyword">var</span> args: [<span class="hljs-type">ExprAST</span>]<span class="hljs-operator">?</span><br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> callee: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> args: [<span class="hljs-type">ExprAST</span>]) &#123;<br>        <span class="hljs-keyword">self</span>.callee <span class="hljs-operator">=</span> callee<br>        <span class="hljs-keyword">self</span>.args <span class="hljs-operator">=</span> args<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>CallExprAST用来解析函数的调用。</p><h3 id="开始解析"><a href="#开始解析" class="headerlink" title="开始解析"></a>开始解析</h3><p>在上一章中，我们已经实现了一个可以解析出token的lexer。下面我们需要完善Lexer并且实现Parser，它用来解析出AST。</p><p>我们为Lexer添加输入方法以及代理方法提供给Parser。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析代码</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Parameter sourceInput: 代码数据源</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">_</span> sourceInput: String)</span></span> &#123;<br>    <span class="hljs-keyword">let</span> blockArray <span class="hljs-operator">=</span> sourceInput.split(separator: <span class="hljs-string">&quot;;&quot;</span>)<br>    <span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> blockArray &#123;<br>        source <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(block <span class="hljs-operator">+</span> <span class="hljs-string">&quot;;&quot;</span>)<br>        index <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        lastChar <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span><br>        nextToken()<br>        <span class="hljs-keyword">switch</span> currentToken<span class="hljs-operator">!</span>.token &#123;<br>        <span class="hljs-keyword">case</span> .def:<br>            delegate<span class="hljs-operator">?</span>.lexerWithDefinition(<span class="hljs-keyword">self</span>)<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">case</span> .extern:<br>            delegate<span class="hljs-operator">?</span>.lexerWithExtern(<span class="hljs-keyword">self</span>)<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">case</span> .number, .identifier:<br>            delegate<span class="hljs-operator">?</span>.lexerWithTopLevelExpression(<span class="hljs-keyword">self</span>)<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Kaleidoscope用”;”分割代码块，为了方便处理我们就可以直接根据”;”进行分块解析即可。</p><p>接下来我们定义Parser。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parser</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> lexer <span class="hljs-operator">=</span> <span class="hljs-type">Lexer</span>()<br>    <br>    <span class="hljs-keyword">init</span>() &#123;<br>        lexer.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Parser</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/// 解析代码</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// - Parameter sourceInput: 代码数据源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-keyword">_</span> sourceInput: String)</span></span> &#123;<br>        lexer.start(sourceInput)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析基本表达式"><a href="#解析基本表达式" class="headerlink" title="解析基本表达式"></a>解析基本表达式</h4><p>我们从解析数字开始。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析数值常量</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseNumberExpr</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span> &#123;<br>    <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-type">NumberExprAST</span>(<span class="hljs-type">Double</span>(lexer.currentToken<span class="hljs-operator">!</span>.val)<span class="hljs-operator">!</span>)<br>    lexer.nextToken()<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>这个其实看代码毫无疑问，生成NumberAST完获取下一个token即可。</p><p>解析<code>&quot;&#39;(&#39; expression &#39;)&#39;&quot;</code>形式的表达式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析&#x27;(&#x27;开头的表达式</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseParenExpr</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    lexer.nextToken()<span class="hljs-comment">//跳过&#x27;(&#x27;</span><br>    <span class="hljs-keyword">let</span> v <span class="hljs-operator">=</span> parseExpression()<br>    <span class="hljs-keyword">guard</span> v <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;)&quot;</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected &#x27;<span class="hljs-subst">\(lexer.currentToken<span class="hljs-operator">!</span>.val)</span>&#x27;&quot;</span>)<br>    &#125;<br>    lexer.nextToken()<span class="hljs-comment">//跳过&#x27;)&#x27;</span><br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><p>parseExpression()方法将会在下面介绍到。</p><p>解析变量或者函数调用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析变量引用和函数调用</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseIdentifierExpr</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    <span class="hljs-keyword">let</span> idName <span class="hljs-operator">=</span> lexer.currentToken<span class="hljs-operator">!</span>.val<br>    lexer.nextToken()<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;(&quot;</span> &#123;<br>      <span class="hljs-comment">//说明只是普通的变量</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">VariableExprAST</span>(idName)<br>    &#125;<br>  <span class="hljs-comment">//走到这说明是函数调用</span><br>    lexer.nextToken()<br>    <span class="hljs-keyword">var</span> args: [<span class="hljs-type">ExprAST</span>] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;)&quot;</span> &#123;<br>      <span class="hljs-comment">//这个循环用来解析传入参数</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> &#123;<br>            <span class="hljs-keyword">let</span> arg <span class="hljs-operator">=</span> parseExpression()<br>            <span class="hljs-keyword">guard</span> arg <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>            &#125;<br>            args.append(arg<span class="hljs-operator">!</span>)<br>          <span class="hljs-comment">//匹配到&quot;)&quot;说明解析该结束了</span><br>            <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;)&quot;</span> &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>          <span class="hljs-comment">//不同参数之间用&quot;,&quot;分割</span><br>            <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;,&quot;</span> &#123;<br>                <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected &#x27;)&#x27; or &#x27;,&#x27; in argument list&quot;</span>)<br>            &#125;<br>            lexer.nextToken()<br>        &#125;<br>    &#125;<br>    <br>    lexer.nextToken()<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">CallExprAST</span>(idName, args)<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们已经有了所有简单表达式解析的逻辑了，我们把它们的调用写一个统一的入口。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析基本表达式的入口</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePrimary</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    <span class="hljs-keyword">guard</span> lexer.currentToken <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">==</span> <span class="hljs-string">&quot;(&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> parseParenExpr()<br>    &#125;<br>    <span class="hljs-keyword">switch</span> lexer.currentToken<span class="hljs-operator">!</span>.token &#123;<br>    <span class="hljs-keyword">case</span> .identifier:<br>        <span class="hljs-keyword">return</span> parseIdentifierExpr()<br>    <span class="hljs-keyword">case</span> .number:<br>        <span class="hljs-keyword">return</span> parseNumberExpr()<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;unknow token when expecting an expression&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析二元表达式"><a href="#解析二元表达式" class="headerlink" title="解析二元表达式"></a>解析二元表达式</h4><p>首先我们需要定义一个全局的操作符优先级表</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> <span class="hljs-type">BinOpPrecedence</span>: [<span class="hljs-type">String</span>: <span class="hljs-type">UInt</span>] <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;&lt;&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&quot;+&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&quot;-&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-number">40</span>]<br></code></pre></td></tr></table></figure><p>value越大代表优先级越大，很明显”*”是大于”+”的，目前我们只支持4个运算符，当然你自己可以支持更多的运算符。</p><p>接着在Parser中定义获得操作符优先级的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 获取currentToken对应的运算符优先级</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: 优先级</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTokenPrecedence</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-type">BinOpPrecedence</span>[lexer.currentToken<span class="hljs-operator">!</span>.val] <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-operator">-</span><span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Int</span>(<span class="hljs-type">BinOpPrecedence</span>[lexer.currentToken<span class="hljs-operator">!</span>.val]<span class="hljs-operator">!</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要实现parseExpression()方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析表达式</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseExpression</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    <span class="hljs-keyword">var</span> lhs <span class="hljs-operator">=</span> parsePrimary()<br>    <span class="hljs-keyword">guard</span> lhs <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> parseBinOpRHS(<span class="hljs-number">0</span>, <span class="hljs-operator">&amp;</span>lhs<span class="hljs-operator">!</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运算优先级的解析思想是将二元运算符的表达式分为多个部分。运算符优先级解析的基本思想就是通过拆解含有二元运算符的表达式来解决可能的二义性问题。以表达式<code>a+b+(c+d)*e*f+g</code>为例，在进行运算符优先级解析时，它将被视作一串按二元运算符分隔的主表达式。按照这个思路，解析出来的第一个主表达式应该是<code>a</code>，紧跟着是若干个有序对，即：<code>[+, b]</code>、<code>[+, (c+d)]</code>、<code>[*, e]</code>、<code>[*, f]</code>和<code>[+, g]</code>。注意，括号表达式也是主表达式，所以在解析二元表达式时无须特殊照顾<code>(c+d)</code>这样的嵌套表达式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析二元运算符</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Parameters:</span><br><span class="hljs-comment">///   - exprPrec: 二元运算符优先级</span><br><span class="hljs-comment">///   - lhs: 左表达式</span><br><span class="hljs-comment">/// - Returns: AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseBinOpRHS</span><span class="hljs-params">(<span class="hljs-keyword">_</span> exprPrec: Int, <span class="hljs-keyword">_</span> lhs: <span class="hljs-keyword">inout</span> ExprAST)</span></span> -&gt; <span class="hljs-type">ExprAST</span>? &#123;<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> &#123;<br>        <span class="hljs-keyword">let</span> tokPrec <span class="hljs-operator">=</span> getTokenPrecedence()<br>        <span class="hljs-keyword">if</span> tokPrec <span class="hljs-operator">&lt;</span> exprPrec &#123;<br>            <span class="hljs-keyword">return</span> lhs<br>        &#125;<br>        <br>        <span class="hljs-comment">//获取二元运算符</span><br>        <span class="hljs-keyword">let</span> binOp <span class="hljs-operator">=</span> lexer.currentToken<br>        lexer.nextToken()<br>        <br>        <span class="hljs-comment">//解析二元运算符右边的表达式</span><br>        <span class="hljs-keyword">var</span> rhs <span class="hljs-operator">=</span> parsePrimary()<br>        <span class="hljs-keyword">guard</span> rhs <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">let</span> nextPrec <span class="hljs-operator">=</span> getTokenPrecedence()<br>        <span class="hljs-keyword">if</span> tokPrec <span class="hljs-operator">&lt;</span> nextPrec &#123;<br>            <span class="hljs-comment">//如果下一个符号优先级更高，则递归调用自己把它们拼成一个rhs返回</span><br>            rhs <span class="hljs-operator">=</span> parseBinOpRHS(tokPrec <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, <span class="hljs-operator">&amp;</span>rhs<span class="hljs-operator">!</span>)<br>            <span class="hljs-keyword">guard</span> rhs <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//合并lhr和rhs</span><br>        lhs <span class="hljs-operator">=</span> <span class="hljs-type">BinaryExprAST</span>(binOp<span class="hljs-operator">!</span>.val, lhs, rhs<span class="hljs-operator">!</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析其余结构"><a href="#解析其余结构" class="headerlink" title="解析其余结构"></a>解析其余结构</h4><p>下面来解析函数原型。在Kaleidoscope中，有两处会用到函数原型：一是<code>extern</code>函数声明，二是函数定义。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析函数原型</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: 函数原型AST</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePrototype</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">PrototypeAST</span> &#123;<br>    <span class="hljs-keyword">var</span> fnName: <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">switch</span> lexer.currentToken<span class="hljs-operator">!</span>.token &#123;<br>    <span class="hljs-keyword">case</span> .identifier:<br>        fnName <span class="hljs-operator">=</span> lexer.currentToken<span class="hljs-operator">!</span>.val<br>        lexer.nextToken()<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected function name in prototype.&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;(&quot;</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected &#x27;(&#x27; in prototype&quot;</span>)<br>    &#125;<br>    <br>    lexer.nextToken()<br>    <span class="hljs-keyword">var</span> argNames: [<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">while</span> lexer.currentToken<span class="hljs-operator">!</span>.token <span class="hljs-operator">==</span> .identifier &#123;<br>        argNames.append(lexer.currentToken<span class="hljs-operator">!</span>.val)<br>        lexer.nextToken()<br>    &#125;<br>    <span class="hljs-keyword">if</span> lexer.currentToken<span class="hljs-operator">!</span>.val <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;)&quot;</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Expected &#x27;)&#x27; in prototype&quot;</span>)<br>    &#125;<br>    lexer.nextToken()<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">PrototypeAST</span>(fnName, argNames)<br>&#125;<br></code></pre></td></tr></table></figure><p>解析函数定义就更简单了，只需要先解析函数原型再解析表达式即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析函数定义</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: 函数定义AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseDefinition</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">FunctionAST</span>? &#123;<br>    lexer.nextToken()<br>    <span class="hljs-keyword">let</span> proto <span class="hljs-operator">=</span> parsePrototype()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> e <span class="hljs-operator">=</span> parseExpression() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">FunctionAST</span>(proto, e)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解析<code>extern</code>也很简单，因为也是解析函数原型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析extern导出定义</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: 原型AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseExtern</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">PrototypeAST</span> &#123;<br>    lexer.nextToken()<br>    <span class="hljs-keyword">return</span> parsePrototype()<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们还要允许用户能够输入任意表达式并求值，这个方式可以通过添加一个特殊的匿名函数实现，这个函数不需要任何参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 解析顶级表达式</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Returns: 函数AST</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseTopLevelExpr</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">FunctionAST</span>? &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> e <span class="hljs-operator">=</span> parseExpression() &#123;<br>        <span class="hljs-comment">//__anon_expr为默认占位函数名</span><br>        <span class="hljs-keyword">let</span> proto <span class="hljs-operator">=</span> <span class="hljs-type">PrototypeAST</span>(<span class="hljs-string">&quot;__anon_expr&quot;</span>, [])<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">FunctionAST</span>(proto, e)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入口代码"><a href="#入口代码" class="headerlink" title="入口代码"></a>入口代码</h4><p>我们还需要编写一段输入代码能够让我们愉快的解析代码。</p><p>首先我们定义一种存放Kaleidoscope语言的文件，这里就让扩展名为.k好了。这样的话我们需要先写一个读取文本内容的函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-keyword">_</span> path: String)</span></span> -&gt; <span class="hljs-type">String</span>? &#123;<br>    <span class="hljs-keyword">var</span> path <span class="hljs-operator">=</span> path<br>    <span class="hljs-keyword">if</span> path.hasSuffix(<span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span>) &#123;<br>        path.removeLast()<br>    &#125;<br>    <span class="hljs-keyword">guard</span> path.split(separator: <span class="hljs-string">&quot;.&quot;</span>).last<span class="hljs-operator">!</span> <span class="hljs-operator">==</span> <span class="hljs-string">&quot;k&quot;</span> <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Expected file is *.k.&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> <span class="hljs-type">String</span>(contentsOfFile: path, encoding: .utf8)<br>    &#125; <span class="hljs-keyword">catch</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Read file <span class="hljs-subst">\(path)</span> failure.&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们通过输入的文件路径读这个文件的内容进行解析即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//解析器</span><br>    <span class="hljs-keyword">let</span> parser <span class="hljs-operator">=</span> <span class="hljs-type">Parser</span>()<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(data: <span class="hljs-type">FileHandle</span>.standardInput.availableData, encoding: .utf8) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> str <span class="hljs-operator">=</span> readFile(path) &#123;<br>            parser.parse(str)<br>        &#125;<br>    &#125;<br>&#125;<br><br>main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（1）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%881%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章对应<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.html">官方教程第1章</a>，介绍了Kaleidoscope以及实现词法分析器(Lexer)。</p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><p>Kaleidoscope大概长这样</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">fib</span>(<span class="hljs-variable">x</span>)</span><br>  <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">x</span> &lt; <span class="hljs-number">3</span> <span class="hljs-variable">then</span><br>    <span class="hljs-number">1</span><br>  <span class="hljs-variable"><span class="hljs-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-title">fib</span>(<span class="hljs-variable">x</span>-<span class="hljs-number">1</span>)+<span class="hljs-title">fib</span>(<span class="hljs-variable">x</span>-<span class="hljs-number">2</span>);</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-title">fib</span>(<span class="hljs-number">40</span>);</span><br></code></pre></td></tr></table></figure><p>本项目参考官方文档编写，为了图方便与官方文档一样写了不少全局变量，这在实际工程中不是一个好的处理方式。</p><p><strong>注意</strong>：教程中使用extern调用标准库本文并未实现，仅实现了extern的解析。由于本工程一开始把全部变量解析为int64类型而不是Double类型，所以后续章节可能会出现与官方教程生成的中间代码IR不相同的情况，还请各位具体问题具体分析。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们在实现语言时，首先需要能识别代码内容。通常情况下我们使用词法分析器(Lexer)，将输入分解为Token。首先我们需要定义Token以及CurrentToken结构体。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Token</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> def<br>    <span class="hljs-keyword">case</span> extern<br>    <span class="hljs-keyword">case</span> identifier<br>    <span class="hljs-keyword">case</span> number<br>    <span class="hljs-keyword">case</span> other<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CurrentToken</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> token: <span class="hljs-type">Token</span><br>    <span class="hljs-keyword">var</span> val: <span class="hljs-type">String</span><br>&#125;<br></code></pre></td></tr></table></figure><p>identifier是用来记录变量，而其他的几个Token的枚举一目了然。CurrentToken用来表示当前正在解析的内容。</p><h3 id="定义Lexer"><a href="#定义Lexer" class="headerlink" title="定义Lexer"></a>定义Lexer</h3><p>在编写详细的token处理之前，我们需要先定义一下Lexer类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lexer</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/// 当前的token</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> currentToken: <span class="hljs-type">CurrentToken</span>?<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastChar: <span class="hljs-type">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> index <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment">/// 代码内容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> source: [<span class="hljs-type">Character</span>] <span class="hljs-operator">=</span> []<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>本工程解析代码通过index的增加从而依次从source中读取每一个字符进行处理。</p><h3 id="获取下一个token"><a href="#获取下一个token" class="headerlink" title="获取下一个token"></a>获取下一个token</h3><p>获取当前index对应的字符</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getChar</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Character</span> &#123;<br>    <span class="hljs-keyword">let</span> char <span class="hljs-operator">=</span> source[index]<br>    index <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> char<br>&#125;<br></code></pre></td></tr></table></figure><p>解析当前字符获取下一个currentToken</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 获取下一个currentToken</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextToken</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> identifierStr <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-comment">//如果是空白则继续往下读取</span><br>        <span class="hljs-keyword">while</span> lastChar.isWhitespace &#123;<br>            lastChar <span class="hljs-operator">=</span> getChar()<br>        &#125;<br>        <br>        <span class="hljs-comment">//如果开头是字母的话说明是identifier类型或者是其他关键字</span><br>        <span class="hljs-keyword">if</span> lastChar.isLetter &#123;<br>            identifierStr <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(lastChar)<br>            lastChar <span class="hljs-operator">=</span> getChar()<br>            <span class="hljs-keyword">while</span> lastChar.isNumber <span class="hljs-operator">||</span> lastChar.isLetter &#123;<br>                identifierStr.append(lastChar)<br>                lastChar <span class="hljs-operator">=</span> getChar()<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;def&quot;</span> &#123;<br>                currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .def, val: <span class="hljs-string">&quot;def&quot;</span>)<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> identifierStr <span class="hljs-operator">==</span> <span class="hljs-string">&quot;extern&quot;</span> &#123;<br>                currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .extern, val: <span class="hljs-string">&quot;extern&quot;</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .identifier, val: identifierStr)<br>            &#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <br>        <span class="hljs-comment">//是数字开头的话说明这个是一个数值</span><br>        <span class="hljs-keyword">if</span> lastChar.isNumber <span class="hljs-operator">||</span> lastChar <span class="hljs-operator">==</span> <span class="hljs-string">&quot;.&quot;</span> &#123;<br>            <span class="hljs-keyword">var</span> numStr <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-keyword">repeat</span> &#123;<br>                numStr.append(lastChar)<br>                lastChar <span class="hljs-operator">=</span> getChar()<br>            &#125; <span class="hljs-keyword">while</span> lastChar.isNumber <span class="hljs-operator">||</span> lastChar <span class="hljs-operator">==</span> <span class="hljs-string">&quot;.&quot;</span><br>            currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .number, val: numStr)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <br>        <span class="hljs-comment">//遇到&quot;;&quot;说明这一个函数块结束了</span><br>        <span class="hljs-keyword">let</span> thisChar <span class="hljs-operator">=</span> lastChar<br>        <span class="hljs-keyword">if</span> thisChar <span class="hljs-operator">!=</span> <span class="hljs-string">&quot;;&quot;</span> &#123;<br>            lastChar <span class="hljs-operator">=</span> getChar()<br>        &#125;<br>        <br>        <span class="hljs-comment">//返回其他类型仅作为占位使用</span><br>        currentToken <span class="hljs-operator">=</span> <span class="hljs-type">CurrentToken</span>(token: .other, val: <span class="hljs-type">String</span>(thisChar))<br>    &#125;<br></code></pre></td></tr></table></figure><p>代码详细的解释都体现在了注释中，现在我们已经完成了一个可以解析token的Lexer了。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教你使用swift写编译器玩具（0）</title>
    <link href="/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%880%EF%BC%89/"/>
    <url>/2020/07/05/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8swift%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%A9%E5%85%B7%EF%BC%880%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上学期学完编译原理之后总想搞个大事情，于是就萌生了写编译器的想法。在多方查找之下我发现了LLVM的<a href="http://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html">官方教程</a>。这个教程实现了一门玩具语言叫做<strong>Kaleidoscope</strong>。在官方教程中提供了即时编译执行以及生成目标文件被C++调用的两种执行方法，我在工程中也有一一对应实现。</p><p>官方教程是用C++写的，我就想能不能用swift来写呢？结果还真给我找到了办法，网上有一个现成的swift开源库<a href="https://github.com/llvm-swift/LLVMSwift">LLVMSwift</a>，封装了LLVM。当然我觉得不用这个库直接使用LLVM也是ok的，其实这样反而更贴近官方教程，使用那个开源库还得理解它的逻辑。</p><p>于是我把他们教程的前8章都写完了，<a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><p>教程如下:</p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（0）/">教你使用swift写编译器玩具（0）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（1）/">教你使用swift写编译器玩具（1）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（2）/">教你使用swift写编译器玩具（2）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（3）/">教你使用swift写编译器玩具（3）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（4）/">教你使用swift写编译器玩具（4）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（5）/">教你使用swift写编译器玩具（5）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（6）/">教你使用swift写编译器玩具（6）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（7）/">教你使用swift写编译器玩具（7）</a></p><p><a href="https://qyizhong.cn/2020/07/05/教你使用swift写编译器玩具（8）/">教你使用swift写编译器玩具（8）</a></p><p><a href="https://github.com/qyz777/Kaleidoscope">仓库在这</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>作为第0章我们首先要完成的是安装LLVM。网上关于这方面的文档非常少，这个自己摸索的过程真是十分痛苦，下面说一下如何去安装LLVM并在xcode中使用。</p><h3 id="下载LLVM"><a href="#下载LLVM" class="headerlink" title="下载LLVM"></a>下载LLVM</h3><p>首先我们通过homebrew下载LLVM</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span><span class="hljs-keyword">llvm</span><br></code></pre></td></tr></table></figure><p>下载完LLVM我们继续下载pkg-config</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>pkg-<span class="hljs-built_in">config</span><br></code></pre></td></tr></table></figure><h4 id="不使用LLVMSwift"><a href="#不使用LLVMSwift" class="headerlink" title="不使用LLVMSwift"></a>不使用LLVMSwift</h4><p>你需要在xcode直接引入LLVM可以通过添加环境到.bash_profile文件中实现</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 在.bash_profile下配置llvm命令行，具体情况根据你所安装的llvm版本不同</span><br>export PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>llvm<span class="hljs-regexp">/8.0.0_1/</span>bin:<span class="hljs-variable">$PATH</span>;<br></code></pre></td></tr></table></figure><p>然后在Xcode-&gt;Build Settings-&gt;Search Paths-&gt;Header Search Paths中添加</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/opt/</span>llvm/<span class="hljs-keyword">include</span><br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/opt/</span>llvm/lib<br></code></pre></td></tr></table></figure><h4 id="使用LLVMSwift"><a href="#使用LLVMSwift" class="headerlink" title="使用LLVMSwift"></a>使用LLVMSwift</h4><p>下载来之LLVMSwift的<a href="https://github.com/qyz777/Kaleidoscope/blob/master/utils/make-pkgconfig.swift">脚本</a>。</p><p>在Package中添加</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">.package(url: <span class="hljs-string">&quot;https://github.com/llvm-swift/LLVMSwift.git&quot;</span>, from: <span class="hljs-string">&quot;0.5.0&quot;</span>)<br></code></pre></td></tr></table></figure><p>并在target中依赖LLVM</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">dependencies:</span> [<span class="hljs-string">&quot;LLVM&quot;</span>]<br></code></pre></td></tr></table></figure><p>配置环境</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">swift</span> <span class="hljs-selector-tag">utils</span>/<span class="hljs-selector-tag">make-pkgconfig</span><span class="hljs-selector-class">.swift</span><br></code></pre></td></tr></table></figure><p>编译工程</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">swift build</span><br></code></pre></td></tr></table></figure><p>build完成之后就可以在工程中引入LLVM并使用LLVMSwift了。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tensorflow Lite实战——在iOS上部署中文文本分类模型</title>
    <link href="/2020/06/27/Tensorflow%20Lite%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%9C%A8iOS%E4%B8%8A%E9%83%A8%E7%BD%B2%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/06/27/Tensorflow%20Lite%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%9C%A8iOS%E4%B8%8A%E9%83%A8%E7%BD%B2%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本文所使用的分类模型来自于<a href="[https://github.com/gaussic/text-classification-cnn-rnn](https://github.com/gaussic/text-classification-cnn-rnn)">CNN-RNN中文文本分类，基于TensorFlow</a></strong>，感谢开源。</p><p>最近一段时间需要用到中文文本分类这样一个功能，于是我马上想到了Create ML，但是经过自己的尝试以后发现Create ML并不支持中文的文本分类(不信可以自己试试)。</p><p>最近发现有道词典有离线翻译这样一个功能，我猜测这应该就是把模型下载到本地使用了，这么一看模型部署到移动端理论上是可行的。但各个深度学习框架我只了解过tensorflow，于是在有这样一个需求之下，我又回到了tensorflow这个大坑，去年年底说我这辈子都不会再用tensorflow了，没想到真香了。</p><p>实际上tensorflow所训练的模型是放在后端最合适，但由于我不想给APP维护一个健壮的后端，所以执着于把模型部署到移动端。这个是<a href="https://github.com/qyz777/tensorflow_lite_swift_demo">Demo</a>。</p><p>言归正传，从头部署一个模型我可以归纳出几个步骤</p><ol><li>训练并测试模型，将模型保存为ckpt格式</li><li>将ckpt模型固化转成pb模型</li><li>通过TensorFlow Lite提供的方法将pb模型转换为tflite模型</li><li>使用cocoapods的方式引入TensorFlow Lite，并把模型导入工程</li><li>封装调用模型逻辑，进行文本分类</li></ol><p><strong>注意:</strong> 本篇博客仅根据上方的开源工程进行部署，其他的网络结构还需要具体问题具体分析。</p><h1 id="大致分类原理"><a href="#大致分类原理" class="headerlink" title="大致分类原理"></a>大致分类原理</h1><p>如果想要从头部署一遍，一定要对tensorflow有一定了解，因为不读懂工程的源码意思是基本上无法往下流程做的。</p><p>这个工程把每一个文本中的字符映射成一个个数字(id)，通过一系列玄学操作，得到一个一维数组，其中前10个就是我们要关注的值，因为标签只有10个。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>我们需要了解数据处理的方式即输入和输出，这样我们才能编写代码在iOS APP中进行预测。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>这个开源工程中会把每一个字符（汉字）映射成一个id，这个id来自于数据集中的行，意思就是第一行对应的字符id就是0，第二行对应的是1，以此类推。这样我们就获得了一个id的数组。并且这个id数组需要处理成一个固定长度，本文在iOS中处理方式为不足则数组后面添0，多余则移除数组末尾。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出的是一个数组，数量会超过10个，但因为数据集中的分类只有10个，所以我们只需要关注这个数组的前10个即可。这前10个数组对应的下标就是标签数组中的下标，数组的值就是预测的概率。所以输出的数组0-10的下标就对应了标签数组中0-10具体分类的可能性。</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>本文使用开源工程中的CNN网络，因为TensorFlow Lite支持的operators有限，所以不是所有的TensorFlow中的operators都支持，如果出现不支持的情况就会在转换中出现类似如下的错误:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Some <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> operators <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> model are <span class="hljs-keyword">not</span> supported <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> standard TensorFlow Lite runtime. If you have <span class="hljs-keyword">a</span> custom implementation <span class="hljs-keyword">for</span> them you can disable this error <span class="hljs-keyword">with</span> <span class="hljs-comment">--allow_custom_ops, or by setting allow_custom_ops=True when calling tf.contrib.lite.toco_convert(). Here is a list of operators for which  you will need custom implementations: RandomUniform</span><br></code></pre></td></tr></table></figure><p>这里的错误中可以发现不支持的operator是RandomUniform。查找之后发现CNN中的<strong>tf.contrib.layers.dropout</strong>不受支持，但是这个问题不大，我们可以用L2正则化去替代它防止过拟合。</p><p>下面是修改后的参考代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCNNConfig</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;CNN配置参数&quot;&quot;&quot;</span><br><br>    embedding_dim = <span class="hljs-number">64</span>  <span class="hljs-comment"># 词向量维度</span><br>    seq_length = <span class="hljs-number">600</span>  <span class="hljs-comment"># 序列长度</span><br>    num_classes = <span class="hljs-number">10</span>  <span class="hljs-comment"># 类别数</span><br>    num_filters = <span class="hljs-number">256</span>  <span class="hljs-comment"># 卷积核数目</span><br>    kernel_size = <span class="hljs-number">5</span>  <span class="hljs-comment"># 卷积核尺寸</span><br>    vocab_size = <span class="hljs-number">5000</span>  <span class="hljs-comment"># 词汇表达小</span><br><br>    hidden_dim = <span class="hljs-number">128</span>  <span class="hljs-comment"># 全连接层神经元</span><br><br>    dropout_keep_prob = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># dropout保留比例</span><br>    learning_rate = <span class="hljs-number">1e-3</span>  <span class="hljs-comment"># 学习率</span><br><br>    batch_size = <span class="hljs-number">64</span>  <span class="hljs-comment"># 每批训练大小</span><br>    num_epochs = <span class="hljs-number">10</span>  <span class="hljs-comment"># 总迭代轮次</span><br><br>    print_per_batch = <span class="hljs-number">100</span>  <span class="hljs-comment"># 每多少轮输出一次结果</span><br>    save_per_batch = <span class="hljs-number">10</span>  <span class="hljs-comment"># 每多少轮存入tensorboard</span><br><br>    scale = <span class="hljs-number">0.01</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextCNN</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;文本分类，CNN模型&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, config</span>):</span><br>        self.config = config<br><br>        <span class="hljs-comment"># 三个待输入的数据</span><br>        self.input_x = tf.placeholder(tf.int32, [<span class="hljs-literal">None</span>, self.config.seq_length], name=<span class="hljs-string">&#x27;input_x&#x27;</span>)<br>        self.input_y = tf.placeholder(tf.float32, [<span class="hljs-literal">None</span>, self.config.num_classes], name=<span class="hljs-string">&#x27;input_y&#x27;</span>)<br>        self.keep_prob = tf.placeholder(tf.float32, name=<span class="hljs-string">&#x27;keep_prob&#x27;</span>)<br><br>        self.cnn()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cnn</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;CNN模型&quot;&quot;&quot;</span><br>        my_dense_layer = partial(<br>            tf.layers.dense, activation=tf.nn.relu,<br>            <span class="hljs-comment"># 在这里传入了L2正则化函数，并在函数中传入正则化系数。</span><br>            kernel_regularizer=tf.contrib.layers.l2_regularizer(self.config.scale)<br>        )<br>        <span class="hljs-comment"># 词向量映射</span><br>        <span class="hljs-keyword">with</span> tf.device(<span class="hljs-string">&#x27;/cpu:0&#x27;</span>):<br>            embedding = tf.get_variable(<span class="hljs-string">&#x27;embedding&#x27;</span>, [self.config.vocab_size, self.config.embedding_dim])<br>            embedding_inputs = tf.nn.embedding_lookup(embedding, self.input_x)<br><br>        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">&quot;cnn&quot;</span>):<br>            <span class="hljs-comment"># CNN layer</span><br>            conv = tf.layers.conv1d(embedding_inputs, self.config.num_filters, self.config.kernel_size, name=<span class="hljs-string">&#x27;conv&#x27;</span>)<br>            <span class="hljs-comment"># global max pooling layer</span><br>            gmp = tf.reduce_max(conv, reduction_indices=[<span class="hljs-number">1</span>], name=<span class="hljs-string">&#x27;gmp&#x27;</span>)<br><br>        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">&quot;score&quot;</span>):<br>            <span class="hljs-comment"># 全连接层</span><br>            fc = my_dense_layer(gmp, self.config.hidden_dim, name=<span class="hljs-string">&#x27;fc1&#x27;</span>)<br>            <span class="hljs-comment"># fc = tf.layers.dense(gmp, self.config.hidden_dim, name=&#x27;fc1&#x27;)</span><br>            <span class="hljs-comment"># fc = tf.contrib.layers.dropout(fc, self.keep_prob)</span><br>            <span class="hljs-comment"># fc = tf.nn.relu(fc)</span><br><br>            <span class="hljs-comment"># 分类器</span><br>            self.logits = tf.layers.dense(fc, self.config.num_classes, name=<span class="hljs-string">&#x27;fc2&#x27;</span>)<br>            self.y_pred_cls = tf.argmax(tf.nn.softmax(self.logits), <span class="hljs-number">1</span>)  <span class="hljs-comment"># 预测类别</span><br><br>        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">&quot;optimize&quot;</span>):<br>            <span class="hljs-comment"># 损失函数，交叉熵</span><br>            cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=self.logits, labels=self.input_y)<br>            reg_losses = tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES)<br>            self.loss = tf.add_n([tf.reduce_mean(cross_entropy)] + reg_losses)<br>            <span class="hljs-comment"># self.loss = tf.reduce_mean(cross_entropy)</span><br>            <span class="hljs-comment"># 优化器</span><br>            self.optim = tf.train.AdamOptimizer(learning_rate=self.config.learning_rate).minimize(self.loss)<br><br>        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">&quot;accuracy&quot;</span>):<br>            <span class="hljs-comment"># 准确率</span><br>            correct_pred = tf.equal(tf.argmax(self.input_y, <span class="hljs-number">1</span>), self.y_pred_cls)<br>            self.acc = tf.reduce_mean(tf.cast(correct_pred, tf.float32))<br><br></code></pre></td></tr></table></figure><p>接下来在run_cnn.py中经过训练就能获得如下ckpt模型了:<br><img src="https://cdn.qyizhong.cn/8216167-07fab3cb4052360a.png" alt="ckpt模型"></p><h2 id="将ckpt模型固化转成pb模型"><a href="#将ckpt模型固化转成pb模型" class="headerlink" title="将ckpt模型固化转成pb模型"></a>将ckpt模型固化转成pb模型</h2><p>在固化模型这一个环节，你需要通读这个开源工程才行，不然你肯定不了解它的网络结构以及它的输入和输出。这也是对iOS开发者非常不友好的地方。</p><p>通过源码我们可以得知<strong>TextCNN</strong>这个类中的<strong>self.logits</strong>这个属性就是我们需要关注的输出，所以我们可以通过下面这段代码打印出tensor，然后找到我们需要的输出的name</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">ops = sess.graph.get_operations()<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">op</span> <span class="hljs-keyword">in</span> ops:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">op</span>)<br></code></pre></td></tr></table></figure><p>这里我们需要的name是</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">output_node_names</span> = <span class="hljs-string">&quot;score/fc2/BiasAdd&quot;</span><br></code></pre></td></tr></table></figure><p>参考源码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">freeze_graph</span>(<span class="hljs-params">input_checkpoint</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param input_checkpoint:</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># checkpoint = tf.train.get_checkpoint_state(model_folder) #检查目录下ckpt文件状态是否可用</span><br>    <span class="hljs-comment"># input_checkpoint = checkpoint.model_checkpoint_path #得ckpt文件路径</span><br><br>    <span class="hljs-comment"># 指定输出的节点名称,该节点名称必须是原模型中存在的节点</span><br>    output_node_names = <span class="hljs-string">&quot;score/fc2/BiasAdd&quot;</span><br>    saver = tf.train.import_meta_graph(input_checkpoint + <span class="hljs-string">&#x27;.meta&#x27;</span>, clear_devices=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:<br>        saver.restore(sess, input_checkpoint)  <span class="hljs-comment"># 恢复图并得到数据</span><br>        output_graph_def = tf.graph_util.convert_variables_to_constants(  <span class="hljs-comment"># 模型持久化，将变量值固定</span><br>            sess=sess,<br>            input_graph_def=sess.graph_def,  <span class="hljs-comment"># 等于:sess.graph_def</span><br>            output_node_names=output_node_names.split(<span class="hljs-string">&quot;,&quot;</span>)<br>        )  <span class="hljs-comment"># 如果有多个输出节点，以逗号隔开</span><br><br>        <span class="hljs-keyword">with</span> tf.gfile.GFile(output_graph, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment"># 保存模型</span><br>            f.write(output_graph_def.SerializeToString())  <span class="hljs-comment"># 序列化输出</span><br></code></pre></td></tr></table></figure><p>input_checkpoint为你的ckpt模型路径</p><h2 id="将pb模型转换为tflite模型"><a href="#将pb模型转换为tflite模型" class="headerlink" title="将pb模型转换为tflite模型"></a>将pb模型转换为tflite模型</h2><p>下面是<strong>from_frozen_graph</strong>方法的注解。这里我就要吐槽一下了，TensorFlow Lite的文档未免太敷衍了，说好的传入参数是一个[tensor]，结果老报错，在打断点调试了它们库的源码情况下发现竟然要求的是传入tensor的name？？？</p><p><img src="https://cdn.qyizhong.cn/8216167-8587e8f6b65ce590.png" alt="from_frozen_graph方法注解"></p><p>这个只要没有出现operator不支持的情况就很简单，直接上源码就完了</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nix">def convert_to_tflite():<br>    <span class="hljs-attr">input_tensors</span> = [<br>        <span class="hljs-string">&quot;input_x&quot;</span><br>    ]<br>    <span class="hljs-attr">output_tensors</span> = [<br>        <span class="hljs-string">&quot;score/fc2/BiasAdd&quot;</span><br>    ]<br>    <span class="hljs-attr">converter</span> = tf.lite.TFLiteConverter.from_frozen_graph(<br>        output_graph,<br>        input_tensors,<br>        output_tensors)<br>    converter.<span class="hljs-attr">target_ops</span> = [tf.lite.OpsSet.TFLITE_BUILTINS,<br>                            tf.lite.OpsSet.SELECT_TF_OPS]<br>    <span class="hljs-attr">tflite_model</span> = converter.convert()<br>    open(output_tflite_model, <span class="hljs-string">&quot;wb&quot;</span>).write(tflite_model)<br></code></pre></td></tr></table></figure><p>其中<strong>input_x</strong>是输入的name</p><h2 id="使用cocoapods的方式引入TensorFlow-Lite"><a href="#使用cocoapods的方式引入TensorFlow-Lite" class="headerlink" title="使用cocoapods的方式引入TensorFlow Lite"></a>使用cocoapods的方式引入TensorFlow Lite</h2><p>TensorFlow Lite有好几个库，原生的需要写C++，在一顿操作之下我放弃了，完全看不懂tensor的输入嘛。还有<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/experimental/objc">OC封装</a>的以及<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/experimental/swift">swift封装</a>的。因为我的工程是swift写的，所以我直接用swift的TensorFlow Lite库</p><p>按照他们的README</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> <span class="hljs-string">&#x27;TensorFlowLiteSwift&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> TensorFlowLite<br></code></pre></td></tr></table></figure><p>就引入了，这一点就很友好了，比什么直接编译TensorFlow到iOS工程里那是简单的不能再简单了。</p><h2 id="封装调用模型逻辑，进行文本分类"><a href="#封装调用模型逻辑，进行文本分类" class="headerlink" title="封装调用模型逻辑，进行文本分类"></a>封装调用模型逻辑，进行文本分类</h2><p>在喂数据进行预测时我们也要按照开源工程里喂数据的方式进行一番操作。调用的逻辑我们可以参考<a href="(https://github.com/tensorflow/examples/blob/master/lite/examples/image_classification/ios/ImageClassification/ModelDataHandler/ModelDataHandler.swift)">官方Example</a></p><h3 id="导入模型"><a href="#导入模型" class="headerlink" title="导入模型"></a>导入模型</h3><p>我们需要导入模型、分类和字符id，这在本文的前言中提供的demo中有体现。</p><p><img src="https://cdn.qyizhong.cn/8216167-eae6ed14bcb96cba.png" alt="必须导入的东西"></p><h3 id="初始化Interpreter"><a href="#初始化Interpreter" class="headerlink" title="初始化Interpreter"></a>初始化Interpreter</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> init<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-keyword">let</span> options = <span class="hljs-constructor">InterpreterOptions()</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// Create the `Interpreter`.</span><br>            <span class="hljs-keyword">let</span> modelPath = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bundle</span>.</span></span>init(<span class="hljs-keyword">for</span>: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextClassifier</span>.</span></span>self).path(forResource: <span class="hljs-string">&quot;model&quot;</span>, ofType: <span class="hljs-string">&quot;tflite&quot;</span>)!<br>            interpreter = <span class="hljs-keyword">try</span> <span class="hljs-constructor">Interpreter(<span class="hljs-params">modelPath</span>: <span class="hljs-params">modelPath</span>, <span class="hljs-params">options</span>: <span class="hljs-params">options</span>)</span><br>            <span class="hljs-comment">// Allocate memory for the model&#x27;s input `Tensor`s.</span><br>            <span class="hljs-keyword">try</span> interpreter.allocate<span class="hljs-constructor">Tensors()</span><br>        &#125; catch &#123;<br>            print(<span class="hljs-string">&quot;Failed to create the interpreter with error: \(error.localizedDescription)&quot;</span>)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="加载标签、id以及将字符转换为id"><a href="#加载标签、id以及将字符转换为id" class="headerlink" title="加载标签、id以及将字符转换为id"></a>加载标签、id以及将字符转换为id</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> func <span class="hljs-function"><span class="hljs-title">loadLabels</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path = Bundle.init(<span class="hljs-keyword">for</span>: TextClassifier.self).path(forResource: <span class="hljs-string">&quot;labels&quot;</span>, <span class="hljs-attr">ofType</span>: <span class="hljs-string">&quot;txt&quot;</span>) &#123;<br>            <span class="hljs-keyword">let</span> fileManager = FileManager.default<br>            <span class="hljs-keyword">let</span> txtData = fileManager.contents(atPath: path)!<br>            <span class="hljs-keyword">let</span> content = <span class="hljs-built_in">String</span>.init(data: txtData, <span class="hljs-attr">encoding</span>: .utf8)<br>            <span class="hljs-keyword">let</span> rowArray = content?.split(separator: <span class="hljs-string">&quot;\n&quot;</span>) ?? []<br>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rowArray &#123;<br>                labels.append(<span class="hljs-built_in">String</span>(row))<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> func <span class="hljs-function"><span class="hljs-title">loadTextId</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path = Bundle.init(<span class="hljs-keyword">for</span>: TextClassifier.self).path(forResource: <span class="hljs-string">&quot;text_id&quot;</span>, <span class="hljs-attr">ofType</span>: <span class="hljs-string">&quot;txt&quot;</span>) &#123;<br>            <span class="hljs-keyword">let</span> fileManager = FileManager.default<br>            <span class="hljs-keyword">let</span> txtData = fileManager.contents(atPath: path)!<br>            <span class="hljs-keyword">let</span> content = <span class="hljs-built_in">String</span>.init(data: txtData, <span class="hljs-attr">encoding</span>: .utf8)<br>            <span class="hljs-keyword">let</span> rowArray = content?.split(separator: <span class="hljs-string">&quot;\n&quot;</span>) ?? []<br>            <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rowArray &#123;<br>                textIdInfo[<span class="hljs-built_in">String</span>(row)] = i<br>                i += <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> func transformTextToId(_ text: <span class="hljs-built_in">String</span>) -&gt; [Int] &#123;<br>        <span class="hljs-keyword">var</span> idArray: [Int] = []<br>        <span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> text &#123;<br>            idArray.append(textIdInfo[<span class="hljs-built_in">String</span>(str)]!)<br>        &#125;<br>        <span class="hljs-comment">//根据python工程中的输入设置，超出截取前面，不足后面补0</span><br>        <span class="hljs-keyword">while</span> idArray.count &lt; <span class="hljs-number">2400</span> &#123;<br>            idArray.append(<span class="hljs-number">0</span>)<br>        &#125;<br>        <span class="hljs-keyword">while</span> idArray.count &gt; <span class="hljs-number">2400</span> &#123;<br>            idArray.removeLast()<br>        &#125;<br>        <span class="hljs-keyword">return</span> idArray<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="进行预测"><a href="#进行预测" class="headerlink" title="进行预测"></a>进行预测</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runModel</span><span class="hljs-params">(with text: String, closure: @escaping<span class="hljs-params">(InferenceReslutClosure)</span></span></span>) &#123;<br>        <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>            <span class="hljs-keyword">let</span> idArray <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.transformTextToId(text)<br>            <span class="hljs-keyword">let</span> outputTensor: <span class="hljs-type">Tensor</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.interpreter.input(at: <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">let</span> idData <span class="hljs-operator">=</span> <span class="hljs-type">Data</span>.<span class="hljs-keyword">init</span>(bytes: idArray, count: idArray.count)<br>                <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.interpreter.copy(idData, toInputAt: <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.interpreter.invoke()<br>                outputTensor <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.interpreter.output(at: <span class="hljs-number">0</span>)<br>            &#125; <span class="hljs-keyword">catch</span> &#123;<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;An error occurred while entering data: <span class="hljs-subst">\(error.localizedDescription)</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">let</span> results: [<span class="hljs-type">Float</span>]<br>            <span class="hljs-keyword">switch</span> outputTensor.dataType &#123;<br>            <span class="hljs-keyword">case</span> .uInt8:<br>                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> quantization <span class="hljs-operator">=</span> outputTensor.quantizationParameters <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No results returned because the quantization values for the output tensor are nil.&quot;</span>)<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                <span class="hljs-keyword">let</span> quantizedResults <span class="hljs-operator">=</span> [<span class="hljs-type">UInt8</span>](outputTensor.data)<br>                results <span class="hljs-operator">=</span> quantizedResults.map &#123;<br>                    quantization.scale <span class="hljs-operator">*</span> <span class="hljs-type">Float</span>(<span class="hljs-type">Int</span>(<span class="hljs-variable">$0</span>) <span class="hljs-operator">-</span> quantization.zeroPoint)<br>                &#125;<br>            <span class="hljs-keyword">case</span> .float32:<br>                results <span class="hljs-operator">=</span> outputTensor.data.withUnsafeBytes( &#123; (ptr: <span class="hljs-type">UnsafeRawBufferPointer</span>) <span class="hljs-keyword">in</span><br>                    [<span class="hljs-type">Float32</span>](<span class="hljs-type">UnsafeBufferPointer</span>.<span class="hljs-keyword">init</span>(start: ptr.baseAddress<span class="hljs-operator">?</span>.assumingMemoryBound(to: <span class="hljs-type">Float32</span>.<span class="hljs-keyword">self</span>), count: ptr.count))<br>                &#125;)<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output tensor data type <span class="hljs-subst">\(outputTensor.dataType)</span> is unsupported for this app.&quot;</span>)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">let</span> resultArray <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.getTopN(results: results)<br>            <span class="hljs-type">DispatchQueue</span>.main.async &#123;<br>                closure(resultArray)<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先我们需要把[Int]类型转换为Data类型提供给interpreter，可以如下方法转换</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> idData = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Data</span>.</span></span>init(<span class="hljs-built_in">bytes</span>: idArray, count: idArray.count)<br></code></pre></td></tr></table></figure><p><strong>invoke()</strong>方法为调用模型进行预测</p><p>我们拿到输出<strong>outputTensor</strong>以后，它的dataType中的float32类型就是我们需要的输出，这是因为在开源工程中的输出就是float32类型。这里我们需要用swift的指针去把Data类型换为[Float]类型，如下:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">results = outputTensor.data.<span class="hljs-keyword">with</span><span class="hljs-constructor">UnsafeBytes( &#123; (<span class="hljs-params">ptr</span>: UnsafeRawBufferPointer)</span> <span class="hljs-keyword">in</span><br>                    <span class="hljs-literal">[F<span class="hljs-identifier">loat32</span>]</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnsafeBufferPointer</span>.</span></span>init(start: ptr.baseAddress?.assuming<span class="hljs-constructor">MemoryBound(<span class="hljs-params">to</span>: Float32.<span class="hljs-params">self</span>)</span>, count: ptr.count))<br>                &#125;)<br></code></pre></td></tr></table></figure><p>至于上面那个.UInt8我没有搞懂是什么意思，但我想我的输出都是float32类型，所以应该是不会走上面那个case。</p><p>最后我们通过<strong>getTopN</strong>方法取到前3个可能性最大的标签(预测值)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTopN</span><span class="hljs-params">(results: [Float])</span></span> -&gt; [<span class="hljs-type">Inference</span>] &#123;<br>        <span class="hljs-comment">//创建元组数组 [(labelIndex: Int, confidence: Float)]</span><br>        <span class="hljs-keyword">let</span> zippedResults <span class="hljs-operator">=</span> <span class="hljs-built_in">zip</span>(labels.indices, results)<br>        <span class="hljs-comment">//从大到小排序并选出前resultCount个(根据python工程中的训练，只取前10个，因为分类只有10个)</span><br>        <span class="hljs-keyword">let</span> sortedResults <span class="hljs-operator">=</span> zippedResults.sorted &#123; <span class="hljs-variable">$0</span>.<span class="hljs-number">1</span> <span class="hljs-operator">&gt;</span> <span class="hljs-variable">$1</span>.<span class="hljs-number">1</span> &#125;.prefix(resultCount)<br>        <span class="hljs-comment">//返回前resultCount对应的标签以及预测值</span><br>        <span class="hljs-keyword">return</span> sortedResults.map &#123; result <span class="hljs-keyword">in</span> <span class="hljs-type">Inference</span>.<span class="hljs-keyword">init</span>(confidence: result.<span class="hljs-number">1</span>, label: labels[result.<span class="hljs-number">0</span>]) &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>这里取的逻辑就像上述所说的，我们只关注输出一维数组的前10个元素，然后给他们排个序取最大三个值，这三个值所在的下标直接在标签数组中取值就能获得对应的预测分类</strong>。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>博客只是一个预览，详细的逻辑还是需要直接看<a href="https://github.com/qyz777/tensorflow_lite_swift_demo">Demo</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/gaussic/text-classification-cnn-rnn">CNN-RNN中文文本分类，基于TensorFlow</a><br><a href="https://codelabs.developers.google.com/codelabs/tensorflow-for-poets-2-ios/#0">TensorFlow for Poets 2: TFLite iOS</a><br><a href="https://www.jianshu.com/p/c13ed339e6a6">【IOS/Android】TensorflowLite移动端部署</a><br><a href="https://github.com/tensorflow/examples/blob/master/lite/examples/image_classification/ios/ImageClassification/ModelDataHandler/ModelDataHandler.swift">TensorFlow Lite Swift Example</a><br><a href="https://stackoverflow.com/questions/50632152/tensorflow-convert-pb-file-to-tflite-using-python">Tensorflow Convert pb file to TFLITE using python</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>TensorFlow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVOController源码全解析</title>
    <link href="/2020/06/27/KVOController%E6%BA%90%E7%A0%81%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/06/27/KVOController%E6%BA%90%E7%A0%81%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在阅读公司源码的一些功能时发现了KVOController这个神奇的库。这个库十分的好用，可以主动的去观察一个对象的属性。</p><p>例如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span>.KVOControllerNonRetaining observe:_test<br>                                    keyPath:<span class="hljs-string">@&quot;test&quot;</span><br>                                    options:<span class="hljs-number">0</span><br>                                      block::^(<span class="hljs-keyword">id</span> _Nullable observer, <span class="hljs-keyword">id</span> object, <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *change) &#123;<br>                                          <br>                                      &#125;];<br></code></pre></td></tr></table></figure><p>KVOController的源码不多，加上分类也就不到800行，所以我花了一段时间阅读它的源码，这篇文章是阅读源码的总结。</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>下图是我通过阅读源码画的UML类图，因为有些偷懒，所以这个类图的方法并不全。但这并不重要，这张类图的意义在于我们能够清晰地看明白他们之间的关系。</p><p><img src="https://cdn.qyizhong.cn/8216167-6d7422401bf1329a.png" alt="KVOController类图.png"></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="FBKVOInfo"><a href="#FBKVOInfo" class="headerlink" title="_FBKVOInfo"></a>_FBKVOInfo</h2><p>_FBKVOInfo作为一个被两个类组合的类，在KVOController中属于Model的性质，用来保存所需要的内容，以下是这个类拥有的变量</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__weak</span> FBKVOController *<span class="hljs-variable">_controller</span>;<br>  NSString *<span class="hljs-variable">_keyPath</span>;<br>  NSKeyValueObservingOptions <span class="hljs-variable">_options</span>;<br>  SEL <span class="hljs-variable">_action</span>;<br>  void *<span class="hljs-variable">_context</span>;<br>  FBKVONotificationBlock <span class="hljs-variable">_block</span>;<br>  <span class="hljs-variable">_FBKVOInfoState</span> <span class="hljs-variable">_state</span>;<br></code></pre></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="_controller"></a>_controller</h3><p>_FBKVOInfo在FBKVOController中初始化，初始化时就把FBKVOController对象持有了，这里用一个weak修饰防止循环引用</p><h3 id="keyPath"><a href="#keyPath" class="headerlink" title="_keyPath"></a>_keyPath</h3><p>这个应该不怎么需要解释，这个就是KVO观察的keyPath</p><h3 id="options"><a href="#options" class="headerlink" title="_options"></a>_options</h3><p>这个也是KVO观察的设置，是一个枚举，设置不同的枚举KVO效果是不同的，这里就不详细展开了。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_OPTIONS</span>(<span class="hljs-type">NSUInteger</span>, <span class="hljs-type">NSKeyValueObservingOptions</span>) &#123;<br>    <span class="hljs-type">NSKeyValueObservingOptionNew</span> = 0x01,<br>    <span class="hljs-type">NSKeyValueObservingOptionOld</span> = 0x02,<br>    <span class="hljs-type">NSKeyValueObservingOptionInitial</span> = 0x04,<br>    <span class="hljs-type">NSKeyValueObservingOptionPrior</span> = 0x08<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="action、-block"><a href="#action、-block" class="headerlink" title="_action、_block"></a>_action、_block</h3><p>这个是用来保存FBKVOController需要调用的方法和block</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文，这个也不多解释</p><h3 id="state"><a href="#state" class="headerlink" title="_state"></a>_state</h3><p>这是一个很重要的枚举，用来保存_FBKVOInfo所对应对象的观察状态</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">typedef NS_ENUM(uint8_t, <span class="hljs-variable">_FBKVOInfoState</span>) &#123;<br><span class="hljs-comment">// 初始化状态</span><br>  <span class="hljs-variable">_FBKVOInfoStateInitial</span> = <span class="hljs-number">0</span>,<br><span class="hljs-comment">// 被观察状态</span><br>  <span class="hljs-variable">_FBKVOInfoStateObserving</span>,<br><span class="hljs-comment">// 没被观察状态</span><br>  <span class="hljs-variable">_FBKVOInfoStateNotObserving</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="FBKVOController"><a href="#FBKVOController" class="headerlink" title="FBKVOController"></a>FBKVOController</h2><p>FBKVOController是KVOController对外暴露的类，其中我们主要用以下两个方法</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>observe:<span class="hljs-params">(nullable id)</span>object keyPath:<span class="hljs-params">(NSString *)</span>keyPath options:<span class="hljs-params">(NSKeyValueObservingOptions)</span>options block:<span class="hljs-params">(FBKVONotificationBlock)</span>block;<br><br>- <span class="hljs-params">(void)</span>observe:<span class="hljs-params">(nullable id)</span>object keyPath:<span class="hljs-params">(NSString *)</span>keyPath options:<span class="hljs-params">(NSKeyValueObservingOptions)</span>options action:<span class="hljs-params">(SEL)</span>action;<br></code></pre></td></tr></table></figure><p>一个是KVO之后的block的回调，另一个是KVO之后调用的方法，下面我们以第一个方法进行讲解。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (<span class="hljs-type">void</span>)observe:(nullable id)<span class="hljs-keyword">object</span> keyPath:(NSString *)keyPath <span class="hljs-keyword">options</span>:(NSKeyValueObservingOptions)<span class="hljs-keyword">options</span> block:(FBKVONotificationBlock)block<br>&#123;<br>  NSAssert(<span class="hljs-number">0</span> != keyPath.length &amp;&amp; <span class="hljs-keyword">NULL</span> != block, @&quot;missing required parameters observe:%@ keyPath:%@ block:%p&quot;, <span class="hljs-keyword">object</span>, keyPath, block);<br>  <span class="hljs-keyword">if</span> (nil == <span class="hljs-keyword">object</span> || <span class="hljs-number">0</span> == keyPath.length || <span class="hljs-keyword">NULL</span> == block) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  // <span class="hljs-keyword">create</span> <span class="hljs-keyword">info</span><br>  _FBKVOInfo *<span class="hljs-keyword">info</span> = [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath <span class="hljs-keyword">options</span>:<span class="hljs-keyword">options</span> block:block];<br><br>  // observe <span class="hljs-keyword">object</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">info</span><br>  [self _observe:<span class="hljs-keyword">object</span> <span class="hljs-keyword">info</span>:<span class="hljs-keyword">info</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>方法执行步骤:</p><ol><li>断言以及错误判断</li><li>创建一个_FBKVOInfo对象</li><li>调用_observe:info:</li></ol><p>根据上文的结论，我们可以得知_FBKVOInfo是一个Model的存在，所以需要先把它初始化了。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (<span class="hljs-type">void</span>)_observe:(id)<span class="hljs-keyword">object</span> <span class="hljs-keyword">info</span>:(_FBKVOInfo *)<span class="hljs-keyword">info</span><br>&#123;<br>  // <span class="hljs-keyword">lock</span><br>  pthread_mutex_lock(&amp;_lock);<br><br>  NSMutableSet *infos = [_objectInfosMap objectForKey:<span class="hljs-keyword">object</span>];<br><br>  // <span class="hljs-keyword">check</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">info</span> existence<br>  _FBKVOInfo *existingInfo = [infos member:<span class="hljs-keyword">info</span>];<br>  <span class="hljs-keyword">if</span> (nil != existingInfo) &#123;<br>    // observation <span class="hljs-keyword">info</span> already <span class="hljs-keyword">exists</span>; <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> observe it again<br><br>    // unlock <span class="hljs-keyword">and</span> <span class="hljs-keyword">return</span><br>    pthread_mutex_unlock(&amp;_lock);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  // lazilly <span class="hljs-keyword">create</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> infos<br>  <span class="hljs-keyword">if</span> (nil == infos) &#123;<br>    infos = [NSMutableSet <span class="hljs-keyword">set</span>];<br>    [_objectInfosMap setObject:infos forKey:<span class="hljs-keyword">object</span>];<br>  &#125;<br><br>  // <span class="hljs-keyword">add</span> <span class="hljs-keyword">info</span> <span class="hljs-keyword">and</span> oberve<br>  [infos addObject:<span class="hljs-keyword">info</span>];<br><br>  // unlock prior <span class="hljs-keyword">to</span> callout<br>  pthread_mutex_unlock(&amp;_lock);<br><br>  [[_FBKVOSharedController sharedController] observe:<span class="hljs-keyword">object</span> <span class="hljs-keyword">info</span>:<span class="hljs-keyword">info</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>_objectInfosMap是临界资源，所以在这个方法里进行加锁防止资源被争抢。</p><p>方法执行步骤:</p><ol><li>加锁</li><li>判断是否存在，存在即解锁结束，不需要再次观察；不存在则进入步骤3</li><li>判断_objectInfosMap所对应的集合是否存在，存在则继续；不存在则初始化并保存在_objectInfosMap中</li><li>保存新的_FBKVOInfo对象</li><li>解锁</li><li>调用_FBKVOSharedController</li></ol><p>这里涉及到一个知识点是NSMapTable，这是一个类似NSDictionary的容器，但是它不仅能做到key和value之间的映射关系，它也能做到object和object之间的映射关系。这种object和object之间的映射关系在KVOController中体现的很好，每一个被观察者(object)对应一个_FBKVOInfo对象(object)。推荐阅读<a href="http://www.isaced.com/post-235.html">NSMapTable: 不只是一个能放weak指针的 NSDictionary</a></p><h2 id="FBKVOSharedController"><a href="#FBKVOSharedController" class="headerlink" title="_FBKVOSharedController"></a>_FBKVOSharedController</h2><p>_FBKVOSharedController它是一个单例，这个私有类才是KVOController提供服务的实际实现类。</p><p>我们继续来看_FBKVOSharedController被FBKVOController所调用的方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (<span class="hljs-type">void</span>)observe:(id)<span class="hljs-keyword">object</span> <span class="hljs-keyword">info</span>:(nullable _FBKVOInfo *)<span class="hljs-keyword">info</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (nil == <span class="hljs-keyword">info</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  // register <span class="hljs-keyword">info</span><br>  pthread_mutex_lock(&amp;_mutex);<br>  [_infos addObject:<span class="hljs-keyword">info</span>];<br>  pthread_mutex_unlock(&amp;_mutex);<br><br>  // <span class="hljs-keyword">add</span> observer<br>  [<span class="hljs-keyword">object</span> addObserver:self forKeyPath:<span class="hljs-keyword">info</span>-&gt;_keyPath <span class="hljs-keyword">options</span>:<span class="hljs-keyword">info</span>-&gt;_options context:(<span class="hljs-type">void</span> *)<span class="hljs-keyword">info</span>];<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">info</span>-&gt;_state == _FBKVOInfoStateInitial) &#123;<br>    <span class="hljs-keyword">info</span>-&gt;_state = _FBKVOInfoStateObserving;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">info</span>-&gt;_state == _FBKVOInfoStateNotObserving) &#123;<br>    [<span class="hljs-keyword">object</span> removeObserver:self forKeyPath:<span class="hljs-keyword">info</span>-&gt;_keyPath context:(<span class="hljs-type">void</span> *)<span class="hljs-keyword">info</span>];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法执行步骤:</p><ol><li>添加临界资源</li><li>注册观察</li><li>判断_FBKVOInfo对象state，若为初始化，则改变为观察中，若为不在观察中，则移除这个观察</li></ol><p>这里涉及到NSHashTable，这个类似于NSSet，本文对此不展开说明。</p><p>之所以说_FBKVOSharedController才是KVOSharedController的实际实现类是因为它实现了KVO的回调方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSString</span> *)keyPath<br>                      ofObject:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)object<br>                        change:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *)change<br>                       context:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">void</span> *)context<br></code></pre></td></tr></table></figure><p>我们来看一下里面的内容</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSString</span> *)keyPath<br>                      ofObject:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)object<br>                        change:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *)change<br>                       context:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">void</span> *)context<br>&#123;<br>  <span class="hljs-built_in">NSAssert</span>(context, <span class="hljs-string">@&quot;missing context keyPath:%@ object:%@ change:%@&quot;</span>, keyPath, object, change);<br><br>  _FBKVOInfo *info;<br><br>  &#123;<br>    <span class="hljs-comment">// lookup context in registered infos, taking out a strong reference only if it exists</span><br>    pthread_mutex_lock(&amp;_mutex);<br>    info = [_infos member:(__bridge <span class="hljs-keyword">id</span>)context];<br>    pthread_mutex_unlock(&amp;_mutex);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != info) &#123;<br><br>    <span class="hljs-comment">// take strong reference to controller</span><br>    FBKVOController *controller = info-&gt;_controller;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != controller) &#123;<br><br>      <span class="hljs-comment">// take strong reference to observer</span><br>      <span class="hljs-keyword">id</span> observer = controller.observer;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != observer) &#123;<br><br>        <span class="hljs-comment">// dispatch custom block or action, fall back to default action</span><br>        <span class="hljs-keyword">if</span> (info-&gt;_block) &#123;<br>          <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *changeWithKeyPath = change;<br>          <span class="hljs-comment">// add the keyPath to the change dictionary for clarity when mulitple keyPaths are being observed</span><br>          <span class="hljs-keyword">if</span> (keyPath) &#123;<br>            <span class="hljs-built_in">NSMutableDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *mChange = [<span class="hljs-built_in">NSMutableDictionary</span> dictionaryWithObject:keyPath forKey:FBKVONotificationKeyPathKey];<br>            [mChange addEntriesFromDictionary:change];<br>            changeWithKeyPath = [mChange <span class="hljs-keyword">copy</span>];<br>          &#125;<br>          info-&gt;_block(observer, object, changeWithKeyPath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info-&gt;_action) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic push</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic ignored <span class="hljs-meta-string">&quot;-Warc-performSelector-leaks&quot;</span></span><br>          [observer performSelector:info-&gt;_action withObject:change withObject:object];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic pop</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法执行步骤</p><ol><li>断言</li><li>通过context上下文从临界资源_infos中拿到info</li><li>进行保护，防止持有的FBKVOController和observe为空</li><li>判断_info持有的block或SEL是否存在，存在则调用;不存在则把消息转发给observe</li></ol><p>最后一步调用发现block或者SEL都不存在时必须让object调用，因为observe里可能存在observeValueForKeyPath的实现</p><h2 id="为什么使用FBKVOController不需要移除通知"><a href="#为什么使用FBKVOController不需要移除通知" class="headerlink" title="为什么使用FBKVOController不需要移除通知"></a>为什么使用FBKVOController不需要移除通知</h2><p>在FBKVOController的dealloc里是这样写的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">dealloc</span><br>&#123;<br>  <span class="hljs-selector-attr">[self unobserveAll]</span>;<br>  <span class="hljs-selector-tag">pthread_mutex_destroy</span>(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>unobserveAll所调用的是</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sqf">- (void)<span class="hljs-variable">_unobserveAll</span><br>&#123;<br>  <span class="hljs-comment">// lock</span><br>  pthread_mutex_lock(&amp;<span class="hljs-variable">_lock</span>);<br><br>  NSMapTable *objectInfoMaps = [<span class="hljs-variable">_objectInfosMap</span> copy];<br><br>  <span class="hljs-comment">// clear table and map</span><br>  [<span class="hljs-variable">_objectInfosMap</span> removeAllObjects];<br><br>  <span class="hljs-comment">// unlock</span><br>  pthread_mutex_unlock(&amp;<span class="hljs-variable">_lock</span>);<br><br>  <span class="hljs-variable">_FBKVOSharedController</span> *shareController = [<span class="hljs-variable">_FBKVOSharedController</span> sharedController];<br><br>  <span class="hljs-keyword">for</span> (id object <span class="hljs-built_in">in</span> objectInfoMaps) &#123;<br>    <span class="hljs-comment">// unobserve each registered object and infos</span><br>    NSSet *infos = [objectInfoMaps objectForKey:object];<br>    [shareController unobserve:object infos:infos];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现FBKVOController通过遍历Map，把所持有的观察者都一一去除了</p><p>最终调用的方法是_FBKVOSharedController的取消观察方法</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sqf">- (void)unobserve:(id)object infos:(nullable NSSet&lt;<span class="hljs-variable">_FBKVOInfo</span> *&gt; *)infos<br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == infos.<span class="hljs-built_in">count</span>) &#123;<br>    return;<br>  &#125;<br><br>  <span class="hljs-comment">// unregister info</span><br>  pthread_mutex_lock(&amp;<span class="hljs-variable">_mutex</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-variable">_FBKVOInfo</span> *info <span class="hljs-built_in">in</span> infos) &#123;<br>    [<span class="hljs-variable">_infos</span> removeObject:info];<br>  &#125;<br>  pthread_mutex_unlock(&amp;<span class="hljs-variable">_mutex</span>);<br><br>  <span class="hljs-comment">// remove observer</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-variable">_FBKVOInfo</span> *info <span class="hljs-built_in">in</span> infos) &#123;<br>    <span class="hljs-keyword">if</span> (info-&gt;<span class="hljs-variable">_state</span> == <span class="hljs-variable">_FBKVOInfoStateObserving</span>) &#123;<br>      [object removeObserver:self forKeyPath:info-&gt;<span class="hljs-variable">_keyPath</span> context:(void *)info];<br>    &#125;<br>    info-&gt;<span class="hljs-variable">_state</span> = <span class="hljs-variable">_FBKVOInfoStateNotObserving</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法可以看出来object所对应的_FBKVOSharedController所持有的_FBKVOInfo全部都被removeObserver了</p><h2 id="“NSObject-FBKVOController-h”"><a href="#“NSObject-FBKVOController-h”" class="headerlink" title="“NSObject+FBKVOController.h”"></a>“NSObject+FBKVOController.h”</h2><p>KVOController还有一个NSObject的分类，提供两种方式使用KVOController的懒加载，分别是持有方式和不持有方式。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (FBKVOController *)KVOController<br>&#123;<br>  <span class="hljs-keyword">id</span> controller = objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSObjectKVOControllerKey</span>);<br>  <br>  <span class="hljs-comment">// lazily create the KVOController</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == controller) &#123;<br>    controller = [FBKVOController controllerWithObserver:<span class="hljs-keyword">self</span>];<br>    <span class="hljs-keyword">self</span>.KVOController = controller;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> controller;<br>&#125;<br><br>- (FBKVOController *)KVOControllerNonRetaining<br>&#123;<br>  <span class="hljs-keyword">id</span> controller = objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSObjectKVOControllerNonRetainingKey</span>);<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == controller) &#123;<br>    controller = [[FBKVOController alloc] initWithObserver:<span class="hljs-keyword">self</span> retainObserved:<span class="hljs-literal">NO</span>];<br>    <span class="hljs-keyword">self</span>.KVOControllerNonRetaining = controller;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> controller;<br>&#125;<br></code></pre></td></tr></table></figure><p>他们的区别就是被观察者的内存管理机制是strong还是weak，前者是strong，后者是weak。</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学的回忆与总结</title>
    <link href="/2020/06/25/%E5%A4%A7%E5%AD%A6%E7%9A%84%E5%9B%9E%E5%BF%86%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/25/%E5%A4%A7%E5%AD%A6%E7%9A%84%E5%9B%9E%E5%BF%86%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>前几天发现学信网上的学籍状态变更为已毕业，想着之前规划好的毕业回忆与总结也必须趁着端午节动手了。原计划是拿了双证之后再动手填这个坑，但没想到是尽管我人身在北京，竟然连学校都没办法去，双证也不知何时才能到手。</p><p>我坐在电脑前仔细回想这四年，发现这四年并如平常文章所说的快的一转眼就过去。对我来说，大学的四年不仅十分漫长与曲折，还夹杂一些痛苦。现在回头想想，高中简直是我最快乐的时光，只需要一心一意学习就行，而我甚至还没有全身心的投入到学习中。</p><p>高中毕业的时候，我就认定了我要去学习计算机专业，而且认定必须去大城市学。可惜的是我分不太够，只能在北京选了一个普通的高校。我的不少同学都认为这所高校十分坑人，因为它收的分同比较高但学校硬件又非常次。我在考虑志愿的时候就已经仔细了解了这所学校的条件，但我还是决定要来，因为想要在分不够的前提下去大城市学习计算机专业，那真是没得选。虽然亲自来了之后还是被学校硬件条件的糟糕而震撼，比如周六无法洗澡、宿舍竟然还没有我以前的卧室大。但是不管怎么样都是我自己选的，也没什么好抱怨的。</p><p>由于一些说来话长的原因，我在刚进大学后就认为自己应该尽早独立强大起来，因此我也不想错过任何机会。当时在贴吧上知道了我校两个实力强大的技术社团，一个是与机器人相关的社团（我忘了名字）另一个是ifLab。前者在主校区而且面试的时间被放到很后，我就放弃面试了。后者就在我们健翔桥校区，我就去参加了它的面试。还记得当时接到面试通知的时候发现一个特别有趣的事情，就是它有面试题。我还记得当年的面试题是写简单的网页，多亏了高中毕业时学的Python，我就花了3小时简单的学习就搞定了这道面试题。在面试的时候我不仅展示了面试题也展示了我自学的Python相关的内容。最后结果非常符合预期，那就是我成功加入了ifLab。我在加入ifLab之前填写的志愿是去Android组，不过不知为何我却被分到了iOS组。想想这都是命呀，iOS APP的开发之后变成了我的工作内容。也正是因为进了iOS组吧，我就买了一台MacBook Air。当时带我的是hubo学长，在他的带领下我学习了一些新鲜的事情，开始接触Linux。写到这里突然想起来我接触Linux的过程实在有趣。我们学校是没法个人拉网线搞Wi-Fi而且限制使用设备只有两台，这让我十分的恼火。有一天偶然间从hubo学长口中得知可以用路由器连接学校网，我就兴奋的买了两台廉价路由器开始了我的折腾之旅。想想也真是好笑，我的大一上学期除了写写C语言，基本就在折腾这两台路由器，最后竟然还是没有成功。到了大一下学期我就放弃折腾它们了，因为我实在是没有成功过，没办法从中获得快感也就失去了兴趣。</p><p>在大一的时候我想明白了许多事情，比如说学校中的很多事情毫无意义，要做有收益的能够让自己成长的事情。后来我在字节跳动学到了一个词就是ROI（投资回报率），用在大学生活中非常合适，不做需要投资时间但却没有回报的事情。另外大一对我来说算是个好的开始，由于不断的刷题以及一些之前学Python的基础，我的C语言拿了100分，也算是对得起自己的努力吧。到了大一下以后我的兴趣就转移了，C语言的学习成果让我决定尝试一些进阶的事情，比如说游戏开发。</p><p>那时我兴致勃勃的下载了虚幻4引擎，买了一大堆关于虚幻4开发的电子书。但很快我对它就失去了兴趣，因为我发现游戏开发不仅需要代码能力，还需要许多模型，而我对建模并不感兴趣。因此我在练手时只能用商城里的模型，而绝大多数模型又是要付费的，这对我来说真是个极大的劝退。在对游戏开发失去兴趣之后我决定好好把这学期的C++学好，再考一个100分。不过很可惜的是最后机考时错了两道选择题才考了96。</p><p>在这一年中我很少去ifLab的实验室，因为我觉得躺在宿舍里敲代码非常的舒服。我一直有一种迷之自信认为我能够在嘈杂的环境中专心学习，有趣的是我发现这竟然是事实。但是在宿舍躺着写代码会让腰很酸，这一年后我感觉自己已经撑不住了，所以我在大一的暑假就决定去ifLab实验室学习。在这个暑假我也做了一个影响我人生的决定，那就是开始学习iOS开发。兜兜转转一年，我突然想起我还有一台MacBook Air，我觉得既然花了钱就不要浪费，试着自学一下iOS开发吧。就是没想到呀，这一学就上瘾了。一开始我是学习swift的，但是网上关于swift的资料实在是太少了，我在花了一周摸索之后就决定放弃学习swift转向OC。当时觉得写OC特别有意思，按照高学长所说的，它的每一行代码都用中括号扩起来，就宛如对话一般优雅。这种认知甚至我在学会OC之后认为Java非常的繁琐和啰嗦。当然，当我彻底使用swift开发的时候，我才意识到OC和Java就是半斤八两，一样很啰嗦，只不过前者晦涩难懂，后者长得一副大家都会写的样子。</p><p>后来到了大二了，我就开始经常去ifLab实验室了。这段时间认识了不少人，也得到了不少练手的机会。最开始认识的是付佬、pj和高学长。关于付佬，我最想不通的事情就是为什么他天天都在打游戏最后却保送去了清华，这可能就是大佬吧。pj呢，他这个时候正在走一个自己开的深坑，那就是翘课去实习。很庆幸认识他，让我后来翘课去实习几乎没走弯路。当时pj刚刚结束完一段实习，所以我经常能在实验室看到他。由于他是学习iOS开发的学长，我在平时练手的时候有很多不会的地方就可以直接问他。大家应该会有一种体验，就是刚入门时很多编程的坑是在搜索引擎中很难搜索到的，如果这个时候有人指点一下就可以很快明白。学了一段时间之后呢，他安排了我和xzk一起重新开发iBistu，这是个很有趣的事情，因为这是我参与的第一款上架APP。我在这段开发中也学会了很多技能，包括terminal、git和SourceTree的使用，对Xcode和Mac的使用也更加熟练了。现在我和pj还有xzk都在西瓜开发iOS，真是没想到大家最后竟然成为了同事。</p><p>同时在大二上学期呢，高学长给我安排了一些事情做，是一些计算机博弈相关的事情。那时我思想上还太年轻，也不愿意放弃任何机会，只要交给我的我都大包大揽。当时我评上了一个国家级大创项目，是在iOS上开发一个苏拉卡尔塔棋的APP，并打算用一些机器学习相关的知识。这真是个深坑，如果说当时我的能力是1，那么这个项目的难度就是我能力的两倍。接了这个事情之后呢，我不仅要开发iBistu，也要开发棋，我只能开始并行做事。往常下课的时间用来写代码已经完全不够用，我开始占用上课的时间写代码。这段时间真是相当的充实，我能感觉到iBistu和棋的开发让我成长的非常迅速。</p><p>不过，开心的时间总是特别少，留给我安心成长的时间也很短暂。正如我大一所担心的那样，由于一些说来话长的原因，我在大二下学期失去了生活费。我是一个有骨气的男人，定下了一个不再向家里要钱的决心。我准备试一试让自己独立起来，看看自己到底有几斤几两。在此之后，我的生活一下就转变了，因为我意识到一个残酷的现实，学习可以暂缓和休息，但是如果不工作，我甚至没法活下去。也就是这个时候，我的人生方向一下从学习转变为活下去。当时我认为虽然是要去工作，但是也要做能够让自己成长的事情。对于当时沉迷于iOS开发的我来说，去应聘iOS开发实习生肯定是个好选择。再和pj聊了一段时间之后，我终于下定决心翘课去实习。说实话这么多年来大学期间我才第一次翘课，刚开始翘课时我心里还是有很多不安，后来随着翘课次数的变多我也慢慢变得毫无感觉。</p><p>当时我就对我的大学职业生涯进行了一次三级跳的规划，那就是第一次实习去小公司，第二次实习去大公司，第三次实习去BAT。于是我开始执行我的第一个规划，我在Boss直聘上投递了不少小公司，最后拿了两个offer。当时面试时我的计算机基础知识十分匮乏，老板让我写一个冒泡排序，我都写成了选择排序。最后我选择了一家做女性直播交友的公司，也就是Lespark。写到这想起来真是十分感谢pj和高学长，这两个offer就是靠着iBistu和苏拉卡尔塔棋APP拿下来的。</p><p>在实习之外呢，我也在晚上下班后和周末的时间做一些写网站的外包工作，于是我开始并行做四件事情。那时我还不懂ROI，但是我能意识到我不能把时间分配给收益较低的事情，于是苏拉卡尔塔棋的开发就几乎被我放弃了，因为我已经在它上获得了足够的收益。我现在回想起来，我大二下的这段时间已经不能用压力山大来形容了，我觉得当时我已经被压到就剩一口气了。我根本没有除了睡觉以外任何的休息时间，早晨7点15起床准备去从学校赶去西二旗上班，晚上7点下班准时走人回学校。到8点回到学校后快速的洗个澡就开始外包的开发到11点回宿舍休息。在工作日更专注于实习，而休息日就进行全天的外包开发。大家都知道学一门新的东西是很痛苦的，我在接下外包的时候甚至连网站的前后端都不知如何系统的进行开发。现在想想这可能就是社会的毒打吧，还好我是一个很硬的弹簧，即使压力山大我也还能扛住。这段时间我也第一次发现自己竟然营养不良，因为我长出了棕黄的头发，这在我身上是从未发生过的事情。4个月后这段实习协议到期了，我选择结束它不再续约，因为我真得非常疲惫，我认为我需要休息一段时间。这4个月的时间让我发现赚钱如此的辛苦，我每天早上7点15起床，晚上7点下班竟然一个月到手还不到4k，到这个时候我才能感受到以前我说的某些话是多么好笑。</p><p>休息了两周，我意识到我只有不断的去实习才能维持我的日常开销，因此我开始我的第二段职业规划。很庆幸的是，我的第二段经历非常的顺利，面试的第一个公司是网易，当天就拿到了口头offer，于是我就这么被网易新闻收留了。只有真正进了大公司后才知道为什么要劝学生毕业后去大公司，因为大公司与创业公司相比真的很不一样。首先与创业公司相比，大公司的整体流程非常规范，我个人认为在学校所学的<code>软件工程</code>这门课远没有直接在大公司实战而了解的更深刻。其次是工程复杂度与代码质量更高，我在网易新闻的实习提高了我对iOS开发的认知也很有效的提升了我的代码质量。如果用造楼来形容开发工作，那么在创业公司你只能造平房，在大公司则可以在高楼大厦里造各种各样的房间，而且要造的非常严谨才行，这是很不一样的体验。最后是福利，免费的三餐和下午茶（虽然后来没了）。下午茶我经常能吃到水果真是感受到十分幸福，因为当时我在学校觉得水果太贵舍不得买来吃。</p><p>18年底到19年过年前在网易的这段时间里逐渐成长的更加强大了，同时也让身体适应了工作，即使身有压力也不会再觉得犹如山大。这期间我也有幸开始参与了CrazyE的开发并一直维护它到今年初，这是一个课表APP，我在它的开发上使用了许多在网易学来的新鲜知识，有效强化了我对iOS开发的认知。</p><p>19年过年后回来很快就是20届的春招了，我虽然不准备去别的公司实习但是也打算出去面一圈看看自己水平如何。当时抽空面了不少大公司，无一例外都是败在了算法和计算机基础上。那一个月对我的打击真是十分巨大，我意识到翘课给我带来的巨大后果，那就是计算机基础不扎实。但同时我又很庆幸，我能够及时开始学习计算机基础并开始刷题。留给我的时间不多，我也不能放弃实习，所以我不得不开始白天上班晚上和周末学习的生活。当时坐地铁来回的时间非常长，我就在地铁上学习计算机网络，看一些面试经验的帖子思考如果是我被问这个问题的话我要如何回答。晚上和休息日就在实验室刷leetcode，刷算法题其实真的挺痛苦的，我刚开始刷的时候甚至怀疑我是不是白学计算机了。之后看了一些算法相关的课程，才意识到算法题跟高中数学有着相似之处，它们的解法都是有套路的甚至不少都有模板，很多题把模板列好，把题目往里一塞就解好了。虽然刷题很痛苦，但是我也强迫自己去喜欢上刷题，让自己每天不刷两题就心里闷得慌。现在打开leetcode上发现其实我刷的也不多，也就263道题。但是我在刷完算法题后发现了我的代码质量和工作中实际的问题解决能力又有巨大的提升，不得不说刷算法是真的有用。接着我又回顾了操作系统和编译原理，编译原理真是个令人着迷的学科，当时我喜欢它到去学了一些llvm的知识并且用swift写出了一个基于llvm为后端的demo语言。后来我甚至想要写一门完整的语言作为毕业设计，但是随着不断的编写和学习，在我掌握了不少知识后我对此失去了兴趣，这门语言也就这么太监了。</p><p>这段时间倒是过的非常快，很快就到了7月份的秋招提前批，我开始实施我的第三个规划了。我的秋招第一次面试就是字节跳动，我在这家公司的面试已经fail了好几次了，而且7月初的我也并不是准备的特别好。不过很幸运的是，我还是顺利拿到了offer。但是我在二面的时候竟然说不出哈希的原理，这让我十分恼火，自己的水平真是太菜了。但是我并没有因为拿到offer而停止学习，而是把在计算机基础和算法上的学习重心重新倾向到了iOS上。这段时间我也在网易新闻做iOS 13和dark mode的适配，遇到了许多奇奇怪怪的问题，也因此而成长。于是到8月底的时候我终于感觉到自己遇到了某种瓶颈，我个人觉得我的水平达到一个阶段的顶点应该是在这个时候。另外，这段时间内我还陆续也在面腾讯和阿里，但是这两个公司实在是太能拖了，拖到我都要去字节实习了还没面完，而且一个要去深圳一个要去杭州，最后想想就算了，于是我就开始在面试上放飞自我了。</p><p>迫于大四上的实习课程，我不得不在9月份立马去字节实习。因此也有个比较可惜的事，就是网易新闻的iOS 13以及dark mode的适配没能在我手上完整做完。刚来到西瓜视频以后也就马上开始参与bug的修复和iOS 13的适配。不得不说，字节跳动培养新人的机制确实没有网易来的完善。在网易的时候，需求都是leader和同事们统一开完需求评审会后分配，后续 有项管处理杂事，也有统一的站会来抛出问题，最后需求统一上车发版本。而在字节跳动，每个需求都需要自己跟进，靠自己完整的跑完整个流程，遇到问题也需要自己来推进，需求跟上哪个版本就上哪个版本，非常的敏捷开发。几个需求后我就开始自己一人跑整个开发流程，还记得第一次一个人去一个评审会连da说的埋点含义都不知道，导致了错误的开发，最后重写了一部分的代码。而且字节跳动的开发工具链体系特别庞大，技术栈特别丰富，刚进来的那段时间感觉真是有点自闭。不过说实话，在这种环境下能够适应的话，人的成长真的非常快。每个双月之后我都能发现自己明显比之前厉害不少，许多之前认为是面试造火箭的知识，没想到都逐渐在工作中用到。我有很多之前面试时不是特别理解的技术知识点，都因为要解决实际问题而逐渐理解。</p><p>也是因为去了字节跳动吧，终于有足够的收入能够搬出去住了，我期待这件事真是很久了。因为我的睡眠特别的浅，舍友一旦打呼噜我一晚就凉了，各种助眠方法都试过了，可惜就是没啥用。吐槽一下北京租房是真的黑，一间8平米的房间竟然就要3k6，不过也算是提高了非常的多的幸福感。毕竟之前上下班来回要2个半小时，还要担心偶尔没得洗澡和呼噜声，现在不仅睡的香而且只要骑车10分钟就能到公司了。从大四开始我的心情就非常愉悦，感觉自己的生活正式的走在了马路上了而不是在小勾勾里艰难前行。19年底我喜欢上了一门有趣的运动，那就是射箭，不得不说，射中黄心的感觉如同投篮空心命中一般让人心里舒爽。在这段疫情过去之后，等我能练习到开26磅的弓时，就是时候买一把属于自己的弓了。</p><p>20年到现在为止一切都还算顺利，心路历程不曲折，不仅兑现了带女友去泰国度假的承诺，还搬到了一个一居室里，感觉自己的生活质量再次提高，就是钱包有点空。唯一让人有些沮丧的就是因为北京的疫情，我没法执行我规划已久的毕业旅行了。现在毕业了，突然感觉到周末没有往日的繁忙有些无法适应，不知道应该做些什么。昨天努力思考了一下，觉得我应该开一个新坑，再开发一款教育类型的APP，就这么决定了吧。</p><p>在大学中，不仅要学会自学，也要学会独立思考，但是在大学中基本上没有人会告诉你要这么做。我的运气算好，我一直以来都习惯于自学，没想到在大学中却成了非常良好的技能。另一件运气好的事就是加入了ifLab，我实在难以想象如果我的大学没有加入这个社团会多么曲折。回忆起BISTU，我觉得能让我开心的也只有在ifLab实验室里写代码和讨论的时光。还记得ifLab创立的初衷有一条就是让社团成员毕业时具有一年工作经验的水平，我觉得我可以勉强厚着脸皮说自己达到了。</p><p>我的大学总的来说算是一段很曲折的故事，尤其是在大三的时候由于学业和实习冲突，导致我非常期待早日毕业，因为呆在学校已经无法让我成长了甚至会拖累我。我意识到，学校的许多课程是毫无用处的，自己才会知道做什么事情对自己的成长帮助最大。一些老师觉得学生应该按照自己的规划来在新手村慢慢练级，殊不知像我这样的学生早就已经走出新手村开始自由探索。至于考不考研这些问题，这是完全依赖于自己的背景以及自己的思考，并不是老师说考研好就去考研。我很早就明白，大学是一个需要长期奋斗和自我思考的地方，跟着老师的节奏走不一定好也不一定不好。我希望读这篇文章的学弟学妹们都能独立思考，清醒的、客观的意识到自己到底需要什么，这种思考需要抛开老师和家人的说辞，只有这样思考后得出的结论才是你所需要的。后来我思考了很多，我觉得大学教育对于我这样的学生应该学会放手，因为我知道什么时候做什么事情，也有很强的自我驱动能力。当然还是感谢大部分老师对我的放手，能够信任我并给我机会，让我能够顺利完成学业。写到这里还是需要再次感谢pj，因为他告诉我了各种学业上的坑，我才能达到没有挂科的完成学业，同时也很感谢各位在期末考前帮助我复习的同学们。</p><p>我的人生在下个月即将开启新的篇章，写下这篇文章也是为了回忆和反思这四年所发生的事情。前路漫漫，人生曲长，希望我正式走出象牙塔后的日子里也能较为顺利。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大二至大三实习一年，你想知道的这里都有</title>
    <link href="/2020/06/25/%E5%A4%A7%E4%BA%8C%E8%87%B3%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0%E4%B8%80%E5%B9%B4%EF%BC%8C%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%99%E9%87%8C%E9%83%BD%E6%9C%89/"/>
    <url>/2020/06/25/%E5%A4%A7%E4%BA%8C%E8%87%B3%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0%E4%B8%80%E5%B9%B4%EF%BC%8C%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%99%E9%87%8C%E9%83%BD%E6%9C%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我还很清晰的记得2018年4月25日是我第一天实习，在这步入社会的一年里，我的心态发生了很大的变化。说是一年，其实也并不是完整的一年，我在18年9月份的时候休息了整整一个月，当然也顺便利用这段时间去面试拿到了下一个offer。因为第一次实习发现工作真的是太累了，能理解到长辈赚钱真的很不容易，我自己也体会到当码农的感觉。写代码是我的一个爱好，尤其是写iOS。但是当爱好转化为我的工作进行输出时，我在工作的时间内就不会觉得那会让我愉悦了，而会让我很疲惫。</p><p>一年来不断有学弟学妹问我怎么做到大二出去实习的，ta想向我学习该怎么做。鉴于总是有人问，我觉得这个事情可以记录下来作为我的一个生活和反思相关的blog吧。</p><p>重要的话先写到最前面，经过一年的实习，我本人认为尽可能<strong>避免大二出去实习</strong>。</p><h1 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h1><p>在你想要了解我是如何做到大二出去实习的之前，你应该仔细思考一下自己究竟想要什么，这个是十分重要的。如果你要考研，那么这条路对你来说非常不合适。如果你要毕业就工作，那么这条路对你来说<strong>也许</strong>会合适。</p><h1 id="如何大二出去实习"><a href="#如何大二出去实习" class="headerlink" title="如何大二出去实习"></a>如何大二出去实习</h1><h2 id="保证你的学习成绩"><a href="#保证你的学习成绩" class="headerlink" title="保证你的学习成绩"></a>保证你的学习成绩</h2><p>最重要也是最关键的一点，你得保证你不能挂科。因为你一旦挂科就意味着你接下来的学期就会有更多的事情积压在你的身上，你的包袱就会越来越大直到压着你喘不过气，当然如果你抗压能力足够强大，即使有包袱也没啥对吧。看到这里一定会有同学好奇了，那去外面实习都不上课，怎么能不挂科呢？这个说起来真是个技术活。</p><p>那么翘课最重要的技能是什么呢？是学会沟通。在我看来沟通技能是十分重要的，尽管你以后有可能是个程序员，但是作为软件工程师，沟通这个技能非常重要。首先你需要让老师意识到你是个能力足够的孩子，你考试能过，实验也ok，技术也ok。如何证明你技术ok呢？你可以拿到offer以后再去跟老师商量。你需要让老师知道你是本科毕业就工作的，不会考虑考研。其次，既然你想要出去实习，那分数肯定不会那么好看，世界上没有这么好的事情。那么平时分能跟老师争取到及格最好，不行的话那就看自己考试和实验成绩咯。这一年来我有N门课的平时分不及格，但我一样能过。提醒一下，与老师沟通的时候态度很重要，你要上去说话就冲，一副自己最牛逼的样子，那肯定不会让你出去的。最后，有些老师就是不放你出去怎么办呢？我的答案就是没办法，老老实实上课呗。其实也有办法，那就看你人际交往关系如何了XD。</p><h2 id="足够的技术能力"><a href="#足够的技术能力" class="headerlink" title="足够的技术能力"></a>足够的技术能力</h2><p>这个也一样是必须满足的条件，如果你满足不了这个条件，我相信你连offer都拿不到。那么如何保证大二的自己拥有足够的技术能力呢？不说别的，我校大一上那C语言那么简单，不考个满分说不过去吧？大一下那C++/Java也很简单，不说满分，也得考个90+吧。说这些什么意思就是要在大一打好编程基础。出去实习是很硬核的，人家公司就是要招个实习生过来写业务的，不是白养你的，尤其是创业公司，所以一定会对你的技术有要求。</p><p>在大一打好基础是远远不够的，为什么不够呢，因为你还没有一个有一定深度了解的方向。可以是前端、后端或者是客户端，像我就是一直在写iOS，所以一定要有一个自己专研过的方向。但是你自己的专研不够呀，你没有经验啊，怎么办呢？我认为最好的解决方案就是不要放过学长学姐提供的机会。其实很多学长学姐都有非常好的能够让你实践的机会，要么是你没发现，要么是你懒，<strong>机会都是自己把握的</strong>。不断的把握机会就会让别人觉得你靠谱，下一次还有这种机会也会继续找你。当你让你身边的人意识到你靠谱的时候，有些事情你就要看情况接手了，因为这个时候可能你已经非常忙了。我有一段时间很懊悔自己抓住了太多事情而让自己忙到没有休息的时间，我目前最高记录是并行处理4件事吧，那几个月忙到没工夫花钱，花呗一个月花了7块hhh。</p><p>抓住了不少机会后，我相信你在我校的同级学生中已经拥有一份还可以的简历了，这个时候你可能还是不具备拿到offer的条件。为什么呢？因为你没有面试经验。我认为最好的解决办法就是直接去面试。App Store打开找到几个实习找工作的App一顿下载，比如实习僧、Boss直聘和拉钩之类的，然后打开App一顿猛投，接着就等HR给你打电话吧。具体的面试踩坑细节就不展开了，说一些一开始需要注意的吧。我还记得我的第一份工作的Boss上来问我的第一句是：“哦，大四了吧”，我说：“我才大二”。我能明显的看到Boss身体一震，一脸惊讶。Boss问我是否有时间，这个时候我就是把我的真实情况告诉他，但是我强调了我是可以调出足够的时间实习的。</p><p>至于如何找到一家靠谱的实习公司这里也不展开说了，但是有一点很重要，你要是实习没工资，那绝对不靠谱。</p><h2 id="保证你自己的时间"><a href="#保证你自己的时间" class="headerlink" title="保证你自己的时间"></a>保证你自己的时间</h2><p>这一条不是必须的，但是我觉得对我来说是必须的。因为拥有自己的时间才能继续提高自己，大二出去实习所拥有的技术水平和真正毕业所面对的校招要求的技术水平还是有很大差距的。也正是因为如此，大二出去实习就会异常的忙碌，你还需要抽出时间来学习和提高自己。我刚上班的那一两个月，每天下班回来就想休息或者打游戏，其他啥也不想干了，因为很累。但是一段时间后我就觉得这样是不行的，我开始下班回来接着做自己的事情或者学习和提高自己。之所以能做到这样是因为一方面我逐渐适应了这样的生活，除了发版前之外并不会感到特别疲惫了，另一方面是我足够自律。所以为了前程考虑，大二出去实习还得足够的自律。</p><h1 id="为何需要大二出去实习"><a href="#为何需要大二出去实习" class="headerlink" title="为何需要大二出去实习"></a>为何需要大二出去实习</h1><p>我想说道这个事情，可能就会有很多人想到要尽快提升自己的能力balabala。这个说的没错，不管自己在学校搞什么项目，终究是学习主导的，并没有经过企业级历练，是不完善的。经过企业开发实战，无论从技术还是从眼界来看，都会有较大提升。</p><p>不过我个人认为还是有其他必要原因的，比如说现在互联网就业环境不好以及门槛较高，身在象牙塔中的学生可能并未意识到这件事情。尤其我校并不是名校，起点可以算是非常低了，为了校招能得到大厂的面试机会，一份丰富的简历是很有必要的，而一份丰富的简历所必要的就是实习经验。这里有一点要强调一下，能被面试，说明你已经过了简历筛选，意味着之后的流程与你在哪个学校无关，<strong>也意味着之后的流程需要靠你的真本事</strong>。</p><p>至于我个人必须大二出去实习的原因则是我大二下的时候没有生活费了XD，为了活下去我只好出去实习咯hhh。</p><h1 id="为什么我不建议大二出去实习"><a href="#为什么我不建议大二出去实习" class="headerlink" title="为什么我不建议大二出去实习"></a>为什么我不建议大二出去实习</h1><p>上面说了这么多如何做，来讲讲为什么我在前言里说不建议大二出去实习。我是没有生活费没办法，但是读这篇文章的你不一定。</p><h2 id="占用你的大量时间"><a href="#占用你的大量时间" class="headerlink" title="占用你的大量时间"></a>占用你的大量时间</h2><p>北京的计算机相关工作都集中在西二旗、知春路、中关村、马连洼、上地和望京，你可以计算一下你的路程花费的时间，然后再加上965的工作时间，看看总共多少时间。大学的时候要花大量的时间来打基础，我一开始就觉得深入掌握一门技术即可，但结果就是我现在在回头补计算机网络、操作系统以及算法。很多公司面试的时候并不care你在这个方向上有多少深度，在他们看来，3年以内的工作经验跟应届都差不多。他们往往在乎你基础是否扎实，是否能手写算法，因为这些才是计算机体系中几乎不变的，而就业方向与其所需技能是容易变的。下面是我某一周的时间安排。</p><p><img src="https://cdn.qyizhong.cn/8216167-50ecaed6844986bd.jpg" alt="我一周的时间安排"></p><h2 id="压力太大"><a href="#压力太大" class="headerlink" title="压力太大"></a>压力太大</h2><p>我校大四之前是不允许实习的，也就是说一旦出去就要面对学校的学习压力以及工作压力。学习压力还是小事，因为我校的考试确实不会很难。但是工作压力是个大事，我们在自己做项目的时候buffer是很充足的，有的时候真不想写了可以缓一缓明天再写，可是工作中就不能这样了，做不完你可走不了。讲道理是下班时间到了你就可以走，可要是项目进度卡在你这里你敢走吗？我一年来坚信着不能让事情卡在我这里的道理，但是我又想早点回去，所以很多时候我都会牺牲中午的休息时间。当然目前我在网易的工作会轻松一些，一方面是自己的技能越来越熟练了，另一方面是自己接手的需求都会自己预估工期，会给自己预留buffer。</p><p>看到这里吧，我相信有些人会觉得压力大没关系，我也行。我这里只提醒一下，一旦选择这条路，你就马上要并行处理两条线的事情，分别是工作与学校的事情。在学校的时候觉得学校的事情没什么，但你工作的时候突然有个学校的事情就不会让你心情舒服了。接着你还要提升自己的实力，于是你又多开了一个线程用来学习和提升自己的能力，所以在我看来，最终的你至少并行在做三件事。不过我认为这是自己的选择，但是在选择之前还是思考一下<strong>自己到底要什么</strong>。</p><p>当然，我不推荐的是大二的日常实习，如果有暑期实习的机会，这个机会一定不要放过。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>一年的实习经验让我经历了不少有趣的事情，也让我见识到了市场的残酷，而我逐渐的意识到自己只是个普通人。如果问我是否后悔，我不会后悔，因为这是我当时最好的选择。曾经有人问我“你以后还有几十年要工作，为什么那么着急？”。当时我只觉得不着急就会被淘汰，现在反思后却觉得在大二这个时间点，我努力的方向却不是那么对。</p><p>最后的最后，用一句话总结我一年来最大也是最多的体会：“小时候真傻，竟然期望长大”。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DispatchGroup出现EXC_BAD_INSTRUCTION问题</title>
    <link href="/2020/06/25/DispatchGroup%E5%87%BA%E7%8E%B0EXC-BAD-INSTRUCTION%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/25/DispatchGroup%E5%87%BA%E7%8E%B0EXC-BAD-INSTRUCTION%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看app的线上奔溃总是出现意义不明的崩溃问题，而且崩溃栈出现在闭包的回调里，并且bugly上提示说是有可能在swift解包的时候出现问题，也就是对nil使用了!。这就完全误导了我，把我对问题的理解定义为数据保护的不够到位。结果就是在多次发版后这个问题还未得到解决，所以我绝对对这个问题一探究竟。</p><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><p>其实出现这个问题的原因很简单，那就是group的enter和leave没有成对出现。比如说我们会在闭包的回调里去leave，但是闭包有可能返回多次，一旦多leave了，那么就会出现<strong>EXC_BAD_INSTRUCTION</strong>这个问题。</p><p>举个例子</p><p>我们声明如下两个方法，可以看出来work2回调了两次</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work1</span><span class="hljs-params">(closure: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;<br>    sleep(<span class="hljs-number">1</span>)<br>    closure()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work2</span><span class="hljs-params">(closure: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;<br>    closure()<br>    sleep(<span class="hljs-number">2</span>)<br>    closure()<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们使用它们</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.viewDidLoad()<br>    <br>    <span class="hljs-keyword">let</span> group <span class="hljs-operator">=</span> <span class="hljs-type">DispatchGroup</span>()<br>    <span class="hljs-keyword">let</span> queue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;test&quot;</span>, qos: .background, attributes: .concurrent, autoreleaseFrequency: .inherit, target: <span class="hljs-literal">nil</span>)<br>    <br>    group.enter()<br>    queue.async &#123;<br>        <span class="hljs-keyword">self</span>.work1 &#123;<br>            group.leave()<br>        &#125;<br>    &#125;<br>    <br>    group.enter()<br>    queue.async &#123;<br>        <span class="hljs-keyword">self</span>.work2 &#123;<br>            group.leave()<br>        &#125;<br>    &#125;<br>    <br>    group.notify(queue: queue) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;同步完成&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看出来在work2的闭包的leave就会出现这个问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>其实这种问题完全使我们编写代码的过程中不够细心导致的，通过完善的测试用例完全可以避免问题发生，但是我们还是需要记住一句话<strong>DispatchGroup的enter和leave必须成对出现!!!</strong></p>]]></content>
    
    
    <categories>
      
      <category>Crash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UITableView和UICollectionView实现自定义滚动动画</title>
    <link href="/2020/06/25/UITableView%E5%92%8CUICollectionView%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB/"/>
    <url>/2020/06/25/UITableView%E5%92%8CUICollectionView%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到这个标题你可能会觉得“这不是很简单吗？像下面这么一写就完了呗”</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">UIView</span><span class="hljs-selector-class">.animate</span>(<span class="hljs-attribute">withDuration</span>: <span class="hljs-number">0.25</span>) &#123;<br>    <span class="hljs-selector-tag">self</span><span class="hljs-selector-class">.tableView</span><span class="hljs-selector-class">.setContentOffset</span>(CGPoint(<span class="hljs-attribute">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">y</span>: <span class="hljs-number">500</span>), <span class="hljs-attribute">animated</span>: false)<br>&#125;<br></code></pre></td></tr></table></figure><p>不不不，如果你觉得就这么简单的话说明你还是太年轻了。这样写你的列表在滚动的一开始上面的cell就消失了，这种效果是完全过不了产品和视觉小姐姐的像素眼。</p><p>为了实现自定义滚动动效我们可以使用CADisplayLink来实现，至于为什么不用其他timer相信大家可以自己百度了解。</p><p>当然如果你并不想那么麻烦的自己写的话可以使用Facebook出品的Pop动画库，它也是基于CADisplayLink实现的。由于UIScrollView的滚动原理，我们可以用<code>POPBasicAnimation</code>设置UIScrollView的<code>bounds</code>属性动画即可。</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://github.com/qyz777/scroll_animation">自定义列表滚动动效</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h2><p>首先我们先实现实际动画的类<code>ScrollViewAnimator</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollViewAnimator</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> scrollView: <span class="hljs-type">UIScrollView</span>?<br>    <span class="hljs-keyword">let</span> timingFunction: <span class="hljs-type">ScrollTimingFunction</span><br>    <br>    <span class="hljs-keyword">var</span> closure: (() -&gt; <span class="hljs-type">Void</span>)<span class="hljs-operator">?</span><br>    <br>    <span class="hljs-comment">//动画开始时间</span><br>    <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">TimeInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment">//动画初始的contentOffset</span><br>    <span class="hljs-keyword">var</span> startOffset: <span class="hljs-type">CGPoint</span> <span class="hljs-operator">=</span> .zero<br>    <span class="hljs-comment">//动画目标的contentOffset</span><br>    <span class="hljs-keyword">var</span> destinationOffset: <span class="hljs-type">CGPoint</span> <span class="hljs-operator">=</span> .zero<br>    <span class="hljs-comment">//动画时长</span><br>    <span class="hljs-keyword">var</span> duration: <span class="hljs-type">TimeInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment">//动画已运行时长</span><br>    <span class="hljs-keyword">var</span> runTime: <span class="hljs-type">TimeInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">var</span> timer: <span class="hljs-type">CADisplayLink</span>?<br>    <br>    <span class="hljs-keyword">init</span>(scrollView: <span class="hljs-type">UIScrollView</span>, timingFunction: <span class="hljs-type">ScrollTimingFunction</span>) &#123;<br>        <span class="hljs-keyword">self</span>.scrollView <span class="hljs-operator">=</span> scrollView<br>        <span class="hljs-keyword">self</span>.timingFunction <span class="hljs-operator">=</span> timingFunction<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setContentOffset</span><span class="hljs-params">(<span class="hljs-keyword">_</span> contentOffset: CGPoint, duration: TimeInterval)</span></span> &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scrollView <span class="hljs-operator">=</span> scrollView <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">//设置需要的属性</span><br>        startTime <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>().timeIntervalSince1970<br>        startOffset <span class="hljs-operator">=</span> scrollView.contentOffset<br>        destinationOffset <span class="hljs-operator">=</span> contentOffset<br>        <span class="hljs-keyword">self</span>.duration <span class="hljs-operator">=</span> duration<br>        runTime <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">self</span>.duration <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> &#123;<br>            scrollView.setContentOffset(contentOffset, animated: <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> timer <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;<br>            timer <span class="hljs-operator">=</span> <span class="hljs-type">CADisplayLink</span>(target: <span class="hljs-keyword">self</span>, selector: <span class="hljs-keyword">#selector</span>(animtedScroll))<br>            <span class="hljs-comment">//把timer加入到common的runloop中</span><br>            timer<span class="hljs-operator">?</span>.add(to: .main, forMode: .common)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animtedScroll</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> timer <span class="hljs-operator">=</span> timer <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scrollView <span class="hljs-operator">=</span> scrollView <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>        <span class="hljs-comment">//由于CADisplayLink每次回调的时间不固定，所以使用它自己记录的回调时间来增加运行时长</span><br>        runTime <span class="hljs-operator">+=</span> timer.duration<br>        <span class="hljs-keyword">if</span> runTime <span class="hljs-operator">&gt;=</span> duration &#123;<br>            <span class="hljs-comment">//如果运行时长超过动画时长说明动画需要结束了</span><br>            scrollView.setContentOffset(destinationOffset, animated: <span class="hljs-literal">false</span>)<br>            timer.invalidate()<br>            <span class="hljs-keyword">self</span>.timer <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>            closure<span class="hljs-operator">?</span>()<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">var</span> offset <span class="hljs-operator">=</span> scrollView.contentOffset<br>        offset.x <span class="hljs-operator">=</span> timingFunction.compute(<span class="hljs-type">CGFloat</span>(runTime), startOffset.x, destinationOffset.x <span class="hljs-operator">-</span> startOffset.x, <span class="hljs-type">CGFloat</span>(duration))<br>        offset.y <span class="hljs-operator">=</span> timingFunction.compute(<span class="hljs-type">CGFloat</span>(runTime), startOffset.y, destinationOffset.y <span class="hljs-operator">-</span> startOffset.y, <span class="hljs-type">CGFloat</span>(duration))<br>        scrollView.setContentOffset(offset, animated: <span class="hljs-literal">false</span>)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="UIScrollView拓展"><a href="#UIScrollView拓展" class="headerlink" title="UIScrollView拓展"></a>UIScrollView拓展</h2><p>我们用OC的runtime知识动态为分类添加属性方便使用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIScrollView</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AssociatedKeys</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> animator: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;animator&quot;</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> animator: <span class="hljs-type">ScrollViewAnimator</span>? &#123;<br>        <span class="hljs-keyword">set</span> &#123;<br>            objc_setAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-operator">&amp;</span><span class="hljs-type">AssociatedKeys</span>.animator, newValue, .<span class="hljs-type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)<br>        &#125;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-operator">&amp;</span><span class="hljs-type">AssociatedKeys</span>.animator) <span class="hljs-keyword">as?</span> <span class="hljs-type">ScrollViewAnimator</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setContentOffset</span><span class="hljs-params">(<span class="hljs-keyword">_</span> contentOffset: CGPoint, duration: TimeInterval, timingFunction: ScrollTimingFunction = .linear, completion: <span class="hljs-params">(<span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)<span class="hljs-operator">?</span> <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">if</span> animator <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;<br>            animator <span class="hljs-operator">=</span> <span class="hljs-type">ScrollViewAnimator</span>(scrollView: <span class="hljs-keyword">self</span>, timingFunction: timingFunction)<br>        &#125;<br>        animator<span class="hljs-operator">!</span>.closure <span class="hljs-operator">=</span> &#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> strongSelf <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>            <span class="hljs-type">DispatchQueue</span>.main.async &#123;<br>                strongSelf.animator <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>            &#125;<br>            completion<span class="hljs-operator">?</span>()<br>        &#125;<br>        animator<span class="hljs-operator">!</span>.setContentOffset(contentOffset, duration: duration)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ScrollTimingFunction枚举"><a href="#ScrollTimingFunction枚举" class="headerlink" title="ScrollTimingFunction枚举"></a>ScrollTimingFunction枚举</h2><p>动画缓冲函数的实现可以参考<a href="http://robertpenner.com/easing/">http://robertpenner.com/easing/</a>。具体实现例子在<a href="https://github.com/qyz777/scroll_animation">Demo</a>中</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://robertpenner.com/easing/">http://robertpenner.com/easing/</a><br><a href="https://blog.csdn.net/S_clifftop/article/details/89490422">https://blog.csdn.net/S_clifftop/article/details/89490422</a><br><a href="https://zsisme.gitbooks.io/ios-/content/index.html">https://zsisme.gitbooks.io/ios-/content/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
