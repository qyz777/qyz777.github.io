<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tensorflow Lite实战——在iOS上部署中文文本分类模型</title>
    <link href="/2020/06/27/Lite%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%9C%A8iOS%E4%B8%8A%E9%83%A8%E7%BD%B2%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/06/27/Lite%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%9C%A8iOS%E4%B8%8A%E9%83%A8%E7%BD%B2%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本文所使用的分类模型来自于<a href="[https://github.com/gaussic/text-classification-cnn-rnn](https://github.com/gaussic/text-classification-cnn-rnn)">CNN-RNN中文文本分类，基于TensorFlow</a></strong>，感谢开源。</p><p>最近一段时间需要用到中文文本分类这样一个功能，于是我马上想到了Create ML，但是经过自己的尝试以后发现Create ML并不支持中文的文本分类(不信可以自己试试)。</p><p>最近发现有道词典有离线翻译这样一个功能，我猜测这应该就是把模型下载到本地使用了，这么一看模型部署到移动端理论上是可行的。但各个深度学习框架我只了解过tensorflow，于是在有这样一个需求之下，我又回到了tensorflow这个大坑，去年年底说我这辈子都不会再用tensorflow了，没想到真香了。</p><p>实际上tensorflow所训练的模型是放在后端最合适，但由于我不想给APP维护一个健壮的后端，所以执着于把模型部署到移动端。这个是<a href="https://github.com/qyz777/tensorflow_lite_swift_demo" target="_blank" rel="noopener">Demo</a>。</p><p>言归正传，从头部署一个模型我可以归纳出几个步骤</p><ol><li>训练并测试模型，将模型保存为ckpt格式</li><li>将ckpt模型固化转成pb模型</li><li>通过TensorFlow Lite提供的方法将pb模型转换为tflite模型</li><li>使用cocoapods的方式引入TensorFlow Lite，并把模型导入工程</li><li>封装调用模型逻辑，进行文本分类</li></ol><p><strong>注意:</strong> 本篇博客仅根据上方的开源工程进行部署，其他的网络结构还需要具体问题具体分析。</p><h1 id="大致分类原理"><a href="#大致分类原理" class="headerlink" title="大致分类原理"></a>大致分类原理</h1><p>如果想要从头部署一遍，一定要对tensorflow有一定了解，因为不读懂工程的源码意思是基本上无法往下流程做的。</p><p>这个工程把每一个文本中的字符映射成一个个数字(id)，通过一系列玄学操作，得到一个一维数组，其中前10个就是我们要关注的值，因为标签只有10个。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>我们需要了解数据处理的方式即输入和输出，这样我们才能编写代码在iOS APP中进行预测。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>这个开源工程中会把每一个字符（汉字）映射成一个id，这个id来自于数据集中的行，意思就是第一行对应的字符id就是0，第二行对应的是1，以此类推。这样我们就获得了一个id的数组。并且这个id数组需要处理成一个固定长度，本文在iOS中处理方式为不足则数组后面添0，多余则移除数组末尾。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出的是一个数组，数量会超过10个，但因为数据集中的分类只有10个，所以我们只需要关注这个数组的前10个即可。这前10个数组对应的下标就是标签数组中的下标，数组的值就是预测的概率。所以输出的数组0-10的下标就对应了标签数组中0-10具体分类的可能性。</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>本文使用开源工程中的CNN网络，因为TensorFlow Lite支持的operators有限，所以不是所有的TensorFlow中的operators都支持，如果出现不支持的情况就会在转换中出现类似如下的错误:</p><div class="hljs"><pre><code class="hljs undefined">Some <span class="hljs-keyword">of</span> the operators <span class="hljs-keyword">in</span> the model are <span class="hljs-keyword">not</span> supported <span class="hljs-keyword">by</span> the standard TensorFlow Lite runtime. <span class="hljs-keyword">If</span> you have a <span class="hljs-keyword">custom</span> implementation <span class="hljs-keyword">for</span> them you can disable this <span class="hljs-keyword">error</span> <span class="hljs-keyword">with</span> --allow_custom_ops, <span class="hljs-keyword">or</span> <span class="hljs-keyword">by</span> setting allow_custom_ops=<span class="hljs-literal">True</span> <span class="hljs-keyword">when</span> calling tf.contrib.lite.toco_convert(). Here <span class="hljs-keyword">is</span> a list <span class="hljs-keyword">of</span> operators <span class="hljs-keyword">for</span> which  you will need <span class="hljs-keyword">custom</span> implementations: RandomUniform</code></pre></div><p>这里的错误中可以发现不支持的operator是RandomUniform。查找之后发现CNN中的<strong>tf.contrib.layers.dropout</strong>不受支持，但是这个问题不大，我们可以用L2正则化去替代它防止过拟合。</p><p>下面是修改后的参考代码:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCNNConfig</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-string">"""CNN配置参数"""</span>    embedding_dim = <span class="hljs-number">64</span>  <span class="hljs-comment"># 词向量维度</span>    seq_length = <span class="hljs-number">600</span>  <span class="hljs-comment"># 序列长度</span>    num_classes = <span class="hljs-number">10</span>  <span class="hljs-comment"># 类别数</span>    num_filters = <span class="hljs-number">256</span>  <span class="hljs-comment"># 卷积核数目</span>    kernel_size = <span class="hljs-number">5</span>  <span class="hljs-comment"># 卷积核尺寸</span>    vocab_size = <span class="hljs-number">5000</span>  <span class="hljs-comment"># 词汇表达小</span>    hidden_dim = <span class="hljs-number">128</span>  <span class="hljs-comment"># 全连接层神经元</span>    dropout_keep_prob = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># dropout保留比例</span>    learning_rate = <span class="hljs-number">1e-3</span>  <span class="hljs-comment"># 学习率</span>    batch_size = <span class="hljs-number">64</span>  <span class="hljs-comment"># 每批训练大小</span>    num_epochs = <span class="hljs-number">10</span>  <span class="hljs-comment"># 总迭代轮次</span>    print_per_batch = <span class="hljs-number">100</span>  <span class="hljs-comment"># 每多少轮输出一次结果</span>    save_per_batch = <span class="hljs-number">10</span>  <span class="hljs-comment"># 每多少轮存入tensorboard</span>    scale = <span class="hljs-number">0.01</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextCNN</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-string">"""文本分类，CNN模型"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, config)</span>:</span>        self.config = config        <span class="hljs-comment"># 三个待输入的数据</span>        self.input_x = tf.placeholder(tf.int32, [<span class="hljs-literal">None</span>, self.config.seq_length], name=<span class="hljs-string">'input_x'</span>)        self.input_y = tf.placeholder(tf.float32, [<span class="hljs-literal">None</span>, self.config.num_classes], name=<span class="hljs-string">'input_y'</span>)        self.keep_prob = tf.placeholder(tf.float32, name=<span class="hljs-string">'keep_prob'</span>)        self.cnn()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cnn</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""CNN模型"""</span>        my_dense_layer = partial(            tf.layers.dense, activation=tf.nn.relu,            <span class="hljs-comment"># 在这里传入了L2正则化函数，并在函数中传入正则化系数。</span>            kernel_regularizer=tf.contrib.layers.l2_regularizer(self.config.scale)        )        <span class="hljs-comment"># 词向量映射</span>        <span class="hljs-keyword">with</span> tf.device(<span class="hljs-string">'/cpu:0'</span>):            embedding = tf.get_variable(<span class="hljs-string">'embedding'</span>, [self.config.vocab_size, self.config.embedding_dim])            embedding_inputs = tf.nn.embedding_lookup(embedding, self.input_x)        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">"cnn"</span>):            <span class="hljs-comment"># CNN layer</span>            conv = tf.layers.conv1d(embedding_inputs, self.config.num_filters, self.config.kernel_size, name=<span class="hljs-string">'conv'</span>)            <span class="hljs-comment"># global max pooling layer</span>            gmp = tf.reduce_max(conv, reduction_indices=[<span class="hljs-number">1</span>], name=<span class="hljs-string">'gmp'</span>)        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">"score"</span>):            <span class="hljs-comment"># 全连接层</span>            fc = my_dense_layer(gmp, self.config.hidden_dim, name=<span class="hljs-string">'fc1'</span>)            <span class="hljs-comment"># fc = tf.layers.dense(gmp, self.config.hidden_dim, name='fc1')</span>            <span class="hljs-comment"># fc = tf.contrib.layers.dropout(fc, self.keep_prob)</span>            <span class="hljs-comment"># fc = tf.nn.relu(fc)</span>            <span class="hljs-comment"># 分类器</span>            self.logits = tf.layers.dense(fc, self.config.num_classes, name=<span class="hljs-string">'fc2'</span>)            self.y_pred_cls = tf.argmax(tf.nn.softmax(self.logits), <span class="hljs-number">1</span>)  <span class="hljs-comment"># 预测类别</span>        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">"optimize"</span>):            <span class="hljs-comment"># 损失函数，交叉熵</span>            cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=self.logits, labels=self.input_y)            reg_losses = tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES)            self.loss = tf.add_n([tf.reduce_mean(cross_entropy)] + reg_losses)            <span class="hljs-comment"># self.loss = tf.reduce_mean(cross_entropy)</span>            <span class="hljs-comment"># 优化器</span>            self.optim = tf.train.AdamOptimizer(learning_rate=self.config.learning_rate).minimize(self.loss)        <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">"accuracy"</span>):            <span class="hljs-comment"># 准确率</span>            correct_pred = tf.equal(tf.argmax(self.input_y, <span class="hljs-number">1</span>), self.y_pred_cls)            self.acc = tf.reduce_mean(tf.cast(correct_pred, tf.float32))</code></pre></div><p>接下来在run_cnn.py中经过训练就能获得如下ckpt模型了:<br><img src="https://cdn.qyizhong.cn/8216167-07fab3cb4052360a.png" srcset="/img/loading.gif" alt="ckpt模型"></p><h2 id="将ckpt模型固化转成pb模型"><a href="#将ckpt模型固化转成pb模型" class="headerlink" title="将ckpt模型固化转成pb模型"></a>将ckpt模型固化转成pb模型</h2><p>在固化模型这一个环节，你需要通读这个开源工程才行，不然你肯定不了解它的网络结构以及它的输入和输出。这也是对iOS开发者非常不友好的地方。</p><p>通过源码我们可以得知<strong>TextCNN</strong>这个类中的<strong>self.logits</strong>这个属性就是我们需要关注的输出，所以我们可以通过下面这段代码打印出tensor，然后找到我们需要的输出的name</p><div class="hljs"><pre><code class="hljs undefined">ops = sess.graph.get_operations()        <span class="hljs-keyword">for</span> <span class="hljs-built_in">op</span> <span class="hljs-keyword">in</span> ops:            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">op</span>)</code></pre></div><p>这里我们需要的name是</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">output_node_names</span> = <span class="hljs-string">"score/fc2/BiasAdd"</span></code></pre></div><p>参考源码:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">freeze_graph</span><span class="hljs-params">(input_checkpoint)</span>:</span>    <span class="hljs-string">"""    :param input_checkpoint:    :return:    """</span>    <span class="hljs-comment"># checkpoint = tf.train.get_checkpoint_state(model_folder) #检查目录下ckpt文件状态是否可用</span>    <span class="hljs-comment"># input_checkpoint = checkpoint.model_checkpoint_path #得ckpt文件路径</span>    <span class="hljs-comment"># 指定输出的节点名称,该节点名称必须是原模型中存在的节点</span>    output_node_names = <span class="hljs-string">"score/fc2/BiasAdd"</span>    saver = tf.train.import_meta_graph(input_checkpoint + <span class="hljs-string">'.meta'</span>, clear_devices=<span class="hljs-literal">True</span>)    <span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:        saver.restore(sess, input_checkpoint)  <span class="hljs-comment"># 恢复图并得到数据</span>        output_graph_def = tf.graph_util.convert_variables_to_constants(  <span class="hljs-comment"># 模型持久化，将变量值固定</span>            sess=sess,            input_graph_def=sess.graph_def,  <span class="hljs-comment"># 等于:sess.graph_def</span>            output_node_names=output_node_names.split(<span class="hljs-string">","</span>)        )  <span class="hljs-comment"># 如果有多个输出节点，以逗号隔开</span>        <span class="hljs-keyword">with</span> tf.gfile.GFile(output_graph, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment"># 保存模型</span>            f.write(output_graph_def.SerializeToString())  <span class="hljs-comment"># 序列化输出</span></code></pre></div><p>input_checkpoint为你的ckpt模型路径</p><h2 id="将pb模型转换为tflite模型"><a href="#将pb模型转换为tflite模型" class="headerlink" title="将pb模型转换为tflite模型"></a>将pb模型转换为tflite模型</h2><p>下面是<strong>from_frozen_graph</strong>方法的注解。这里我就要吐槽一下了，TensorFlow Lite的文档未免太敷衍了，说好的传入参数是一个[tensor]，结果老报错，在打断点调试了它们库的源码情况下发现竟然要求的是传入tensor的name？？？</p><p><img src="https://cdn.qyizhong.cn/8216167-8587e8f6b65ce590.png" srcset="/img/loading.gif" alt="from_frozen_graph方法注解"></p><p>这个只要没有出现operator不支持的情况就很简单，直接上源码就完了</p><div class="hljs"><pre><code class="hljs undefined">def convert_to_tflite():    <span class="hljs-attr">input_tensors</span> = [        <span class="hljs-string">"input_x"</span>    ]    <span class="hljs-attr">output_tensors</span> = [        <span class="hljs-string">"score/fc2/BiasAdd"</span>    ]    <span class="hljs-attr">converter</span> = tf.lite.TFLiteConverter.from_frozen_graph(        output_graph,        input_tensors,        output_tensors)    converter.<span class="hljs-attr">target_ops</span> = [tf.lite.OpsSet.TFLITE_BUILTINS,                            tf.lite.OpsSet.SELECT_TF_OPS]    <span class="hljs-attr">tflite_model</span> = converter.convert()    open(output_tflite_model, <span class="hljs-string">"wb"</span>).write(tflite_model)</code></pre></div><p>其中<strong>input_x</strong>是输入的name</p><h2 id="使用cocoapods的方式引入TensorFlow-Lite"><a href="#使用cocoapods的方式引入TensorFlow-Lite" class="headerlink" title="使用cocoapods的方式引入TensorFlow Lite"></a>使用cocoapods的方式引入TensorFlow Lite</h2><p>TensorFlow Lite有好几个库，原生的需要写C++，在一顿操作之下我放弃了，完全看不懂tensor的输入嘛。还有<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/experimental/objc" target="_blank" rel="noopener">OC封装</a>的以及<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/experimental/swift" target="_blank" rel="noopener">swift封装</a>的。因为我的工程是swift写的，所以我直接用swift的TensorFlow Lite库</p><p>按照他们的README</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">pod</span> <span class="hljs-string">'TensorFlowLiteSwift'</span></code></pre></div><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> TensorFlowLite</code></pre></div><p>就引入了，这一点就很友好了，比什么直接编译TensorFlow到iOS工程里那是简单的不能再简单了。</p><h2 id="封装调用模型逻辑，进行文本分类"><a href="#封装调用模型逻辑，进行文本分类" class="headerlink" title="封装调用模型逻辑，进行文本分类"></a>封装调用模型逻辑，进行文本分类</h2><p>在喂数据进行预测时我们也要按照开源工程里喂数据的方式进行一番操作。调用的逻辑我们可以参考<a href="(https://github.com/tensorflow/examples/blob/master/lite/examples/image_classification/ios/ImageClassification/ModelDataHandler/ModelDataHandler.swift)">官方Example</a></p><h3 id="导入模型"><a href="#导入模型" class="headerlink" title="导入模型"></a>导入模型</h3><p>我们需要导入模型、分类和字符id，这在本文的前言中提供的demo中有体现。</p><p><img src="https://cdn.qyizhong.cn/8216167-eae6ed14bcb96cba.png" srcset="/img/loading.gif" alt="必须导入的东西"></p><h3 id="初始化Interpreter"><a href="#初始化Interpreter" class="headerlink" title="初始化Interpreter"></a>初始化Interpreter</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() &#123;        <span class="hljs-keyword">let</span> options = <span class="hljs-type">InterpreterOptions</span>()        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">// Create the `Interpreter`.</span>            <span class="hljs-keyword">let</span> modelPath = <span class="hljs-type">Bundle</span>.<span class="hljs-keyword">init</span>(<span class="hljs-keyword">for</span>: <span class="hljs-type">TextClassifier</span>.<span class="hljs-keyword">self</span>).path(forResource: <span class="hljs-string">"model"</span>, ofType: <span class="hljs-string">"tflite"</span>)!            interpreter = <span class="hljs-keyword">try</span> <span class="hljs-type">Interpreter</span>(modelPath: modelPath, options: options)            <span class="hljs-comment">// Allocate memory for the model's input `Tensor`s.</span>            <span class="hljs-keyword">try</span> interpreter.allocateTensors()        &#125; <span class="hljs-keyword">catch</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Failed to create the interpreter with error: \(error.localizedDescription)"</span>)        &#125;    &#125;</code></pre></div><h3 id="加载标签、id以及将字符转换为id"><a href="#加载标签、id以及将字符转换为id" class="headerlink" title="加载标签、id以及将字符转换为id"></a>加载标签、id以及将字符转换为id</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadLabels</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path = <span class="hljs-type">Bundle</span>.<span class="hljs-keyword">init</span>(<span class="hljs-keyword">for</span>: <span class="hljs-type">TextClassifier</span>.<span class="hljs-keyword">self</span>).path(forResource: <span class="hljs-string">"labels"</span>, ofType: <span class="hljs-string">"txt"</span>) &#123;            <span class="hljs-keyword">let</span> fileManager = <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>            <span class="hljs-keyword">let</span> txtData = fileManager.contents(atPath: path)!            <span class="hljs-keyword">let</span> content = <span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(data: txtData, encoding: .utf8)            <span class="hljs-keyword">let</span> rowArray = content?.<span class="hljs-built_in">split</span>(separator: <span class="hljs-string">"\n"</span>) ?? []            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rowArray &#123;                labels.append(<span class="hljs-type">String</span>(row))            &#125;        &#125;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadTextId</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path = <span class="hljs-type">Bundle</span>.<span class="hljs-keyword">init</span>(<span class="hljs-keyword">for</span>: <span class="hljs-type">TextClassifier</span>.<span class="hljs-keyword">self</span>).path(forResource: <span class="hljs-string">"text_id"</span>, ofType: <span class="hljs-string">"txt"</span>) &#123;            <span class="hljs-keyword">let</span> fileManager = <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>            <span class="hljs-keyword">let</span> txtData = fileManager.contents(atPath: path)!            <span class="hljs-keyword">let</span> content = <span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(data: txtData, encoding: .utf8)            <span class="hljs-keyword">let</span> rowArray = content?.<span class="hljs-built_in">split</span>(separator: <span class="hljs-string">"\n"</span>) ?? []            <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rowArray &#123;                textIdInfo[<span class="hljs-type">String</span>(row)] = i                i += <span class="hljs-number">1</span>            &#125;        &#125;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transformTextToId</span><span class="hljs-params">(<span class="hljs-number">_</span> text: String)</span></span> -&gt; [<span class="hljs-type">Int</span>] &#123;        <span class="hljs-keyword">var</span> idArray: [<span class="hljs-type">Int</span>] = []        <span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> text &#123;            idArray.append(textIdInfo[<span class="hljs-type">String</span>(str)]!)        &#125;        <span class="hljs-comment">//根据python工程中的输入设置，超出截取前面，不足后面补0</span>        <span class="hljs-keyword">while</span> idArray.<span class="hljs-built_in">count</span> &lt; <span class="hljs-number">2400</span> &#123;            idArray.append(<span class="hljs-number">0</span>)        &#125;        <span class="hljs-keyword">while</span> idArray.<span class="hljs-built_in">count</span> &gt; <span class="hljs-number">2400</span> &#123;            idArray.removeLast()        &#125;        <span class="hljs-keyword">return</span> idArray    &#125;</code></pre></div><h3 id="进行预测"><a href="#进行预测" class="headerlink" title="进行预测"></a>进行预测</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runModel</span><span class="hljs-params">(with text: String, closure: @escaping<span class="hljs-params">(InferenceReslutClosure)</span></span></span>) &#123;        <span class="hljs-type">DispatchQueue</span>.global().async &#123;            <span class="hljs-keyword">let</span> idArray = <span class="hljs-keyword">self</span>.transformTextToId(text)            <span class="hljs-keyword">let</span> outputTensor: <span class="hljs-type">Tensor</span>            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-number">_</span> = <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.interpreter.input(at: <span class="hljs-number">0</span>)                <span class="hljs-keyword">let</span> idData = <span class="hljs-type">Data</span>.<span class="hljs-keyword">init</span>(bytes: idArray, <span class="hljs-built_in">count</span>: idArray.<span class="hljs-built_in">count</span>)                <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.interpreter.copy(idData, toInputAt: <span class="hljs-number">0</span>)                <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.interpreter.invoke()                outputTensor = <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.interpreter.output(at: <span class="hljs-number">0</span>)            &#125; <span class="hljs-keyword">catch</span> &#123;                <span class="hljs-built_in">print</span>(<span class="hljs-string">"An error occurred while entering data: \(error.localizedDescription)"</span>)                <span class="hljs-keyword">return</span>            &#125;            <span class="hljs-keyword">let</span> results: [<span class="hljs-type">Float</span>]            <span class="hljs-keyword">switch</span> outputTensor.dataType &#123;            <span class="hljs-keyword">case</span> .uInt8:                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> quantization = outputTensor.quantizationParameters <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"No results returned because the quantization values for the output tensor are nil."</span>)                    <span class="hljs-keyword">return</span>                &#125;                <span class="hljs-keyword">let</span> quantizedResults = [<span class="hljs-type">UInt8</span>](outputTensor.data)                results = quantizedResults.<span class="hljs-built_in">map</span> &#123;                    quantization.scale * <span class="hljs-type">Float</span>(<span class="hljs-type">Int</span>($<span class="hljs-number">0</span>) - quantization.zeroPoint)                &#125;            <span class="hljs-keyword">case</span> .float32:                results = outputTensor.data.withUnsafeBytes( &#123; (ptr: <span class="hljs-type">UnsafeRawBufferPointer</span>) <span class="hljs-keyword">in</span>                    [<span class="hljs-type">Float32</span>](<span class="hljs-type">UnsafeBufferPointer</span>.<span class="hljs-keyword">init</span>(start: ptr.baseAddress?.assumingMemoryBound(to: <span class="hljs-type">Float32</span>.<span class="hljs-keyword">self</span>), <span class="hljs-built_in">count</span>: ptr.<span class="hljs-built_in">count</span>))                &#125;)            <span class="hljs-keyword">default</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">"Output tensor data type \(outputTensor.dataType) is unsupported for this app."</span>)                <span class="hljs-keyword">return</span>            &#125;            <span class="hljs-keyword">let</span> resultArray = <span class="hljs-keyword">self</span>.getTopN(results: results)            <span class="hljs-type">DispatchQueue</span>.main.async &#123;                closure(resultArray)            &#125;        &#125;    &#125;</code></pre></div><p>首先我们需要把[Int]类型转换为Data类型提供给interpreter，可以如下方法转换</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">let</span> idData = <span class="hljs-type">Data</span>.<span class="hljs-keyword">init</span>(bytes: idArray, <span class="hljs-built_in">count</span>: idArray.<span class="hljs-built_in">count</span>)</code></pre></div><p><strong>invoke()</strong>方法为调用模型进行预测</p><p>我们拿到输出<strong>outputTensor</strong>以后，它的dataType中的float32类型就是我们需要的输出，这是因为在开源工程中的输出就是float32类型。这里我们需要用swift的指针去把Data类型换为[Float]类型，如下:</p><div class="hljs"><pre><code class="hljs undefined">results = outputTensor.data.withUnsafeBytes( &#123; (<span class="hljs-keyword">ptr</span>: UnsafeRawBufferPointer) in                    [Float32](UnsafeBufferPointer.init(<span class="hljs-keyword">star</span><span class="hljs-variable">t:</span> <span class="hljs-keyword">ptr</span>.baseAddress?.assumingMemoryBound(<span class="hljs-keyword">to</span>: Float32.self), coun<span class="hljs-variable">t:</span> <span class="hljs-keyword">ptr</span>.<span class="hljs-built_in">count</span>))                &#125;)</code></pre></div><p>至于上面那个.UInt8我没有搞懂是什么意思，但我想我的输出都是float32类型，所以应该是不会走上面那个case。</p><p>最后我们通过<strong>getTopN</strong>方法取到前3个可能性最大的标签(预测值)</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTopN</span><span class="hljs-params">(results: [Float])</span></span> -&gt; [<span class="hljs-type">Inference</span>] &#123;        <span class="hljs-comment">//创建元组数组 [(labelIndex: Int, confidence: Float)]</span>        <span class="hljs-keyword">let</span> zippedResults = <span class="hljs-built_in">zip</span>(labels.<span class="hljs-built_in">indices</span>, results)        <span class="hljs-comment">//从大到小排序并选出前resultCount个(根据python工程中的训练，只取前10个，因为分类只有10个)</span>        <span class="hljs-keyword">let</span> sortedResults = zippedResults.sorted &#123; $<span class="hljs-number">0.1</span> &gt; $<span class="hljs-number">1.1</span> &#125;.<span class="hljs-keyword">prefix</span>(resultCount)        <span class="hljs-comment">//返回前resultCount对应的标签以及预测值</span>        <span class="hljs-keyword">return</span> sortedResults.<span class="hljs-built_in">map</span> &#123; result <span class="hljs-keyword">in</span> <span class="hljs-type">Inference</span>.<span class="hljs-keyword">init</span>(confidence: result.<span class="hljs-number">1</span>, label: labels[result.<span class="hljs-number">0</span>]) &#125;    &#125;</code></pre></div><p><strong>这里取的逻辑就像上述所说的，我们只关注输出一维数组的前10个元素，然后给他们排个序取最大三个值，这三个值所在的下标直接在标签数组中取值就能获得对应的预测分类</strong>。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>博客只是一个预览，详细的逻辑还是需要直接看<a href="https://github.com/qyz777/tensorflow_lite_swift_demo" target="_blank" rel="noopener">Demo</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/gaussic/text-classification-cnn-rnn" target="_blank" rel="noopener">CNN-RNN中文文本分类，基于TensorFlow</a><br><a href="https://codelabs.developers.google.com/codelabs/tensorflow-for-poets-2-ios/#0" target="_blank" rel="noopener">TensorFlow for Poets 2: TFLite iOS</a><br><a href="https://www.jianshu.com/p/c13ed339e6a6" target="_blank" rel="noopener">【IOS/Android】TensorflowLite移动端部署</a><br><a href="https://github.com/tensorflow/examples/blob/master/lite/examples/image_classification/ios/ImageClassification/ModelDataHandler/ModelDataHandler.swift" target="_blank" rel="noopener">TensorFlow Lite Swift Example</a><br><a href="https://stackoverflow.com/questions/50632152/tensorflow-convert-pb-file-to-tflite-using-python" target="_blank" rel="noopener">Tensorflow Convert pb file to TFLITE using python</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>TensorFlow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVOController源码全解析</title>
    <link href="/2020/06/27/KVOController%E6%BA%90%E7%A0%81%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/06/27/KVOController%E6%BA%90%E7%A0%81%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在阅读公司源码的一些功能时发现了KVOController这个神奇的库。这个库十分的好用，可以主动的去观察一个对象的属性。</p><p>例如</p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-keyword">self</span>.KVOControllerNonRetaining observe:_test                                    keyPath:<span class="hljs-string">@"test"</span>                                    options:<span class="hljs-number">0</span>                                      block::^(<span class="hljs-keyword">id</span> _Nullable observer, <span class="hljs-keyword">id</span> object, <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *change) &#123;                                                                                &#125;];</code></pre></div><p>KVOController的源码不多，加上分类也就不到800行，所以我花了一段时间阅读它的源码，这篇文章是阅读源码的总结。</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>下图是我通过阅读源码画的UML类图，因为有些偷懒，所以这个类图的方法并不全。但这并不重要，这张类图的意义在于我们能够清晰地看明白他们之间的关系。</p><p><img src="https://cdn.qyizhong.cn/8216167-6d7422401bf1329a.png" srcset="/img/loading.gif" alt="KVOController类图.png"></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="FBKVOInfo"><a href="#FBKVOInfo" class="headerlink" title="_FBKVOInfo"></a>_FBKVOInfo</h2><p>_FBKVOInfo作为一个被两个类组合的类，在KVOController中属于Model的性质，用来保存所需要的内容，以下是这个类拥有的变量</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-variable">__weak</span> FBKVOController *<span class="hljs-variable">_controller</span>;  NSString *<span class="hljs-variable">_keyPath</span>;  NSKeyValueObservingOptions <span class="hljs-variable">_options</span>;  SEL <span class="hljs-variable">_action</span>;  void *<span class="hljs-variable">_context</span>;  FBKVONotificationBlock <span class="hljs-variable">_block</span>;  <span class="hljs-variable">_FBKVOInfoState</span> <span class="hljs-variable">_state</span>;</code></pre></div><h3 id="controller"><a href="#controller" class="headerlink" title="_controller"></a>_controller</h3><p>_FBKVOInfo在FBKVOController中初始化，初始化时就把FBKVOController对象持有了，这里用一个weak修饰防止循环引用</p><h3 id="keyPath"><a href="#keyPath" class="headerlink" title="_keyPath"></a>_keyPath</h3><p>这个应该不怎么需要解释，这个就是KVO观察的keyPath</p><h3 id="options"><a href="#options" class="headerlink" title="_options"></a>_options</h3><p>这个也是KVO观察的设置，是一个枚举，设置不同的枚举KVO效果是不同的，这里就不详细展开了。</p><div class="hljs"><pre><code class="hljs undefined">typedef <span class="hljs-type">NS_OPTIONS</span>(<span class="hljs-type">NSUInteger</span>, <span class="hljs-type">NSKeyValueObservingOptions</span>) &#123;    <span class="hljs-type">NSKeyValueObservingOptionNew</span> = 0x01,    <span class="hljs-type">NSKeyValueObservingOptionOld</span> = 0x02,    <span class="hljs-type">NSKeyValueObservingOptionInitial</span> = 0x04,    <span class="hljs-type">NSKeyValueObservingOptionPrior</span> = 0x08&#125;;</code></pre></div><h3 id="action、-block"><a href="#action、-block" class="headerlink" title="_action、_block"></a>_action、_block</h3><p>这个是用来保存FBKVOController需要调用的方法和block</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文，这个也不多解释</p><h3 id="state"><a href="#state" class="headerlink" title="_state"></a>_state</h3><p>这是一个很重要的枚举，用来保存_FBKVOInfo所对应对象的观察状态</p><div class="hljs"><pre><code class="hljs undefined">typedef NS_ENUM(uint8_t, <span class="hljs-variable">_FBKVOInfoState</span>) &#123;<span class="hljs-comment">// 初始化状态</span>  <span class="hljs-variable">_FBKVOInfoStateInitial</span> = <span class="hljs-number">0</span>,<span class="hljs-comment">// 被观察状态</span>  <span class="hljs-variable">_FBKVOInfoStateObserving</span>,<span class="hljs-comment">// 没被观察状态</span>  <span class="hljs-variable">_FBKVOInfoStateNotObserving</span>,&#125;;</code></pre></div><h2 id="FBKVOController"><a href="#FBKVOController" class="headerlink" title="FBKVOController"></a>FBKVOController</h2><p>FBKVOController是KVOController对外暴露的类，其中我们主要用以下两个方法</p><div class="hljs"><pre><code class="hljs undefined">- <span class="hljs-params">(void)</span>observe:<span class="hljs-params">(nullable id)</span>object keyPath:<span class="hljs-params">(NSString *)</span>keyPath options:<span class="hljs-params">(NSKeyValueObservingOptions)</span>options block:<span class="hljs-params">(FBKVONotificationBlock)</span>block;- <span class="hljs-params">(void)</span>observe:<span class="hljs-params">(nullable id)</span>object keyPath:<span class="hljs-params">(NSString *)</span>keyPath options:<span class="hljs-params">(NSKeyValueObservingOptions)</span>options action:<span class="hljs-params">(SEL)</span>action;</code></pre></div><p>一个是KVO之后的block的回调，另一个是KVO之后调用的方法，下面我们以第一个方法进行讲解。</p><div class="hljs"><pre><code class="hljs undefined">- (<span class="hljs-built_in">void</span>)observe:(nullable id)<span class="hljs-keyword">object</span> keyPath:(<span class="hljs-type">NSString</span> *)keyPath options:(<span class="hljs-type">NSKeyValueObservingOptions</span>)options <span class="hljs-keyword">block</span>:(<span class="hljs-type">FBKVONotificationBlock</span>)<span class="hljs-keyword">block</span>&#123;  <span class="hljs-type">NSAssert</span>(<span class="hljs-number">0</span> != keyPath.length &amp;&amp; <span class="hljs-type">NULL</span> != <span class="hljs-keyword">block</span>, @<span class="hljs-string">"missing required parameters observe:%@ keyPath:%@ block:%p"</span>, <span class="hljs-keyword">object</span>, keyPath, <span class="hljs-keyword">block</span>);  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">nil</span> == <span class="hljs-keyword">object</span> || <span class="hljs-number">0</span> == keyPath.length || <span class="hljs-type">NULL</span> == <span class="hljs-keyword">block</span>) &#123;    <span class="hljs-keyword">return</span>;  &#125;  // create info  _FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath options:options <span class="hljs-keyword">block</span>:<span class="hljs-keyword">block</span>];  // observe <span class="hljs-keyword">object</span> <span class="hljs-keyword">with</span> info  [self _observe:<span class="hljs-keyword">object</span> info:info];&#125;</code></pre></div><p>方法执行步骤:</p><ol><li>断言以及错误判断</li><li>创建一个_FBKVOInfo对象</li><li>调用_observe:info:</li></ol><p>根据上文的结论，我们可以得知_FBKVOInfo是一个Model的存在，所以需要先把它初始化了。</p><div class="hljs"><pre><code class="hljs undefined">- (void)<span class="hljs-variable">_observe</span>:(id)object info:(<span class="hljs-variable">_FBKVOInfo</span> *)info&#123;  <span class="hljs-comment">// lock</span>  pthread_mutex_lock(&amp;<span class="hljs-variable">_lock</span>);  NSMutableSet *infos = [<span class="hljs-variable">_objectInfosMap</span> objectForKey:object];  <span class="hljs-comment">// check for info existence</span>  <span class="hljs-variable">_FBKVOInfo</span> *existingInfo = [infos member:info];  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != existingInfo) &#123;    <span class="hljs-comment">// observation info already exists; do not observe it again</span>    <span class="hljs-comment">// unlock and return</span>    pthread_mutex_unlock(&amp;<span class="hljs-variable">_lock</span>);    return;  &#125;  <span class="hljs-comment">// lazilly create set of infos</span>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == infos) &#123;    infos = [NSMutableSet <span class="hljs-built_in">set</span>];    [<span class="hljs-variable">_objectInfosMap</span> setObject:infos forKey:object];  &#125;  <span class="hljs-comment">// add info and oberve</span>  [infos addObject:info];  <span class="hljs-comment">// unlock prior to callout</span>  pthread_mutex_unlock(&amp;<span class="hljs-variable">_lock</span>);  [[<span class="hljs-variable">_FBKVOSharedController</span> sharedController] observe:object info:info];&#125;</code></pre></div><p>_objectInfosMap是临界资源，所以在这个方法里进行加锁防止资源被争抢。</p><p>方法执行步骤:</p><ol><li>加锁</li><li>判断是否存在，存在即解锁结束，不需要再次观察；不存在则进入步骤3</li><li>判断_objectInfosMap所对应的集合是否存在，存在则继续；不存在则初始化并保存在_objectInfosMap中</li><li>保存新的_FBKVOInfo对象</li><li>解锁</li><li>调用_FBKVOSharedController</li></ol><p>这里涉及到一个知识点是NSMapTable，这是一个类似NSDictionary的容器，但是它不仅能做到key和value之间的映射关系，它也能做到object和object之间的映射关系。这种object和object之间的映射关系在KVOController中体现的很好，每一个被观察者(object)对应一个_FBKVOInfo对象(object)。推荐阅读<a href="http://www.isaced.com/post-235.html" target="_blank" rel="noopener">NSMapTable: 不只是一个能放weak指针的 NSDictionary</a></p><h2 id="FBKVOSharedController"><a href="#FBKVOSharedController" class="headerlink" title="_FBKVOSharedController"></a>_FBKVOSharedController</h2><p>_FBKVOSharedController它是一个单例，这个私有类才是KVOController提供服务的实际实现类。</p><p>我们继续来看_FBKVOSharedController被FBKVOController所调用的方法</p><div class="hljs"><pre><code class="hljs undefined">- (void)observe:(id)object <span class="hljs-meta">info</span>:(nullable _FBKVOInfo *)<span class="hljs-meta">info</span>&#123;  <span class="hljs-meta">if</span> (nil == <span class="hljs-meta">info</span>) &#123;    return<span class="hljs-comment">;</span>  &#125;  // register <span class="hljs-meta">info</span>  pthread_mutex_lock(&amp;_mutex)<span class="hljs-comment">;</span>  [_infos <span class="hljs-keyword">addObject:info];</span>  pthread_mutex_unlock(&amp;_mutex)<span class="hljs-comment">;</span>  // <span class="hljs-keyword">add </span>observer  [object <span class="hljs-keyword">addObserver:self </span>forKeyPath:<span class="hljs-meta">info</span>-&gt;_keyPath options:<span class="hljs-meta">info</span>-&gt;_options context:(void *)<span class="hljs-meta">info</span>]<span class="hljs-comment">;</span>  <span class="hljs-meta">if</span> (<span class="hljs-meta">info</span>-&gt;_state == _FBKVOInfoStateInitial) &#123;    <span class="hljs-meta">info</span>-&gt;_state = _FBKVOInfoStateObserving<span class="hljs-comment">;</span>  &#125; <span class="hljs-meta">else</span> <span class="hljs-meta">if</span> (<span class="hljs-meta">info</span>-&gt;_state == _FBKVOInfoStateNotObserving) &#123;    [object removeObserver:<span class="hljs-keyword">self </span>forKeyPath:<span class="hljs-meta">info</span>-&gt;_keyPath context:(void *)<span class="hljs-meta">info</span>]<span class="hljs-comment">;</span>  &#125;&#125;</code></pre></div><p>方法执行步骤:</p><ol><li>添加临界资源</li><li>注册观察</li><li>判断_FBKVOInfo对象state，若为初始化，则改变为观察中，若为不在观察中，则移除这个观察</li></ol><p>这里涉及到NSHashTable，这个类似于NSSet，本文对此不展开说明。</p><p>之所以说_FBKVOSharedController才是KVOSharedController的实际实现类是因为它实现了KVO的回调方法</p><div class="hljs"><pre><code class="hljs undefined">- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSString</span> *)keyPath                      ofObject:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)object                        change:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *)change                       context:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">void</span> *)context</code></pre></div><p>我们来看一下里面的内容</p><div class="hljs"><pre><code class="hljs undefined">- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSString</span> *)keyPath                      ofObject:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)object                        change:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *)change                       context:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">void</span> *)context&#123;  <span class="hljs-built_in">NSAssert</span>(context, <span class="hljs-string">@"missing context keyPath:%@ object:%@ change:%@"</span>, keyPath, object, change);  _FBKVOInfo *info;  &#123;    <span class="hljs-comment">// lookup context in registered infos, taking out a strong reference only if it exists</span>    pthread_mutex_lock(&amp;_mutex);    info = [_infos member:(__bridge <span class="hljs-keyword">id</span>)context];    pthread_mutex_unlock(&amp;_mutex);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != info) &#123;    <span class="hljs-comment">// take strong reference to controller</span>    FBKVOController *controller = info-&gt;_controller;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != controller) &#123;      <span class="hljs-comment">// take strong reference to observer</span>      <span class="hljs-keyword">id</span> observer = controller.observer;      <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> != observer) &#123;        <span class="hljs-comment">// dispatch custom block or action, fall back to default action</span>        <span class="hljs-keyword">if</span> (info-&gt;_block) &#123;          <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *changeWithKeyPath = change;          <span class="hljs-comment">// add the keyPath to the change dictionary for clarity when mulitple keyPaths are being observed</span>          <span class="hljs-keyword">if</span> (keyPath) &#123;            <span class="hljs-built_in">NSMutableDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *mChange = [<span class="hljs-built_in">NSMutableDictionary</span> dictionaryWithObject:keyPath forKey:FBKVONotificationKeyPathKey];            [mChange addEntriesFromDictionary:change];            changeWithKeyPath = [mChange <span class="hljs-keyword">copy</span>];          &#125;          info-&gt;_block(observer, object, changeWithKeyPath);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info-&gt;_action) &#123;<span class="hljs-meta">#pragma clang diagnostic push</span><span class="hljs-meta">#pragma clang diagnostic ignored <span class="hljs-meta-string">"-Warc-performSelector-leaks"</span></span>          [observer performSelector:info-&gt;_action withObject:change withObject:object];<span class="hljs-meta">#pragma clang diagnostic pop</span>        &#125; <span class="hljs-keyword">else</span> &#123;          [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];        &#125;      &#125;    &#125;  &#125;&#125;</code></pre></div><p>方法执行步骤</p><ol><li>断言</li><li>通过context上下文从临界资源_infos中拿到info</li><li>进行保护，防止持有的FBKVOController和observe为空</li><li>判断_info持有的block或SEL是否存在，存在则调用;不存在则把消息转发给observe</li></ol><p>最后一步调用发现block或者SEL都不存在时必须让object调用，因为observe里可能存在observeValueForKeyPath的实现</p><h2 id="为什么使用FBKVOController不需要移除通知"><a href="#为什么使用FBKVOController不需要移除通知" class="headerlink" title="为什么使用FBKVOController不需要移除通知"></a>为什么使用FBKVOController不需要移除通知</h2><p>在FBKVOController的dealloc里是这样写的</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">dealloc</span>&#123;  <span class="hljs-selector-attr">[self unobserveAll]</span>;  <span class="hljs-selector-tag">pthread_mutex_destroy</span>(&amp;_lock);&#125;</code></pre></div><p>unobserveAll所调用的是</p><div class="hljs"><pre><code class="hljs undefined">- (void)<span class="hljs-variable">_unobserveAll</span>&#123;  <span class="hljs-comment">// lock</span>  pthread_mutex_lock(&amp;<span class="hljs-variable">_lock</span>);  NSMapTable *objectInfoMaps = [<span class="hljs-variable">_objectInfosMap</span> copy];  <span class="hljs-comment">// clear table and map</span>  [<span class="hljs-variable">_objectInfosMap</span> removeAllObjects];  <span class="hljs-comment">// unlock</span>  pthread_mutex_unlock(&amp;<span class="hljs-variable">_lock</span>);  <span class="hljs-variable">_FBKVOSharedController</span> *shareController = [<span class="hljs-variable">_FBKVOSharedController</span> sharedController];  <span class="hljs-keyword">for</span> (id object <span class="hljs-built_in">in</span> objectInfoMaps) &#123;    <span class="hljs-comment">// unobserve each registered object and infos</span>    NSSet *infos = [objectInfoMaps objectForKey:object];    [shareController unobserve:object infos:infos];  &#125;&#125;</code></pre></div><p>可以发现FBKVOController通过遍历Map，把所持有的观察者都一一去除了</p><p>最终调用的方法是_FBKVOSharedController的取消观察方法</p><div class="hljs"><pre><code class="hljs undefined">- (void)unobserve:(id)object infos:(nullable NSSet&lt;<span class="hljs-variable">_FBKVOInfo</span> *&gt; *)infos&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == infos.<span class="hljs-built_in">count</span>) &#123;    return;  &#125;  <span class="hljs-comment">// unregister info</span>  pthread_mutex_lock(&amp;<span class="hljs-variable">_mutex</span>);  <span class="hljs-keyword">for</span> (<span class="hljs-variable">_FBKVOInfo</span> *info <span class="hljs-built_in">in</span> infos) &#123;    [<span class="hljs-variable">_infos</span> removeObject:info];  &#125;  pthread_mutex_unlock(&amp;<span class="hljs-variable">_mutex</span>);  <span class="hljs-comment">// remove observer</span>  <span class="hljs-keyword">for</span> (<span class="hljs-variable">_FBKVOInfo</span> *info <span class="hljs-built_in">in</span> infos) &#123;    <span class="hljs-keyword">if</span> (info-&gt;<span class="hljs-variable">_state</span> == <span class="hljs-variable">_FBKVOInfoStateObserving</span>) &#123;      [object removeObserver:self forKeyPath:info-&gt;<span class="hljs-variable">_keyPath</span> context:(void *)info];    &#125;    info-&gt;<span class="hljs-variable">_state</span> = <span class="hljs-variable">_FBKVOInfoStateNotObserving</span>;  &#125;&#125;</code></pre></div><p>这个方法可以看出来object所对应的_FBKVOSharedController所持有的_FBKVOInfo全部都被removeObserver了</p><h2 id="“NSObject-FBKVOController-h”"><a href="#“NSObject-FBKVOController-h”" class="headerlink" title="“NSObject+FBKVOController.h”"></a>“NSObject+FBKVOController.h”</h2><p>KVOController还有一个NSObject的分类，提供两种方式使用KVOController的懒加载，分别是持有方式和不持有方式。</p><div class="hljs"><pre><code class="hljs undefined">- (FBKVOController *)KVOController&#123;  <span class="hljs-keyword">id</span> controller = objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSObjectKVOControllerKey</span>);    <span class="hljs-comment">// lazily create the KVOController</span>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == controller) &#123;    controller = [FBKVOController controllerWithObserver:<span class="hljs-keyword">self</span>];    <span class="hljs-keyword">self</span>.KVOController = controller;  &#125;    <span class="hljs-keyword">return</span> controller;&#125;- (FBKVOController *)KVOControllerNonRetaining&#123;  <span class="hljs-keyword">id</span> controller = objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSObjectKVOControllerNonRetainingKey</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == controller) &#123;    controller = [[FBKVOController alloc] initWithObserver:<span class="hljs-keyword">self</span> retainObserved:<span class="hljs-literal">NO</span>];    <span class="hljs-keyword">self</span>.KVOControllerNonRetaining = controller;  &#125;    <span class="hljs-keyword">return</span> controller;&#125;</code></pre></div><p>他们的区别就是被观察者的内存管理机制是strong还是weak，前者是strong，后者是weak。</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学的回忆与总结</title>
    <link href="/2020/06/25/%E5%A4%A7%E5%AD%A6%E7%9A%84%E5%9B%9E%E5%BF%86%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/25/%E5%A4%A7%E5%AD%A6%E7%9A%84%E5%9B%9E%E5%BF%86%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>前几天发现学信网上的学籍状态变更为已毕业，想着之前规划好的毕业回忆与总结也必须趁着端午节动手了。原计划是拿了双证之后再动手填这个坑，但没想到是尽管我人身在北京，竟然连学校都没办法去，双证也不知何时才能到手。</p><p>我坐在电脑前仔细回想这四年，发现这四年并如平常文章所说的快的一转眼就过去。对我来说，大学的四年不仅十分漫长与曲折，还夹杂一些痛苦。现在回头想想，高中简直是我最快乐的时光，只需要一心一意学习就行，而我甚至还没有全身心的投入到学习中。</p><p>高中毕业的时候，我就认定了我要去学习计算机专业，而且认定必须去大城市学。可惜的是我分不太够，只能在北京选了一个普通的高校。我的不少同学都认为这所高校十分坑人，因为它收的分同比较高但学校硬件又非常次。我在考虑志愿的时候就已经仔细了解了这所学校的条件，但我还是决定要来，因为想要在分不够的前提下去大城市学习计算机专业，那真是没得选。虽然亲自来了之后还是被学校硬件条件的糟糕而震撼，比如周六无法洗澡、宿舍竟然还没有我以前的卧室大。但是不管怎么样都是我自己选的，也没什么好抱怨的。</p><p>由于一些说来话长的原因，我在刚进大学后就认为自己应该尽早独立强大起来，因此我也不想错过任何机会。当时在贴吧上知道了我校两个实力强大的技术社团，一个是与机器人相关的社团（我忘了名字）另一个是ifLab。前者在主校区而且面试的时间被放到很后，我就放弃面试了。后者就在我们健翔桥校区，我就去参加了它的面试。还记得当时接到面试通知的时候发现一个特别有趣的事情，就是它有面试题。我还记得当年的面试题是写简单的网页，多亏了高中毕业时学的Python，我就花了3小时简单的学习就搞定了这道面试题。在面试的时候我不仅展示了面试题也展示了我自学的Python相关的内容。最后结果非常符合预期，那就是我成功加入了ifLab。我在加入ifLab之前填写的志愿是去Android组，不过不知为何我却被分到了iOS组。想想这都是命呀，iOS APP的开发之后变成了我的工作内容。也正是因为进了iOS组吧，我就买了一台MacBook Air。当时带我的是hubo学长，在他的带领下我学习了一些新鲜的事情，开始接触Linux。写到这里突然想起来我接触Linux的过程实在有趣。我们学校是没法个人拉网线搞Wi-Fi而且限制使用设备只有两台，这让我十分的恼火。有一天偶然间从hubo学长口中得知可以用路由器连接学校网，我就兴奋的买了两台廉价路由器开始了我的折腾之旅。想想也真是好笑，我的大一上学期除了写写C语言，基本就在折腾这两台路由器，最后竟然还是没有成功。到了大一下学期我就放弃折腾它们了，因为我实在是没有成功过，没办法从中获得快感也就失去了兴趣。</p><p>在大一的时候我想明白了许多事情，比如说学校中的很多事情毫无意义，要做有收益的能够让自己成长的事情。后来我在字节跳动学到了一个词就是ROI（投资回报率），用在大学生活中非常合适，不做需要投资时间但却没有回报的事情。另外大一对我来说算是个好的开始，由于不断的刷题以及一些之前学Python的基础，我的C语言拿了100分，也算是对得起自己的努力吧。到了大一下以后我的兴趣就转移了，C语言的学习成果让我决定尝试一些进阶的事情，比如说游戏开发。</p><p>那时我兴致勃勃的下载了虚幻4引擎，买了一大堆关于虚幻4开发的电子书。但很快我对它就失去了兴趣，因为我发现游戏开发不仅需要代码能力，还需要许多模型，而我对建模并不感兴趣。因此我在练手时只能用商城里的模型，而绝大多数模型又是要付费的，这对我来说真是个极大的劝退。在对游戏开发失去兴趣之后我决定好好把这学期的C++学好，再考一个100分。不过很可惜的是最后机考时错了两道选择题才考了96。</p><p>在这一年中我很少去ifLab的实验室，因为我觉得躺在宿舍里敲代码非常的舒服。我一直有一种迷之自信认为我能够在嘈杂的环境中专心学习，有趣的是我发现这竟然是事实。但是在宿舍躺着写代码会让腰很酸，这一年后我感觉自己已经撑不住了，所以我在大一的暑假就决定去ifLab实验室学习。在这个暑假我也做了一个影响我人生的决定，那就是开始学习iOS开发。兜兜转转一年，我突然想起我还有一台MacBook Air，我觉得既然花了钱就不要浪费，试着自学一下iOS开发吧。就是没想到呀，这一学就上瘾了。一开始我是学习swift的，但是网上关于swift的资料实在是太少了，我在花了一周摸索之后就决定放弃学习swift转向OC。当时觉得写OC特别有意思，按照高学长所说的，它的每一行代码都用中括号扩起来，就宛如对话一般优雅。这种认知甚至我在学会OC之后认为Java非常的繁琐和啰嗦。当然，当我彻底使用swift开发的时候，我才意识到OC和Java就是半斤八两，一样很啰嗦，只不过前者晦涩难懂，后者长得一副大家都会写的样子。</p><p>后来到了大二了，我就开始经常去ifLab实验室了。这段时间认识了不少人，也得到了不少练手的机会。最开始认识的是付佬、pj和高学长。关于付佬，我最想不通的事情就是为什么他天天都在打游戏最后却保送去了清华，这可能就是大佬吧。pj呢，他这个时候正在走一个自己开的深坑，那就是翘课去实习。很庆幸认识他，让我后来翘课去实习几乎没走弯路。当时pj刚刚结束完一段实习，所以我经常能在实验室看到他。由于他是学习iOS开发的学长，我在平时练手的时候有很多不会的地方就可以直接问他。大家应该会有一种体验，就是刚入门时很多编程的坑是在搜索引擎中很难搜索到的，如果这个时候有人指点一下就可以很快明白。学了一段时间之后呢，他安排了我和xzk一起重新开发iBistu，这是个很有趣的事情，因为这是我参与的第一款上架APP。我在这段开发中也学会了很多技能，包括terminal、git和SourceTree的使用，对Xcode和Mac的使用也更加熟练了。现在我和pj还有xzk都在西瓜开发iOS，真是没想到大家最后竟然成为了同事。</p><p>同时在大二上学期呢，高学长给我安排了一些事情做，是一些计算机博弈相关的事情。那时我思想上还太年轻，也不愿意放弃任何机会，只要交给我的我都大包大揽。当时我评上了一个国家级大创项目，是在iOS上开发一个苏拉卡尔塔棋的APP，并打算用一些机器学习相关的知识。这真是个深坑，如果说当时我的能力是1，那么这个项目的难度就是我能力的两倍。接了这个事情之后呢，我不仅要开发iBistu，也要开发棋，我只能开始并行做事。往常下课的时间用来写代码已经完全不够用，我开始占用上课的时间写代码。这段时间真是相当的充实，我能感觉到iBistu和棋的开发让我成长的非常迅速。</p><p>不过，开心的时间总是特别少，留给我安心成长的时间也很短暂。正如我大一所担心的那样，由于一些说来话长的原因，我在大二下学期失去了生活费。我是一个有骨气的男人，定下了一个不再向家里要钱的决心。我准备试一试让自己独立起来，看看自己到底有几斤几两。在此之后，我的生活一下就转变了，因为我意识到一个残酷的现实，学习可以暂缓和休息，但是如果不工作，我甚至没法活下去。也就是这个时候，我的人生方向一下从学习转变为活下去。当时我认为虽然是要去工作，但是也要做能够让自己成长的事情。对于当时沉迷于iOS开发的我来说，去应聘iOS开发实习生肯定是个好选择。再和pj聊了一段时间之后，我终于下定决心翘课去实习。说实话这么多年来大学期间我才第一次翘课，刚开始翘课时我心里还是有很多不安，后来随着翘课次数的变多我也慢慢变得毫无感觉。</p><p>当时我就对我的大学职业生涯进行了一次三级跳的规划，那就是第一次实习去小公司，第二次实习去大公司，第三次实习去BAT。于是我开始执行我的第一个规划，我在Boss直聘上投递了不少小公司，最后拿了两个offer。当时面试时我的计算机基础知识十分匮乏，老板让我写一个冒泡排序，我都写成了选择排序。最后我选择了一家做女性直播交友的公司，也就是Lespark。写到这想起来真是十分感谢pj和高学长，这两个offer就是靠着iBistu和苏拉卡尔塔棋APP拿下来的。</p><p>在实习之外呢，我也在晚上下班后和周末的时间做一些写网站的外包工作，于是我开始并行做四件事情。那时我还不懂ROI，但是我能意识到我不能把时间分配给收益较低的事情，于是苏拉卡尔塔棋的开发就几乎被我放弃了，因为我已经在它上获得了足够的收益。我现在回想起来，我大二下的这段时间已经不能用压力山大来形容了，我觉得当时我已经被压到就剩一口气了。我根本没有除了睡觉以外任何的休息时间，早晨7点15起床准备去从学校赶去西二旗上班，晚上7点下班准时走人回学校。到8点回到学校后快速的洗个澡就开始外包的开发到11点回宿舍休息。在工作日更专注于实习，而休息日就进行全天的外包开发。大家都知道学一门新的东西是很痛苦的，我在接下外包的时候甚至连网站的前后端都不知如何系统的进行开发。现在想想这可能就是社会的毒打吧，还好我是一个很硬的弹簧，即使压力山大我也还能扛住。这段时间我也第一次发现自己竟然营养不良，因为我长出了棕黄的头发，这在我身上是从未发生过的事情。4个月后这段实习协议到期了，我选择结束它不再续约，因为我真得非常疲惫，我认为我需要休息一段时间。这4个月的时间让我发现赚钱如此的辛苦，我每天早上7点15起床，晚上7点下班竟然一个月到手还不到4k，到这个时候我才能感受到以前我说的某些话是多么好笑。</p><p>休息了两周，我意识到我只有不断的去实习才能维持我的日常开销，因此我开始我的第二段职业规划。很庆幸的是，我的第二段经历非常的顺利，面试的第一个公司是网易，当天就拿到了口头offer，于是我就这么被网易新闻收留了。只有真正进了大公司后才知道为什么要劝学生毕业后去大公司，因为大公司与创业公司相比真的很不一样。首先与创业公司相比，大公司的整体流程非常规范，我个人认为在学校所学的<code>软件工程</code>这门课远没有直接在大公司实战而了解的更深刻。其次是工程复杂度与代码质量更高，我在网易新闻的实习提高了我对iOS开发的认知也很有效的提升了我的代码质量。如果用造楼来形容开发工作，那么在创业公司你只能造平房，在大公司则可以在高楼大厦里造各种各样的房间，而且要造的非常严谨才行，这是很不一样的体验。最后是福利，免费的三餐和下午茶（虽然后来没了）。下午茶我经常能吃到水果真是感受到十分幸福，因为当时我在学校觉得水果太贵舍不得买来吃。</p><p>18年底到19年过年前在网易的这段时间里逐渐成长的更加强大了，同时也让身体适应了工作，即使身有压力也不会再觉得犹如山大。这期间我也有幸开始参与了CrazyE的开发并一直维护它到今年初，这是一个课表APP，我在它的开发上使用了许多在网易学来的新鲜知识，有效强化了我对iOS开发的认知。</p><p>19年过年后回来很快就是20届的春招了，我虽然不准备去别的公司实习但是也打算出去面一圈看看自己水平如何。当时抽空面了不少大公司，无一例外都是败在了算法和计算机基础上。那一个月对我的打击真是十分巨大，我意识到翘课给我带来的巨大后果，那就是计算机基础不扎实。但同时我又很庆幸，我能够及时开始学习计算机基础并开始刷题。留给我的时间不多，我也不能放弃实习，所以我不得不开始白天上班晚上和周末学习的生活。当时坐地铁来回的时间非常长，我就在地铁上学习计算机网络，看一些面试经验的帖子思考如果是我被问这个问题的话我要如何回答。晚上和休息日就在实验室刷leetcode，刷算法题其实真的挺痛苦的，我刚开始刷的时候甚至怀疑我是不是白学计算机了。之后看了一些算法相关的课程，才意识到算法题跟高中数学有着相似之处，它们的解法都是有套路的甚至不少都有模板，很多题把模板列好，把题目往里一塞就解好了。虽然刷题很痛苦，但是我也强迫自己去喜欢上刷题，让自己每天不刷两题就心里闷得慌。现在打开leetcode上发现其实我刷的也不多，也就263道题。但是我在刷完算法题后发现了我的代码质量和工作中实际的问题解决能力又有巨大的提升，不得不说刷算法是真的有用。接着我又回顾了操作系统和编译原理，编译原理真是个令人着迷的学科，当时我喜欢它到去学了一些llvm的知识并且用swift写出了一个基于llvm为后端的demo语言。后来我甚至想要写一门完整的语言作为毕业设计，但是随着不断的编写和学习，在我掌握了不少知识后我对此失去了兴趣，这门语言也就这么太监了。</p><p>这段时间倒是过的非常快，很快就到了7月份的秋招提前批，我开始实施我的第三个规划了。我的秋招第一次面试就是字节跳动，我在这家公司的面试已经fail了好几次了，而且7月初的我也并不是准备的特别好。不过很幸运的是，我还是顺利拿到了offer。但是我在二面的时候竟然说不出哈希的原理，这让我十分恼火，自己的水平真是太菜了。但是我并没有因为拿到offer而停止学习，而是把在计算机基础和算法上的学习重心重新倾向到了iOS上。这段时间我也在网易新闻做iOS 13和dark mode的适配，遇到了许多奇奇怪怪的问题，也因此而成长。于是到8月底的时候我终于感觉到自己遇到了某种瓶颈，我个人觉得我的水平达到一个阶段的顶点应该是在这个时候。另外，这段时间内我还陆续也在面腾讯和阿里，但是这两个公司实在是太能拖了，拖到我都要去字节实习了还没面完，而且一个要去深圳一个要去杭州，最后想想就算了，于是我就开始在面试上放飞自我了。</p><p>迫于大四上的实习课程，我不得不在9月份立马去字节实习。因此也有个比较可惜的事，就是网易新闻的iOS 13以及dark mode的适配没能在我手上完整做完。刚来到西瓜视频以后也就马上开始参与bug的修复和iOS 13的适配。不得不说，字节跳动培养新人的机制确实没有网易来的完善。在网易的时候，需求都是leader和同事们统一开完需求评审会后分配，后续 有项管处理杂事，也有统一的站会来抛出问题，最后需求统一上车发版本。而在字节跳动，每个需求都需要自己跟进，靠自己完整的跑完整个流程，遇到问题也需要自己来推进，需求跟上哪个版本就上哪个版本，非常的敏捷开发。几个需求后我就开始自己一人跑整个开发流程，还记得第一次一个人去一个评审会连da说的埋点含义都不知道，导致了错误的开发，最后重写了一部分的代码。而且字节跳动的开发工具链体系特别庞大，技术栈特别丰富，刚进来的那段时间感觉真是有点自闭。不过说实话，在这种环境下能够适应的话，人的成长真的非常快。每个双月之后我都能发现自己明显比之前厉害不少，许多之前认为是面试造火箭的知识，没想到都逐渐在工作中用到。我有很多之前面试时不是特别理解的技术知识点，都因为要解决实际问题而逐渐理解。</p><p>也是因为去了字节跳动吧，终于有足够的收入能够搬出去住了，我期待这件事真是很久了。因为我的睡眠特别的浅，舍友一旦打呼噜我一晚就凉了，各种助眠方法都试过了，可惜就是没啥用。吐槽一下北京租房是真的黑，一间8平米的房间竟然就要3k6，不过也算是提高了非常的多的幸福感。毕竟之前上下班来回要2个半小时，还要担心偶尔没得洗澡和呼噜声，现在不仅睡的香而且只要骑车10分钟就能到公司了。从大四开始我的心情就非常愉悦，感觉自己的生活正式的走在了马路上了而不是在小勾勾里艰难前行。19年底我喜欢上了一门有趣的运动，那就是射箭，不得不说，射中黄心的感觉如同投篮空心命中一般让人心里舒爽。在这段疫情过去之后，等我能练习到开26磅的弓时，就是时候买一把属于自己的弓了。</p><p>20年到现在为止一切都还算顺利，心路历程不曲折，不仅兑现了带女友去泰国度假的承诺，还搬到了一个一居室里，感觉自己的生活质量再次提高，就是钱包有点空。唯一让人有些沮丧的就是因为北京的疫情，我没法执行我规划已久的毕业旅行了。现在毕业了，突然感觉到周末没有往日的繁忙有些无法适应，不知道应该做些什么。昨天努力思考了一下，觉得我应该开一个新坑，再开发一款教育类型的APP，就这么决定了吧。</p><p>在大学中，不仅要学会自学，也要学会独立思考，但是在大学中基本上没有人会告诉你要这么做。我的运气算好，我一直以来都习惯于自学，没想到在大学中却成了非常良好的技能。另一件运气好的事就是加入了ifLab，我实在难以想象如果我的大学没有加入这个社团会多么曲折。回忆起BISTU，我觉得能让我开心的也只有在ifLab实验室里写代码和讨论的时光。还记得ifLab创立的初衷有一条就是让社团成员毕业时具有一年工作经验的水平，我觉得我可以勉强厚着脸皮说自己达到了。</p><p>我的大学总的来说算是一段很曲折的故事，尤其是在大三的时候由于学业和实习冲突，导致我非常期待早日毕业，因为呆在学校已经无法让我成长了甚至会拖累我。我意识到，学校的许多课程是毫无用处的，自己才会知道做什么事情对自己的成长帮助最大。一些老师觉得学生应该按照自己的规划来在新手村慢慢练级，殊不知像我这样的学生早就已经走出新手村开始自由探索。至于考不考研这些问题，这是完全依赖于自己的背景以及自己的思考，并不是老师说考研好就去考研。我很早就明白，大学是一个需要长期奋斗和自我思考的地方，跟着老师的节奏走不一定好也不一定不好。我希望读这篇文章的学弟学妹们都能独立思考，清醒的、客观的意识到自己到底需要什么，这种思考需要抛开老师和家人的说辞，只有这样思考后得出的结论才是你所需要的。后来我思考了很多，我觉得大学教育对于我这样的学生应该学会放手，因为我知道什么时候做什么事情，也有很强的自我驱动能力。当然还是感谢大部分老师对我的放手，能够信任我并给我机会，让我能够顺利完成学业。写到这里还是需要再次感谢pj，因为他告诉我了各种学业上的坑，我才能达到没有挂科的完成学业，同时也很感谢各位在期末考前帮助我复习的同学们。</p><p>我的人生在下个月即将开启新的篇章，写下这篇文章也是为了回忆和反思这四年所发生的事情。前路漫漫，人生曲长，希望我正式走出象牙塔后的日子里也能较为顺利。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大二至大三实习一年，你想知道的这里都有</title>
    <link href="/2020/06/25/%E5%A4%A7%E4%BA%8C%E8%87%B3%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0%E4%B8%80%E5%B9%B4%EF%BC%8C%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%99%E9%87%8C%E9%83%BD%E6%9C%89/"/>
    <url>/2020/06/25/%E5%A4%A7%E4%BA%8C%E8%87%B3%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0%E4%B8%80%E5%B9%B4%EF%BC%8C%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E8%BF%99%E9%87%8C%E9%83%BD%E6%9C%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我还很清晰的记得2018年4月25日是我第一天实习，在这步入社会的一年里，我的心态发生了很大的变化。说是一年，其实也并不是完整的一年，我在18年9月份的时候休息了整整一个月，当然也顺便利用这段时间去面试拿到了下一个offer。因为第一次实习发现工作真的是太累了，能理解到长辈赚钱真的很不容易，我自己也体会到当码农的感觉。写代码是我的一个爱好，尤其是写iOS。但是当爱好转化为我的工作进行输出时，我在工作的时间内就不会觉得那会让我愉悦了，而会让我很疲惫。</p><p>一年来不断有学弟学妹问我怎么做到大二出去实习的，ta想向我学习该怎么做。鉴于总是有人问，我觉得这个事情可以记录下来作为我的一个生活和反思相关的blog吧。</p><p>重要的话先写到最前面，经过一年的实习，我本人认为尽可能<strong>避免大二出去实习</strong>。</p><h1 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h1><p>在你想要了解我是如何做到大二出去实习的之前，你应该仔细思考一下自己究竟想要什么，这个是十分重要的。如果你要考研，那么这条路对你来说非常不合适。如果你要毕业就工作，那么这条路对你来说<strong>也许</strong>会合适。</p><h1 id="如何大二出去实习"><a href="#如何大二出去实习" class="headerlink" title="如何大二出去实习"></a>如何大二出去实习</h1><h2 id="保证你的学习成绩"><a href="#保证你的学习成绩" class="headerlink" title="保证你的学习成绩"></a>保证你的学习成绩</h2><p>最重要也是最关键的一点，你得保证你不能挂科。因为你一旦挂科就意味着你接下来的学期就会有更多的事情积压在你的身上，你的包袱就会越来越大直到压着你喘不过气，当然如果你抗压能力足够强大，即使有包袱也没啥对吧。看到这里一定会有同学好奇了，那去外面实习都不上课，怎么能不挂科呢？这个说起来真是个技术活。</p><p>那么翘课最重要的技能是什么呢？是学会沟通。在我看来沟通技能是十分重要的，尽管你以后有可能是个程序员，但是作为软件工程师，沟通这个技能非常重要。首先你需要让老师意识到你是个能力足够的孩子，你考试能过，实验也ok，技术也ok。如何证明你技术ok呢？你可以拿到offer以后再去跟老师商量。你需要让老师知道你是本科毕业就工作的，不会考虑考研。其次，既然你想要出去实习，那分数肯定不会那么好看，世界上没有这么好的事情。那么平时分能跟老师争取到及格最好，不行的话那就看自己考试和实验成绩咯。这一年来我有N门课的平时分不及格，但我一样能过。提醒一下，与老师沟通的时候态度很重要，你要上去说话就冲，一副自己最牛逼的样子，那肯定不会让你出去的。最后，有些老师就是不放你出去怎么办呢？我的答案就是没办法，老老实实上课呗。其实也有办法，那就看你人际交往关系如何了XD。</p><h2 id="足够的技术能力"><a href="#足够的技术能力" class="headerlink" title="足够的技术能力"></a>足够的技术能力</h2><p>这个也一样是必须满足的条件，如果你满足不了这个条件，我相信你连offer都拿不到。那么如何保证大二的自己拥有足够的技术能力呢？不说别的，我校大一上那C语言那么简单，不考个满分说不过去吧？大一下那C++/Java也很简单，不说满分，也得考个90+吧。说这些什么意思就是要在大一打好编程基础。出去实习是很硬核的，人家公司就是要招个实习生过来写业务的，不是白养你的，尤其是创业公司，所以一定会对你的技术有要求。</p><p>在大一打好基础是远远不够的，为什么不够呢，因为你还没有一个有一定深度了解的方向。可以是前端、后端或者是客户端，像我就是一直在写iOS，所以一定要有一个自己专研过的方向。但是你自己的专研不够呀，你没有经验啊，怎么办呢？我认为最好的解决方案就是不要放过学长学姐提供的机会。其实很多学长学姐都有非常好的能够让你实践的机会，要么是你没发现，要么是你懒，<strong>机会都是自己把握的</strong>。不断的把握机会就会让别人觉得你靠谱，下一次还有这种机会也会继续找你。当你让你身边的人意识到你靠谱的时候，有些事情你就要看情况接手了，因为这个时候可能你已经非常忙了。我有一段时间很懊悔自己抓住了太多事情而让自己忙到没有休息的时间，我目前最高记录是并行处理4件事吧，那几个月忙到没工夫花钱，花呗一个月花了7块hhh。</p><p>抓住了不少机会后，我相信你在我校的同级学生中已经拥有一份还可以的简历了，这个时候你可能还是不具备拿到offer的条件。为什么呢？因为你没有面试经验。我认为最好的解决办法就是直接去面试。App Store打开找到几个实习找工作的App一顿下载，比如实习僧、Boss直聘和拉钩之类的，然后打开App一顿猛投，接着就等HR给你打电话吧。具体的面试踩坑细节就不展开了，说一些一开始需要注意的吧。我还记得我的第一份工作的Boss上来问我的第一句是：“哦，大四了吧”，我说：“我才大二”。我能明显的看到Boss身体一震，一脸惊讶。Boss问我是否有时间，这个时候我就是把我的真实情况告诉他，但是我强调了我是可以调出足够的时间实习的。</p><p>至于如何找到一家靠谱的实习公司这里也不展开说了，但是有一点很重要，你要是实习没工资，那绝对不靠谱。</p><h2 id="保证你自己的时间"><a href="#保证你自己的时间" class="headerlink" title="保证你自己的时间"></a>保证你自己的时间</h2><p>这一条不是必须的，但是我觉得对我来说是必须的。因为拥有自己的时间才能继续提高自己，大二出去实习所拥有的技术水平和真正毕业所面对的校招要求的技术水平还是有很大差距的。也正是因为如此，大二出去实习就会异常的忙碌，你还需要抽出时间来学习和提高自己。我刚上班的那一两个月，每天下班回来就想休息或者打游戏，其他啥也不想干了，因为很累。但是一段时间后我就觉得这样是不行的，我开始下班回来接着做自己的事情或者学习和提高自己。之所以能做到这样是因为一方面我逐渐适应了这样的生活，除了发版前之外并不会感到特别疲惫了，另一方面是我足够自律。所以为了前程考虑，大二出去实习还得足够的自律。</p><h1 id="为何需要大二出去实习"><a href="#为何需要大二出去实习" class="headerlink" title="为何需要大二出去实习"></a>为何需要大二出去实习</h1><p>我想说道这个事情，可能就会有很多人想到要尽快提升自己的能力balabala。这个说的没错，不管自己在学校搞什么项目，终究是学习主导的，并没有经过企业级历练，是不完善的。经过企业开发实战，无论从技术还是从眼界来看，都会有较大提升。</p><p>不过我个人认为还是有其他必要原因的，比如说现在互联网就业环境不好以及门槛较高，身在象牙塔中的学生可能并未意识到这件事情。尤其我校并不是名校，起点可以算是非常低了，为了校招能得到大厂的面试机会，一份丰富的简历是很有必要的，而一份丰富的简历所必要的就是实习经验。这里有一点要强调一下，能被面试，说明你已经过了简历筛选，意味着之后的流程与你在哪个学校无关，<strong>也意味着之后的流程需要靠你的真本事</strong>。</p><p>至于我个人必须大二出去实习的原因则是我大二下的时候没有生活费了XD，为了活下去我只好出去实习咯hhh。</p><h1 id="为什么我不建议大二出去实习"><a href="#为什么我不建议大二出去实习" class="headerlink" title="为什么我不建议大二出去实习"></a>为什么我不建议大二出去实习</h1><p>上面说了这么多如何做，来讲讲为什么我在前言里说不建议大二出去实习。我是没有生活费没办法，但是读这篇文章的你不一定。</p><h2 id="占用你的大量时间"><a href="#占用你的大量时间" class="headerlink" title="占用你的大量时间"></a>占用你的大量时间</h2><p>北京的计算机相关工作都集中在西二旗、知春路、中关村、马连洼、上地和望京，你可以计算一下你的路程花费的时间，然后再加上965的工作时间，看看总共多少时间。大学的时候要花大量的时间来打基础，我一开始就觉得深入掌握一门技术即可，但结果就是我现在在回头补计算机网络、操作系统以及算法。很多公司面试的时候并不care你在这个方向上有多少深度，在他们看来，3年以内的工作经验跟应届都差不多。他们往往在乎你基础是否扎实，是否能手写算法，因为这些才是计算机体系中几乎不变的，而就业方向与其所需技能是容易变的。下面是我某一周的时间安排。</p><p><img src="https://cdn.qyizhong.cn/8216167-50ecaed6844986bd.jpg" srcset="/img/loading.gif" alt="我一周的时间安排"></p><h2 id="压力太大"><a href="#压力太大" class="headerlink" title="压力太大"></a>压力太大</h2><p>我校大四之前是不允许实习的，也就是说一旦出去就要面对学校的学习压力以及工作压力。学习压力还是小事，因为我校的考试确实不会很难。但是工作压力是个大事，我们在自己做项目的时候buffer是很充足的，有的时候真不想写了可以缓一缓明天再写，可是工作中就不能这样了，做不完你可走不了。讲道理是下班时间到了你就可以走，可要是项目进度卡在你这里你敢走吗？我一年来坚信着不能让事情卡在我这里的道理，但是我又想早点回去，所以很多时候我都会牺牲中午的休息时间。当然目前我在网易的工作会轻松一些，一方面是自己的技能越来越熟练了，另一方面是自己接手的需求都会自己预估工期，会给自己预留buffer。</p><p>看到这里吧，我相信有些人会觉得压力大没关系，我也行。我这里只提醒一下，一旦选择这条路，你就马上要并行处理两条线的事情，分别是工作与学校的事情。在学校的时候觉得学校的事情没什么，但你工作的时候突然有个学校的事情就不会让你心情舒服了。接着你还要提升自己的实力，于是你又多开了一个线程用来学习和提升自己的能力，所以在我看来，最终的你至少并行在做三件事。不过我认为这是自己的选择，但是在选择之前还是思考一下<strong>自己到底要什么</strong>。</p><p>当然，我不推荐的是大二的日常实习，如果有暑期实习的机会，这个机会一定不要放过。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>一年的实习经验让我经历了不少有趣的事情，也让我见识到了市场的残酷，而我逐渐的意识到自己只是个普通人。如果问我是否后悔，我不会后悔，因为这是我当时最好的选择。曾经有人问我“你以后还有几十年要工作，为什么那么着急？”。当时我只觉得不着急就会被淘汰，现在反思后却觉得在大二这个时间点，我努力的方向却不是那么对。</p><p>最后的最后，用一句话总结我一年来最大也是最多的体会：“小时候真傻，竟然期望长大”。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DispatchGroup出现EXC_BAD_INSTRUCTION问题</title>
    <link href="/2020/06/25/DispatchGroup%E5%87%BA%E7%8E%B0EXC-BAD-INSTRUCTION%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/25/DispatchGroup%E5%87%BA%E7%8E%B0EXC-BAD-INSTRUCTION%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看app的线上奔溃总是出现意义不明的崩溃问题，而且崩溃栈出现在闭包的回调里，并且bugly上提示说是有可能在swift解包的时候出现问题，也就是对nil使用了!。这就完全误导了我，把我对问题的理解定义为数据保护的不够到位。结果就是在多次发版后这个问题还未得到解决，所以我绝对对这个问题一探究竟。</p><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><p>其实出现这个问题的原因很简单，那就是group的enter和leave没有成对出现。比如说我们会在闭包的回调里去leave，但是闭包有可能返回多次，一旦多leave了，那么就会出现<strong>EXC_BAD_INSTRUCTION</strong>这个问题。</p><p>举个例子</p><p>我们声明如下两个方法，可以看出来work2回调了两次</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work1</span><span class="hljs-params">(closure: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;    sleep(<span class="hljs-number">1</span>)    closure()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work2</span><span class="hljs-params">(closure: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;    closure()    sleep(<span class="hljs-number">2</span>)    closure()&#125;</code></pre></div><p>接着我们使用它们</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">super</span>.viewDidLoad()        <span class="hljs-keyword">let</span> group = <span class="hljs-type">DispatchGroup</span>()    <span class="hljs-keyword">let</span> queue = <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">"test"</span>, qos: .background, attributes: .concurrent, autoreleaseFrequency: .inherit, target: <span class="hljs-literal">nil</span>)        group.enter()    queue.async &#123;        <span class="hljs-keyword">self</span>.work1 &#123;            group.leave()        &#125;    &#125;        group.enter()    queue.async &#123;        <span class="hljs-keyword">self</span>.work2 &#123;            group.leave()        &#125;    &#125;        group.notify(queue: queue) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">"同步完成"</span>)    &#125;&#125;</code></pre></div><p>这里可以看出来在work2的闭包的leave就会出现这个问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>其实这种问题完全使我们编写代码的过程中不够细心导致的，通过完善的测试用例完全可以避免问题发生，但是我们还是需要记住一句话<strong>DispatchGroup的enter和leave必须成对出现!!!</strong></p>]]></content>
    
    
    <categories>
      
      <category>Crash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UITableView和UICollectionView实现自定义滚动动画</title>
    <link href="/2020/06/25/UITableView%E5%92%8CUICollectionView%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB/"/>
    <url>/2020/06/25/UITableView%E5%92%8CUICollectionView%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到这个标题你可能会觉得“这不是很简单吗？像下面这么一写就完了呗”</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">UIView</span><span class="hljs-selector-class">.animate</span>(<span class="hljs-attribute">withDuration</span>: <span class="hljs-number">0.25</span>) &#123;    <span class="hljs-selector-tag">self</span><span class="hljs-selector-class">.tableView</span><span class="hljs-selector-class">.setContentOffset</span>(CGPoint(<span class="hljs-attribute">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">y</span>: <span class="hljs-number">500</span>), <span class="hljs-attribute">animated</span>: false)&#125;</code></pre></div><p>不不不，如果你觉得就这么简单的话说明你还是太年轻了。这样写你的列表在滚动的一开始上面的cell就消失了，这种效果是完全过不了产品和视觉小姐姐的像素眼。</p><p>为了实现自定义滚动动效我们可以使用CADisplayLink来实现，至于为什么不用其他timer相信大家可以自己百度了解。</p><p>当然如果你并不想那么麻烦的自己写的话可以使用Facebook出品的Pop动画库，它也是基于CADisplayLink实现的。由于UIScrollView的滚动原理，我们可以用<code>POPBasicAnimation</code>设置UIScrollView的<code>bounds</code>属性动画即可。</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://github.com/qyz777/scroll_animation" target="_blank" rel="noopener">自定义列表滚动动效</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h2><p>首先我们先实现实际动画的类<code>ScrollViewAnimator</code>。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollViewAnimator</span> </span>&#123;        <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> scrollView: <span class="hljs-type">UIScrollView?</span>    <span class="hljs-keyword">let</span> timingFunction: <span class="hljs-type">ScrollTimingFunction</span>        <span class="hljs-keyword">var</span> closure: (() -&gt; <span class="hljs-type">Void</span>)?        <span class="hljs-comment">//动画开始时间</span>    <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>    <span class="hljs-comment">//动画初始的contentOffset</span>    <span class="hljs-keyword">var</span> startOffset: <span class="hljs-type">CGPoint</span> = .zero    <span class="hljs-comment">//动画目标的contentOffset</span>    <span class="hljs-keyword">var</span> destinationOffset: <span class="hljs-type">CGPoint</span> = .zero    <span class="hljs-comment">//动画时长</span>    <span class="hljs-keyword">var</span> duration: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>    <span class="hljs-comment">//动画已运行时长</span>    <span class="hljs-keyword">var</span> runTime: <span class="hljs-type">TimeInterval</span> = <span class="hljs-number">0</span>        <span class="hljs-keyword">var</span> timer: <span class="hljs-type">CADisplayLink?</span>        <span class="hljs-keyword">init</span>(scrollView: <span class="hljs-type">UIScrollView</span>, timingFunction: <span class="hljs-type">ScrollTimingFunction</span>) &#123;        <span class="hljs-keyword">self</span>.scrollView = scrollView        <span class="hljs-keyword">self</span>.timingFunction = timingFunction    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setContentOffset</span><span class="hljs-params">(<span class="hljs-number">_</span> contentOffset: CGPoint, duration: TimeInterval)</span></span> &#123;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scrollView = scrollView <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-comment">//设置需要的属性</span>        startTime = <span class="hljs-type">Date</span>().timeIntervalSince1970        startOffset = scrollView.contentOffset        destinationOffset = contentOffset        <span class="hljs-keyword">self</span>.duration = duration        runTime = <span class="hljs-number">0</span>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">self</span>.duration &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> &#123;            scrollView.setContentOffset(contentOffset, animated: <span class="hljs-literal">false</span>)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">if</span> timer == <span class="hljs-literal">nil</span> &#123;            timer = <span class="hljs-type">CADisplayLink</span>(target: <span class="hljs-keyword">self</span>, selector: #selector(animtedScroll))            <span class="hljs-comment">//把timer加入到common的runloop中</span>            timer?.add(to: .main, forMode: .common)        &#125;    &#125;        <span class="hljs-meta">@objc</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animtedScroll</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> timer = timer <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> scrollView = scrollView <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;        <span class="hljs-comment">//由于CADisplayLink每次回调的时间不固定，所以使用它自己记录的回调时间来增加运行时长</span>        runTime += timer.duration        <span class="hljs-keyword">if</span> runTime &gt;= duration &#123;            <span class="hljs-comment">//如果运行时长超过动画时长说明动画需要结束了</span>            scrollView.setContentOffset(destinationOffset, animated: <span class="hljs-literal">false</span>)            timer.invalidate()            <span class="hljs-keyword">self</span>.timer = <span class="hljs-literal">nil</span>            closure?()            <span class="hljs-keyword">return</span>        &#125;                <span class="hljs-keyword">var</span> offset = scrollView.contentOffset        offset.x = timingFunction.compute(<span class="hljs-type">CGFloat</span>(runTime), startOffset.x, destinationOffset.x - startOffset.x, <span class="hljs-type">CGFloat</span>(duration))        offset.y = timingFunction.compute(<span class="hljs-type">CGFloat</span>(runTime), startOffset.y, destinationOffset.y - startOffset.y, <span class="hljs-type">CGFloat</span>(duration))        scrollView.setContentOffset(offset, animated: <span class="hljs-literal">false</span>)    &#125;    &#125;</code></pre></div><h2 id="UIScrollView拓展"><a href="#UIScrollView拓展" class="headerlink" title="UIScrollView拓展"></a>UIScrollView拓展</h2><p>我们用OC的runtime知识动态为分类添加属性方便使用</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIScrollView</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AssociatedKeys</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> animator: <span class="hljs-type">String</span> = <span class="hljs-string">"animator"</span>    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> animator: <span class="hljs-type">ScrollViewAnimator?</span> &#123;        <span class="hljs-keyword">set</span> &#123;            objc_setAssociatedObject(<span class="hljs-keyword">self</span>, &amp;<span class="hljs-type">AssociatedKeys</span>.animator, newValue, .<span class="hljs-type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)        &#125;        <span class="hljs-keyword">get</span> &#123;            <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, &amp;<span class="hljs-type">AssociatedKeys</span>.animator) <span class="hljs-keyword">as</span>? <span class="hljs-type">ScrollViewAnimator</span>        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setContentOffset</span><span class="hljs-params">(<span class="hljs-number">_</span> contentOffset: CGPoint, duration: TimeInterval, timingFunction: ScrollTimingFunction = .linear, completion: <span class="hljs-params">(<span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)? = <span class="hljs-literal">nil</span>) &#123;        <span class="hljs-keyword">if</span> animator == <span class="hljs-literal">nil</span> &#123;            animator = <span class="hljs-type">ScrollViewAnimator</span>(scrollView: <span class="hljs-keyword">self</span>, timingFunction: timingFunction)        &#125;        animator!.closure = &#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> strongSelf = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;            <span class="hljs-type">DispatchQueue</span>.main.async &#123;                strongSelf.animator = <span class="hljs-literal">nil</span>            &#125;            completion?()        &#125;        animator!.setContentOffset(contentOffset, duration: duration)    &#125;    &#125;</code></pre></div><h2 id="ScrollTimingFunction枚举"><a href="#ScrollTimingFunction枚举" class="headerlink" title="ScrollTimingFunction枚举"></a>ScrollTimingFunction枚举</h2><p>动画缓冲函数的实现可以参考<a href="http://robertpenner.com/easing/" target="_blank" rel="noopener">http://robertpenner.com/easing/</a>。具体实现例子在<a href="https://github.com/qyz777/scroll_animation" target="_blank" rel="noopener">Demo</a>中</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://robertpenner.com/easing/" target="_blank" rel="noopener">http://robertpenner.com/easing/</a><br><a href="https://blog.csdn.net/S_clifftop/article/details/89490422" target="_blank" rel="noopener">https://blog.csdn.net/S_clifftop/article/details/89490422</a><br><a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="noopener">https://zsisme.gitbooks.io/ios-/content/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
